(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
    get: (a4, b4) => (typeof require !== "undefined" ? require : a4)[b4]
  }) : x4)(function(x4) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x4 + '" is not supported');
  });
  var __esm = (fn4, res) => function __init() {
    return fn4 && (res = (0, fn4[__getOwnPropNames(fn4)[0]])(fn4 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/@popperjs/core/lib/enums.js
  var top2, bottom2, right2, left2, auto2, basePlacements2, start2, end2, clippingParents2, viewport2, popper2, reference2, variationPlacements2, placements2, beforeRead2, read2, afterRead2, beforeMain2, main2, afterMain2, beforeWrite2, write2, afterWrite2, modifierPhases2;
  var init_enums = __esm({
    "../../node_modules/@popperjs/core/lib/enums.js"() {
      top2 = "top";
      bottom2 = "bottom";
      right2 = "right";
      left2 = "left";
      auto2 = "auto";
      basePlacements2 = [top2, bottom2, right2, left2];
      start2 = "start";
      end2 = "end";
      clippingParents2 = "clippingParents";
      viewport2 = "viewport";
      popper2 = "popper";
      reference2 = "reference";
      variationPlacements2 = /* @__PURE__ */ basePlacements2.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start2, placement + "-" + end2]);
      }, []);
      placements2 = /* @__PURE__ */ [].concat(basePlacements2, [auto2]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start2, placement + "-" + end2]);
      }, []);
      beforeRead2 = "beforeRead";
      read2 = "read";
      afterRead2 = "afterRead";
      beforeMain2 = "beforeMain";
      main2 = "main";
      afterMain2 = "afterMain";
      beforeWrite2 = "beforeWrite";
      write2 = "write";
      afterWrite2 = "afterWrite";
      modifierPhases2 = [beforeRead2, read2, afterRead2, beforeMain2, main2, afterMain2, beforeWrite2, write2, afterWrite2];
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName2(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  var init_getNodeName = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow2(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  var init_getWindow = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getWindow.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement3(node) {
    var OwnElement = getWindow2(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement2(node) {
    var OwnElement = getWindow2(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot2(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow2(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  var init_instanceOf = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js"() {
      init_getWindow();
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles2(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement2(element) || !getNodeName2(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect5(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement2(element) || !getNodeName2(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default2;
  var init_applyStyles = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/applyStyles.js"() {
      init_getNodeName();
      init_instanceOf();
      applyStyles_default2 = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles2,
        effect: effect5,
        requires: ["computeStyles"]
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement3(placement) {
    return placement.split("-")[0];
  }
  var init_getBasePlacement = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getBasePlacement.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/math.js
  var max2, min2, round2;
  var init_math = __esm({
    "../../node_modules/@popperjs/core/lib/utils/math.js"() {
      max2 = Math.max;
      min2 = Math.min;
      round2 = Math.round;
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString2() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  var init_userAgent = __esm({
    "../../node_modules/@popperjs/core/lib/utils/userAgent.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport2() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString2());
  }
  var init_isLayoutViewport = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js"() {
      init_userAgent();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect2(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement2(element)) {
      scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement3(element) ? getWindow2(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport2() && isFixedStrategy;
    var x4 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y4,
      right: x4 + width,
      bottom: y4 + height,
      left: x4,
      x: x4,
      y: y4
    };
  }
  var init_getBoundingClientRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js"() {
      init_instanceOf();
      init_math();
      init_getWindow();
      init_isLayoutViewport();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect2(element) {
    var clientRect = getBoundingClientRect2(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  var init_getLayoutRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js"() {
      init_getBoundingClientRect();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains2(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot2(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  var init_contains = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/contains.js"() {
      init_instanceOf();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow2(element).getComputedStyle(element);
  }
  var init_getComputedStyle = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js"() {
      init_getWindow();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement2(element) {
    return ["table", "td", "th"].indexOf(getNodeName2(element)) >= 0;
  }
  var init_isTableElement = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js"() {
      init_getNodeName();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement2(element) {
    return ((isElement3(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  var init_getDocumentElement = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js"() {
      init_instanceOf();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode2(element) {
    if (getNodeName2(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot2(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement2(element)
    );
  }
  var init_getParentNode = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js"() {
      init_getNodeName();
      init_getDocumentElement();
      init_instanceOf();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent2(element) {
    if (!isHTMLElement2(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock2(element) {
    var isFirefox = /firefox/i.test(getUAString2());
    var isIE = /Trident/i.test(getUAString2());
    if (isIE && isHTMLElement2(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode2(element);
    if (isShadowRoot2(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement2(currentNode) && ["html", "body"].indexOf(getNodeName2(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent2(element) {
    var window2 = getWindow2(element);
    var offsetParent = getTrueOffsetParent2(element);
    while (offsetParent && isTableElement2(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent2(offsetParent);
    }
    if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock2(element) || window2;
  }
  var init_getOffsetParent = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js"() {
      init_getWindow();
      init_getNodeName();
      init_getComputedStyle();
      init_instanceOf();
      init_isTableElement();
      init_getParentNode();
      init_userAgent();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement2(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  var init_getMainAxisFromPlacement = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/within.js
  function within2(min3, value, max3) {
    return max2(min3, min2(value, max3));
  }
  function withinMaxClamp2(min3, value, max3) {
    var v4 = within2(min3, value, max3);
    return v4 > max3 ? max3 : v4;
  }
  var init_within = __esm({
    "../../node_modules/@popperjs/core/lib/utils/within.js"() {
      init_math();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject2() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  var init_getFreshSideObject = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject2(paddingObject) {
    return Object.assign({}, getFreshSideObject2(), paddingObject);
  }
  var init_mergePaddingObject = __esm({
    "../../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js"() {
      init_getFreshSideObject();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap2(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var init_expandToHashMap = __esm({
    "../../node_modules/@popperjs/core/lib/utils/expandToHashMap.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/arrow.js
  function arrow2(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets3 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement3(state.placement);
    var axis = getMainAxisFromPlacement2(basePlacement);
    var isVertical = [left2, right2].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets3) {
      return;
    }
    var paddingObject = toPaddingObject3(options.padding, state);
    var arrowRect = getLayoutRect2(arrowElement);
    var minProp = axis === "y" ? top2 : left2;
    var maxProp = axis === "y" ? bottom2 : right2;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets3[axis] - state.rects.popper[len];
    var startDiff = popperOffsets3[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent2(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min3 = paddingObject[minProp];
    var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset3 = within2(min3, center, max3);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
  }
  function effect6(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains2(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var toPaddingObject3, arrow_default2;
  var init_arrow = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/arrow.js"() {
      init_getBasePlacement();
      init_getLayoutRect();
      init_contains();
      init_getOffsetParent();
      init_getMainAxisFromPlacement();
      init_within();
      init_mergePaddingObject();
      init_expandToHashMap();
      init_enums();
      toPaddingObject3 = function toPaddingObject4(padding, state) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
          placement: state.placement
        })) : padding;
        return mergePaddingObject2(typeof padding !== "number" ? padding : expandToHashMap2(padding, basePlacements2));
      };
      arrow_default2 = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow2,
        effect: effect6,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation2(placement) {
    return placement.split("-")[1];
  }
  var init_getVariation = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getVariation.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  function roundOffsetsByDPR2(_ref, win) {
    var x4 = _ref.x, y4 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(x4 * dpr) / dpr || 0,
      y: round2(y4 * dpr) / dpr || 0
    };
  }
  function mapToStyles2(_ref2) {
    var _Object$assign2;
    var popper3 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x4 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x4,
      y: y4
    }) : {
      x: x4,
      y: y4
    };
    x4 = _ref3.x;
    y4 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left2;
    var sideY = top2;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent2(popper3);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow2(popper3)) {
        offsetParent = getDocumentElement2(popper3);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top2 || (placement === left2 || placement === right2) && variation === end2) {
        sideY = bottom2;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y4 -= offsetY - popperRect.height;
        y4 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left2 || (placement === top2 || placement === bottom2) && variation === end2) {
        sideX = right2;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x4 -= offsetX - popperRect.width;
        x4 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides2);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR2({
      x: x4,
      y: y4
    }, getWindow2(popper3)) : {
      x: x4,
      y: y4
    };
    x4 = _ref4.x;
    y4 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x4 + "px, " + y4 + "px)" : "translate3d(" + x4 + "px, " + y4 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x4 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles2(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement3(state.placement),
      variation: getVariation2(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles2(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles2(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var unsetSides2, computeStyles_default2;
  var init_computeStyles = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/computeStyles.js"() {
      init_enums();
      init_getOffsetParent();
      init_getWindow();
      init_getDocumentElement();
      init_getComputedStyle();
      init_getBasePlacement();
      init_getVariation();
      init_math();
      unsetSides2 = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      computeStyles_default2 = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles2,
        data: {}
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  function effect7(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow2(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive2);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive2);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive2);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive2);
      }
    };
  }
  var passive2, eventListeners_default2;
  var init_eventListeners = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/eventListeners.js"() {
      init_getWindow();
      passive2 = {
        passive: true
      };
      eventListeners_default2 = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn2() {
        },
        effect: effect7,
        data: {}
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  function getOppositePlacement2(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash3[matched];
    });
  }
  var hash3;
  var init_getOppositePlacement = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js"() {
      hash3 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  function getOppositeVariationPlacement2(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash4[matched];
    });
  }
  var hash4;
  var init_getOppositeVariationPlacement = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js"() {
      hash4 = {
        start: "end",
        end: "start"
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll2(node) {
    var win = getWindow2(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  var init_getWindowScroll = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js"() {
      init_getWindow();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX2(element) {
    return getBoundingClientRect2(getDocumentElement2(element)).left + getWindowScroll2(element).scrollLeft;
  }
  var init_getWindowScrollBarX = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js"() {
      init_getBoundingClientRect();
      init_getDocumentElement();
      init_getWindowScroll();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect2(element, strategy) {
    var win = getWindow2(element);
    var html = getDocumentElement2(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x4 = 0;
    var y4 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport2();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x4 = visualViewport.offsetLeft;
        y4 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x4 + getWindowScrollBarX2(element),
      y: y4
    };
  }
  var init_getViewportRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js"() {
      init_getWindow();
      init_getDocumentElement();
      init_getWindowScrollBarX();
      init_isLayoutViewport();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect2(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement2(element);
    var winScroll = getWindowScroll2(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x4 = -winScroll.scrollLeft + getWindowScrollBarX2(element);
    var y4 = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x4 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x4,
      y: y4
    };
  }
  var init_getDocumentRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js"() {
      init_getDocumentElement();
      init_getComputedStyle();
      init_getWindowScrollBarX();
      init_getWindowScroll();
      init_math();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent2(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  var init_isScrollParent = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js"() {
      init_getComputedStyle();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent2(node) {
    if (["html", "body", "#document"].indexOf(getNodeName2(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement2(node) && isScrollParent2(node)) {
      return node;
    }
    return getScrollParent2(getParentNode2(node));
  }
  var init_getScrollParent = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js"() {
      init_getParentNode();
      init_isScrollParent();
      init_getNodeName();
      init_instanceOf();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents2(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent2(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow2(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent2(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents2(getParentNode2(target)))
    );
  }
  var init_listScrollParents = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js"() {
      init_getScrollParent();
      init_getParentNode();
      init_getWindow();
      init_isScrollParent();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect2(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  var init_rectToClientRect = __esm({
    "../../node_modules/@popperjs/core/lib/utils/rectToClientRect.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect2(element, strategy) {
    var rect = getBoundingClientRect2(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType2(element, clippingParent, strategy) {
    return clippingParent === viewport2 ? rectToClientRect2(getViewportRect2(element, strategy)) : isElement3(clippingParent) ? getInnerBoundingClientRect2(clippingParent, strategy) : rectToClientRect2(getDocumentRect2(getDocumentElement2(element)));
  }
  function getClippingParents2(element) {
    var clippingParents3 = listScrollParents2(getParentNode2(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement2(element) ? getOffsetParent2(element) : element;
    if (!isElement3(clipperElement)) {
      return [];
    }
    return clippingParents3.filter(function(clippingParent) {
      return isElement3(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName2(clippingParent) !== "body";
    });
  }
  function getClippingRect2(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents2(element) : [].concat(boundary);
    var clippingParents3 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents3[0];
    var clippingRect = clippingParents3.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType2(element, clippingParent, strategy);
      accRect.top = max2(rect.top, accRect.top);
      accRect.right = min2(rect.right, accRect.right);
      accRect.bottom = min2(rect.bottom, accRect.bottom);
      accRect.left = max2(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType2(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  var init_getClippingRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js"() {
      init_enums();
      init_getViewportRect();
      init_getDocumentRect();
      init_listScrollParents();
      init_getOffsetParent();
      init_getDocumentElement();
      init_getComputedStyle();
      init_instanceOf();
      init_getBoundingClientRect();
      init_getParentNode();
      init_contains();
      init_getNodeName();
      init_rectToClientRect();
      init_math();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets2(_ref) {
    var reference3 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement3(placement) : null;
    var variation = placement ? getVariation2(placement) : null;
    var commonX = reference3.x + reference3.width / 2 - element.width / 2;
    var commonY = reference3.y + reference3.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top2:
        offsets = {
          x: commonX,
          y: reference3.y - element.height
        };
        break;
      case bottom2:
        offsets = {
          x: commonX,
          y: reference3.y + reference3.height
        };
        break;
      case right2:
        offsets = {
          x: reference3.x + reference3.width,
          y: commonY
        };
        break;
      case left2:
        offsets = {
          x: reference3.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference3.x,
          y: reference3.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement2(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference3[len] / 2 - element[len] / 2);
          break;
        case end2:
          offsets[mainAxis] = offsets[mainAxis] + (reference3[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }
  var init_computeOffsets = __esm({
    "../../node_modules/@popperjs/core/lib/utils/computeOffsets.js"() {
      init_getBasePlacement();
      init_getVariation();
      init_getMainAxisFromPlacement();
      init_enums();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow2(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents2 : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport2 : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper2 : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject2(typeof padding !== "number" ? padding : expandToHashMap2(padding, basePlacements2));
    var altContext = elementContext === popper2 ? reference2 : popper2;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect2(isElement3(element) ? element : element.contextElement || getDocumentElement2(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect2(state.elements.reference);
    var popperOffsets3 = computeOffsets2({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect2(Object.assign({}, popperRect, popperOffsets3));
    var elementClientRect = elementContext === popper2 ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper2 && offsetData) {
      var offset3 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right2, bottom2].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top2, bottom2].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset3[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  var init_detectOverflow = __esm({
    "../../node_modules/@popperjs/core/lib/utils/detectOverflow.js"() {
      init_getClippingRect();
      init_getDocumentElement();
      init_getBoundingClientRect();
      init_computeOffsets();
      init_rectToClientRect();
      init_enums();
      init_instanceOf();
      init_mergePaddingObject();
      init_expandToHashMap();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement2(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements2 : _options$allowedAutoP;
    var variation = getVariation2(placement);
    var placements3 = variation ? flipVariations ? variationPlacements2 : variationPlacements2.filter(function(placement2) {
      return getVariation2(placement2) === variation;
    }) : basePlacements2;
    var allowedPlacements = placements3.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements3;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow2(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement3(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a4, b4) {
      return overflows[a4] - overflows[b4];
    });
  }
  var init_computeAutoPlacement = __esm({
    "../../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js"() {
      init_getVariation();
      init_enums();
      init_detectOverflow();
      init_getBasePlacement();
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements2(placement) {
    if (getBasePlacement3(placement) === auto2) {
      return [];
    }
    var oppositePlacement = getOppositePlacement2(placement);
    return [getOppositeVariationPlacement2(placement), oppositePlacement, getOppositeVariationPlacement2(oppositePlacement)];
  }
  function flip2(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement3(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement2(preferredPlacement)] : getExpandedFallbackPlacements2(preferredPlacement));
    var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement3(placement2) === auto2 ? computeAutoPlacement2(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements3[0];
    for (var i4 = 0; i4 < placements3.length; i4++) {
      var placement = placements3[i4];
      var _basePlacement = getBasePlacement3(placement);
      var isStartVariation = getVariation2(placement) === start2;
      var isVertical = [top2, bottom2].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow2(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right2 : left2 : isStartVariation ? bottom2 : top2;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement2(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement2(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i3) {
        var fittingPlacement = placements3.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i3).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
        var _ret = _loop(_i2);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default2;
  var init_flip = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/flip.js"() {
      init_getOppositePlacement();
      init_getBasePlacement();
      init_getOppositeVariationPlacement();
      init_detectOverflow();
      init_computeAutoPlacement();
      init_enums();
      init_getVariation();
      flip_default2 = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip2,
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets2(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped2(overflow) {
    return [top2, right2, bottom2, left2].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide2(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow2(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow2(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets2(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets2(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped2(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped2(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default2;
  var init_hide = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/hide.js"() {
      init_enums();
      init_detectOverflow();
      hide_default2 = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide2
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY2(placement, rects, offset3) {
    var basePlacement = getBasePlacement3(placement);
    var invertDistance = [left2, top2].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
      placement
    })) : offset3, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left2, right2].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset2(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements2.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY2(placement, state.rects, offset3);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x4 = _data$state$placement.x, y4 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x4;
      state.modifiersData.popperOffsets.y += y4;
    }
    state.modifiersData[name] = data;
  }
  var offset_default2;
  var init_offset = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/offset.js"() {
      init_getBasePlacement();
      init_enums();
      offset_default2 = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset2
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets2(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets2({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default2;
  var init_popperOffsets = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js"() {
      init_computeOffsets();
      popperOffsets_default2 = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets2,
        data: {}
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis2(axis) {
    return axis === "x" ? "y" : "x";
  }
  var init_getAltAxis = __esm({
    "../../node_modules/@popperjs/core/lib/utils/getAltAxis.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow2(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow2(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement3(state.placement);
    var variation = getVariation2(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement2(basePlacement);
    var altAxis = getAltAxis2(mainAxis);
    var popperOffsets3 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets3) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top2 : left2;
      var altSide = mainAxis === "y" ? bottom2 : right2;
      var len = mainAxis === "y" ? "height" : "width";
      var offset3 = popperOffsets3[mainAxis];
      var min3 = offset3 + overflow[mainSide];
      var max3 = offset3 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect2(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject2();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within2(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent2(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset3 + maxOffset - offsetModifierValue;
      var preventedOffset = within2(tether ? min2(min3, tetherMin) : min3, offset3, tether ? max2(max3, tetherMax) : max3);
      popperOffsets3[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset3;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top2 : left2;
      var _altSide = mainAxis === "x" ? bottom2 : right2;
      var _offset = popperOffsets3[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top2, left2].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp2(_tetherMin, _offset, _tetherMax) : within2(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets3[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default2;
  var init_preventOverflow = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"() {
      init_enums();
      init_getBasePlacement();
      init_getMainAxisFromPlacement();
      init_getAltAxis();
      init_within();
      init_getLayoutRect();
      init_getOffsetParent();
      init_detectOverflow();
      init_getVariation();
      init_getFreshSideObject();
      init_math();
      preventOverflow_default2 = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow2,
        requiresIfExists: ["offset"]
      };
    }
  });

  // ../../node_modules/@popperjs/core/lib/modifiers/index.js
  var init_modifiers = __esm({
    "../../node_modules/@popperjs/core/lib/modifiers/index.js"() {
      init_applyStyles();
      init_arrow();
      init_computeStyles();
      init_eventListeners();
      init_flip();
      init_hide();
      init_offset();
      init_popperOffsets();
      init_preventOverflow();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll2(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  var init_getHTMLElementScroll = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll2(node) {
    if (node === getWindow2(node) || !isHTMLElement2(node)) {
      return getWindowScroll2(node);
    } else {
      return getHTMLElementScroll2(node);
    }
  }
  var init_getNodeScroll = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js"() {
      init_getWindowScroll();
      init_getWindow();
      init_instanceOf();
      init_getHTMLElementScroll();
    }
  });

  // ../../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled2(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round2(rect.width) / element.offsetWidth || 1;
    var scaleY = round2(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect2(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement2(offsetParent);
    var offsetParentIsScaled = isHTMLElement2(offsetParent) && isElementScaled2(offsetParent);
    var documentElement = getDocumentElement2(offsetParent);
    var rect = getBoundingClientRect2(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName2(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent2(documentElement)) {
        scroll = getNodeScroll2(offsetParent);
      }
      if (isHTMLElement2(offsetParent)) {
        offsets = getBoundingClientRect2(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX2(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  var init_getCompositeRect = __esm({
    "../../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js"() {
      init_getBoundingClientRect();
      init_getNodeScroll();
      init_getNodeName();
      init_instanceOf();
      init_getWindowScrollBarX();
      init_getDocumentElement();
      init_isScrollParent();
      init_math();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order2(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers2(modifiers) {
    var orderedModifiers = order2(modifiers);
    return modifierPhases2.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  var init_orderModifiers = __esm({
    "../../node_modules/@popperjs/core/lib/utils/orderModifiers.js"() {
      init_enums();
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce3(fn4) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn4());
          });
        });
      }
      return pending;
    };
  }
  var init_debounce = __esm({
    "../../node_modules/@popperjs/core/lib/utils/debounce.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName2(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var init_mergeByName = __esm({
    "../../node_modules/@popperjs/core/lib/utils/mergeByName.js"() {
    }
  });

  // ../../node_modules/@popperjs/core/lib/createPopper.js
  function areValidElements2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator2(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers4 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS2 : _generatorOptions$def2;
    return function createPopper5(reference3, popper3, options) {
      if (options === void 0) {
        options = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS2, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference3,
          popper: popper3
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options2);
          state.scrollParents = {
            reference: isElement3(reference3) ? listScrollParents2(reference3) : reference3.contextElement ? listScrollParents2(reference3.contextElement) : [],
            popper: listScrollParents2(popper3)
          };
          var orderedModifiers = orderModifiers2(mergeByName2([].concat(defaultModifiers4, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m4) {
            return m4.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference4 = _state$elements.reference, popper4 = _state$elements.popper;
          if (!areValidElements2(reference4, popper4)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect2(reference4, getOffsetParent2(popper4), state.options.strategy === "fixed"),
            popper: getLayoutRect2(popper4)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn4 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn4 === "function") {
              state = fn4({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce3(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements2(reference3, popper3)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect8 = _ref.effect;
          if (typeof effect8 === "function") {
            var cleanupFn = effect8({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn4) {
          return fn4();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var DEFAULT_OPTIONS2, createPopper2;
  var init_createPopper = __esm({
    "../../node_modules/@popperjs/core/lib/createPopper.js"() {
      init_getCompositeRect();
      init_getLayoutRect();
      init_listScrollParents();
      init_getOffsetParent();
      init_orderModifiers();
      init_debounce();
      init_mergeByName();
      init_detectOverflow();
      init_instanceOf();
      DEFAULT_OPTIONS2 = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      createPopper2 = /* @__PURE__ */ popperGenerator2();
    }
  });

  // ../../node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers2, createPopper3;
  var init_popper_lite = __esm({
    "../../node_modules/@popperjs/core/lib/popper-lite.js"() {
      init_createPopper();
      init_eventListeners();
      init_popperOffsets();
      init_computeStyles();
      init_applyStyles();
      defaultModifiers2 = [eventListeners_default2, popperOffsets_default2, computeStyles_default2, applyStyles_default2];
      createPopper3 = /* @__PURE__ */ popperGenerator2({
        defaultModifiers: defaultModifiers2
      });
    }
  });

  // ../../node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers3, createPopper4;
  var init_popper = __esm({
    "../../node_modules/@popperjs/core/lib/popper.js"() {
      init_createPopper();
      init_eventListeners();
      init_popperOffsets();
      init_computeStyles();
      init_applyStyles();
      init_offset();
      init_flip();
      init_preventOverflow();
      init_arrow();
      init_hide();
      init_modifiers();
      defaultModifiers3 = [eventListeners_default2, popperOffsets_default2, computeStyles_default2, applyStyles_default2, offset_default2, flip_default2, preventOverflow_default2, arrow_default2, hide_default2];
      createPopper4 = /* @__PURE__ */ popperGenerator2({
        defaultModifiers: defaultModifiers3
      });
    }
  });

  // ../../node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain2,
    afterRead: () => afterRead2,
    afterWrite: () => afterWrite2,
    applyStyles: () => applyStyles_default2,
    arrow: () => arrow_default2,
    auto: () => auto2,
    basePlacements: () => basePlacements2,
    beforeMain: () => beforeMain2,
    beforeRead: () => beforeRead2,
    beforeWrite: () => beforeWrite2,
    bottom: () => bottom2,
    clippingParents: () => clippingParents2,
    computeStyles: () => computeStyles_default2,
    createPopper: () => createPopper4,
    createPopperBase: () => createPopper2,
    createPopperLite: () => createPopper3,
    detectOverflow: () => detectOverflow2,
    end: () => end2,
    eventListeners: () => eventListeners_default2,
    flip: () => flip_default2,
    hide: () => hide_default2,
    left: () => left2,
    main: () => main2,
    modifierPhases: () => modifierPhases2,
    offset: () => offset_default2,
    placements: () => placements2,
    popper: () => popper2,
    popperGenerator: () => popperGenerator2,
    popperOffsets: () => popperOffsets_default2,
    preventOverflow: () => preventOverflow_default2,
    read: () => read2,
    reference: () => reference2,
    right: () => right2,
    start: () => start2,
    top: () => top2,
    variationPlacements: () => variationPlacements2,
    viewport: () => viewport2,
    write: () => write2
  });
  var init_lib = __esm({
    "../../node_modules/@popperjs/core/lib/index.js"() {
      init_enums();
      init_modifiers();
      init_createPopper();
      init_popper();
      init_popper_lite();
    }
  });

  // ../../node_modules/@eonasdan/tempus-dominus/dist/plugins/fa-five.js
  var require_fa_five = __commonJS({
    "../../node_modules/@eonasdan/tempus-dominus/dist/plugins/fa-five.js"(exports, module) {
      (function(g4, f4) {
        typeof exports === "object" && typeof module !== "undefined" ? f4(exports) : typeof define === "function" && define.amd ? define(["exports"], f4) : (g4 = typeof globalThis !== "undefined" ? globalThis : g4 || self, f4((g4.tempusDominus = g4.tempusDominus || {}, g4.tempusDominus.plugins = g4.tempusDominus.plugins || {}, g4.tempusDominus.plugins.fa_five = {})));
      })(exports, function(exports2) {
        "use strict";
        const faFiveIcons = {
          type: "icons",
          time: "fas fa-clock",
          date: "fas fa-calendar",
          up: "fas fa-arrow-up",
          down: "fas fa-arrow-down",
          previous: "fas fa-chevron-left",
          next: "fas fa-chevron-right",
          today: "fas fa-calendar-check",
          clear: "fas fa-trash",
          close: "fas fa-times"
        };
        const load2 = (_4, __, tdFactory) => {
          tdFactory.DefaultOptions.display.icons = faFiveIcons;
        };
        exports2.faFiveIcons = faFiveIcons;
        exports2.load = load2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "../../node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t5, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4() : "function" == typeof define && define.amd ? define(e4) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs = e4();
      }(exports, function() {
        "use strict";
        var t5 = 1e3, e4 = 6e4, n4 = 36e5, r4 = "millisecond", i4 = "second", s4 = "minute", u4 = "hour", a4 = "day", o4 = "week", c4 = "month", f4 = "quarter", h4 = "year", d4 = "date", l4 = "Invalid Date", $5 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M4 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t6) {
          var e5 = ["th", "st", "nd", "rd"], n5 = t6 % 100;
          return "[" + t6 + (e5[(n5 - 20) % 10] || e5[n5] || e5[0]) + "]";
        } }, m4 = function(t6, e5, n5) {
          var r5 = String(t6);
          return !r5 || r5.length >= e5 ? t6 : "" + Array(e5 + 1 - r5.length).join(n5) + t6;
        }, v4 = { s: m4, z: function(t6) {
          var e5 = -t6.utcOffset(), n5 = Math.abs(e5), r5 = Math.floor(n5 / 60), i5 = n5 % 60;
          return (e5 <= 0 ? "+" : "-") + m4(r5, 2, "0") + ":" + m4(i5, 2, "0");
        }, m: function t6(e5, n5) {
          if (e5.date() < n5.date()) return -t6(n5, e5);
          var r5 = 12 * (n5.year() - e5.year()) + (n5.month() - e5.month()), i5 = e5.clone().add(r5, c4), s5 = n5 - i5 < 0, u5 = e5.clone().add(r5 + (s5 ? -1 : 1), c4);
          return +(-(r5 + (n5 - i5) / (s5 ? i5 - u5 : u5 - i5)) || 0);
        }, a: function(t6) {
          return t6 < 0 ? Math.ceil(t6) || 0 : Math.floor(t6);
        }, p: function(t6) {
          return { M: c4, y: h4, w: o4, d: a4, D: d4, h: u4, m: s4, s: i4, ms: r4, Q: f4 }[t6] || String(t6 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t6) {
          return void 0 === t6;
        } }, g4 = "en", D4 = {};
        D4[g4] = M4;
        var p4 = "$isDayjsObject", S4 = function(t6) {
          return t6 instanceof _4 || !(!t6 || !t6[p4]);
        }, w4 = function t6(e5, n5, r5) {
          var i5;
          if (!e5) return g4;
          if ("string" == typeof e5) {
            var s5 = e5.toLowerCase();
            D4[s5] && (i5 = s5), n5 && (D4[s5] = n5, i5 = s5);
            var u5 = e5.split("-");
            if (!i5 && u5.length > 1) return t6(u5[0]);
          } else {
            var a5 = e5.name;
            D4[a5] = e5, i5 = a5;
          }
          return !r5 && i5 && (g4 = i5), i5 || !r5 && g4;
        }, O4 = function(t6, e5) {
          if (S4(t6)) return t6.clone();
          var n5 = "object" == typeof e5 ? e5 : {};
          return n5.date = t6, n5.args = arguments, new _4(n5);
        }, b4 = v4;
        b4.l = w4, b4.i = S4, b4.w = function(t6, e5) {
          return O4(t6, { locale: e5.$L, utc: e5.$u, x: e5.$x, $offset: e5.$offset });
        };
        var _4 = function() {
          function M5(t6) {
            this.$L = w4(t6.locale, null, true), this.parse(t6), this.$x = this.$x || t6.x || {}, this[p4] = true;
          }
          var m5 = M5.prototype;
          return m5.parse = function(t6) {
            this.$d = function(t7) {
              var e5 = t7.date, n5 = t7.utc;
              if (null === e5) return /* @__PURE__ */ new Date(NaN);
              if (b4.u(e5)) return /* @__PURE__ */ new Date();
              if (e5 instanceof Date) return new Date(e5);
              if ("string" == typeof e5 && !/Z$/i.test(e5)) {
                var r5 = e5.match($5);
                if (r5) {
                  var i5 = r5[2] - 1 || 0, s5 = (r5[7] || "0").substring(0, 3);
                  return n5 ? new Date(Date.UTC(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s5)) : new Date(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s5);
                }
              }
              return new Date(e5);
            }(t6), this.init();
          }, m5.init = function() {
            var t6 = this.$d;
            this.$y = t6.getFullYear(), this.$M = t6.getMonth(), this.$D = t6.getDate(), this.$W = t6.getDay(), this.$H = t6.getHours(), this.$m = t6.getMinutes(), this.$s = t6.getSeconds(), this.$ms = t6.getMilliseconds();
          }, m5.$utils = function() {
            return b4;
          }, m5.isValid = function() {
            return !(this.$d.toString() === l4);
          }, m5.isSame = function(t6, e5) {
            var n5 = O4(t6);
            return this.startOf(e5) <= n5 && n5 <= this.endOf(e5);
          }, m5.isAfter = function(t6, e5) {
            return O4(t6) < this.startOf(e5);
          }, m5.isBefore = function(t6, e5) {
            return this.endOf(e5) < O4(t6);
          }, m5.$g = function(t6, e5, n5) {
            return b4.u(t6) ? this[e5] : this.set(n5, t6);
          }, m5.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m5.valueOf = function() {
            return this.$d.getTime();
          }, m5.startOf = function(t6, e5) {
            var n5 = this, r5 = !!b4.u(e5) || e5, f5 = b4.p(t6), l5 = function(t7, e6) {
              var i5 = b4.w(n5.$u ? Date.UTC(n5.$y, e6, t7) : new Date(n5.$y, e6, t7), n5);
              return r5 ? i5 : i5.endOf(a4);
            }, $6 = function(t7, e6) {
              return b4.w(n5.toDate()[t7].apply(n5.toDate("s"), (r5 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e6)), n5);
            }, y5 = this.$W, M6 = this.$M, m6 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
            switch (f5) {
              case h4:
                return r5 ? l5(1, 0) : l5(31, 11);
              case c4:
                return r5 ? l5(1, M6) : l5(0, M6 + 1);
              case o4:
                var g5 = this.$locale().weekStart || 0, D5 = (y5 < g5 ? y5 + 7 : y5) - g5;
                return l5(r5 ? m6 - D5 : m6 + (6 - D5), M6);
              case a4:
              case d4:
                return $6(v5 + "Hours", 0);
              case u4:
                return $6(v5 + "Minutes", 1);
              case s4:
                return $6(v5 + "Seconds", 2);
              case i4:
                return $6(v5 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m5.endOf = function(t6) {
            return this.startOf(t6, false);
          }, m5.$set = function(t6, e5) {
            var n5, o5 = b4.p(t6), f5 = "set" + (this.$u ? "UTC" : ""), l5 = (n5 = {}, n5[a4] = f5 + "Date", n5[d4] = f5 + "Date", n5[c4] = f5 + "Month", n5[h4] = f5 + "FullYear", n5[u4] = f5 + "Hours", n5[s4] = f5 + "Minutes", n5[i4] = f5 + "Seconds", n5[r4] = f5 + "Milliseconds", n5)[o5], $6 = o5 === a4 ? this.$D + (e5 - this.$W) : e5;
            if (o5 === c4 || o5 === h4) {
              var y5 = this.clone().set(d4, 1);
              y5.$d[l5]($6), y5.init(), this.$d = y5.set(d4, Math.min(this.$D, y5.daysInMonth())).$d;
            } else l5 && this.$d[l5]($6);
            return this.init(), this;
          }, m5.set = function(t6, e5) {
            return this.clone().$set(t6, e5);
          }, m5.get = function(t6) {
            return this[b4.p(t6)]();
          }, m5.add = function(r5, f5) {
            var d5, l5 = this;
            r5 = Number(r5);
            var $6 = b4.p(f5), y5 = function(t6) {
              var e5 = O4(l5);
              return b4.w(e5.date(e5.date() + Math.round(t6 * r5)), l5);
            };
            if ($6 === c4) return this.set(c4, this.$M + r5);
            if ($6 === h4) return this.set(h4, this.$y + r5);
            if ($6 === a4) return y5(1);
            if ($6 === o4) return y5(7);
            var M6 = (d5 = {}, d5[s4] = e4, d5[u4] = n4, d5[i4] = t5, d5)[$6] || 1, m6 = this.$d.getTime() + r5 * M6;
            return b4.w(m6, this);
          }, m5.subtract = function(t6, e5) {
            return this.add(-1 * t6, e5);
          }, m5.format = function(t6) {
            var e5 = this, n5 = this.$locale();
            if (!this.isValid()) return n5.invalidDate || l4;
            var r5 = t6 || "YYYY-MM-DDTHH:mm:ssZ", i5 = b4.z(this), s5 = this.$H, u5 = this.$m, a5 = this.$M, o5 = n5.weekdays, c5 = n5.months, f5 = n5.meridiem, h5 = function(t7, n6, i6, s6) {
              return t7 && (t7[n6] || t7(e5, r5)) || i6[n6].slice(0, s6);
            }, d5 = function(t7) {
              return b4.s(s5 % 12 || 12, t7, "0");
            }, $6 = f5 || function(t7, e6, n6) {
              var r6 = t7 < 12 ? "AM" : "PM";
              return n6 ? r6.toLowerCase() : r6;
            };
            return r5.replace(y4, function(t7, r6) {
              return r6 || function(t8) {
                switch (t8) {
                  case "YY":
                    return String(e5.$y).slice(-2);
                  case "YYYY":
                    return b4.s(e5.$y, 4, "0");
                  case "M":
                    return a5 + 1;
                  case "MM":
                    return b4.s(a5 + 1, 2, "0");
                  case "MMM":
                    return h5(n5.monthsShort, a5, c5, 3);
                  case "MMMM":
                    return h5(c5, a5);
                  case "D":
                    return e5.$D;
                  case "DD":
                    return b4.s(e5.$D, 2, "0");
                  case "d":
                    return String(e5.$W);
                  case "dd":
                    return h5(n5.weekdaysMin, e5.$W, o5, 2);
                  case "ddd":
                    return h5(n5.weekdaysShort, e5.$W, o5, 3);
                  case "dddd":
                    return o5[e5.$W];
                  case "H":
                    return String(s5);
                  case "HH":
                    return b4.s(s5, 2, "0");
                  case "h":
                    return d5(1);
                  case "hh":
                    return d5(2);
                  case "a":
                    return $6(s5, u5, true);
                  case "A":
                    return $6(s5, u5, false);
                  case "m":
                    return String(u5);
                  case "mm":
                    return b4.s(u5, 2, "0");
                  case "s":
                    return String(e5.$s);
                  case "ss":
                    return b4.s(e5.$s, 2, "0");
                  case "SSS":
                    return b4.s(e5.$ms, 3, "0");
                  case "Z":
                    return i5;
                }
                return null;
              }(t7) || i5.replace(":", "");
            });
          }, m5.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m5.diff = function(r5, d5, l5) {
            var $6, y5 = this, M6 = b4.p(d5), m6 = O4(r5), v5 = (m6.utcOffset() - this.utcOffset()) * e4, g5 = this - m6, D5 = function() {
              return b4.m(y5, m6);
            };
            switch (M6) {
              case h4:
                $6 = D5() / 12;
                break;
              case c4:
                $6 = D5();
                break;
              case f4:
                $6 = D5() / 3;
                break;
              case o4:
                $6 = (g5 - v5) / 6048e5;
                break;
              case a4:
                $6 = (g5 - v5) / 864e5;
                break;
              case u4:
                $6 = g5 / n4;
                break;
              case s4:
                $6 = g5 / e4;
                break;
              case i4:
                $6 = g5 / t5;
                break;
              default:
                $6 = g5;
            }
            return l5 ? $6 : b4.a($6);
          }, m5.daysInMonth = function() {
            return this.endOf(c4).$D;
          }, m5.$locale = function() {
            return D4[this.$L];
          }, m5.locale = function(t6, e5) {
            if (!t6) return this.$L;
            var n5 = this.clone(), r5 = w4(t6, e5, true);
            return r5 && (n5.$L = r5), n5;
          }, m5.clone = function() {
            return b4.w(this.$d, this);
          }, m5.toDate = function() {
            return new Date(this.valueOf());
          }, m5.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m5.toISOString = function() {
            return this.$d.toISOString();
          }, m5.toString = function() {
            return this.$d.toUTCString();
          }, M5;
        }(), k4 = _4.prototype;
        return O4.prototype = k4, [["$ms", r4], ["$s", i4], ["$m", s4], ["$H", u4], ["$W", a4], ["$M", c4], ["$y", h4], ["$D", d4]].forEach(function(t6) {
          k4[t6[1]] = function(e5) {
            return this.$g(e5, t6[0], t6[1]);
          };
        }), O4.extend = function(t6, e5) {
          return t6.$i || (t6(e5, _4, O4), t6.$i = true), O4;
        }, O4.locale = w4, O4.isDayjs = S4, O4.unix = function(t6) {
          return O4(1e3 * t6);
        }, O4.en = D4[g4], O4.Ls = D4, O4.p = {}, O4;
      });
    }
  });

  // ../../node_modules/dayjs/plugin/customParseFormat.js
  var require_customParseFormat = __commonJS({
    "../../node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
      !function(e4, t5) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t5() : "function" == typeof define && define.amd ? define(t5) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_plugin_customParseFormat = t5();
      }(exports, function() {
        "use strict";
        var e4 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t5 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n4 = /\d/, r4 = /\d\d/, i4 = /\d\d?/, o4 = /\d*[^-_:/,()\s\d]+/, s4 = {}, a4 = function(e5) {
          return (e5 = +e5) + (e5 > 68 ? 1900 : 2e3);
        };
        var f4 = function(e5) {
          return function(t6) {
            this[e5] = +t6;
          };
        }, h4 = [/[+-]\d\d:?(\d\d)?|Z/, function(e5) {
          (this.zone || (this.zone = {})).offset = function(e6) {
            if (!e6) return 0;
            if ("Z" === e6) return 0;
            var t6 = e6.match(/([+-]|\d\d)/g), n5 = 60 * t6[1] + (+t6[2] || 0);
            return 0 === n5 ? 0 : "+" === t6[0] ? -n5 : n5;
          }(e5);
        }], u4 = function(e5) {
          var t6 = s4[e5];
          return t6 && (t6.indexOf ? t6 : t6.s.concat(t6.f));
        }, d4 = function(e5, t6) {
          var n5, r5 = s4.meridiem;
          if (r5) {
            for (var i5 = 1; i5 <= 24; i5 += 1) if (e5.indexOf(r5(i5, 0, t6)) > -1) {
              n5 = i5 > 12;
              break;
            }
          } else n5 = e5 === (t6 ? "pm" : "PM");
          return n5;
        }, c4 = { A: [o4, function(e5) {
          this.afternoon = d4(e5, false);
        }], a: [o4, function(e5) {
          this.afternoon = d4(e5, true);
        }], Q: [n4, function(e5) {
          this.month = 3 * (e5 - 1) + 1;
        }], S: [n4, function(e5) {
          this.milliseconds = 100 * +e5;
        }], SS: [r4, function(e5) {
          this.milliseconds = 10 * +e5;
        }], SSS: [/\d{3}/, function(e5) {
          this.milliseconds = +e5;
        }], s: [i4, f4("seconds")], ss: [i4, f4("seconds")], m: [i4, f4("minutes")], mm: [i4, f4("minutes")], H: [i4, f4("hours")], h: [i4, f4("hours")], HH: [i4, f4("hours")], hh: [i4, f4("hours")], D: [i4, f4("day")], DD: [r4, f4("day")], Do: [o4, function(e5) {
          var t6 = s4.ordinal, n5 = e5.match(/\d+/);
          if (this.day = n5[0], t6) for (var r5 = 1; r5 <= 31; r5 += 1) t6(r5).replace(/\[|\]/g, "") === e5 && (this.day = r5);
        }], w: [i4, f4("week")], ww: [r4, f4("week")], M: [i4, f4("month")], MM: [r4, f4("month")], MMM: [o4, function(e5) {
          var t6 = u4("months"), n5 = (u4("monthsShort") || t6.map(function(e6) {
            return e6.slice(0, 3);
          })).indexOf(e5) + 1;
          if (n5 < 1) throw new Error();
          this.month = n5 % 12 || n5;
        }], MMMM: [o4, function(e5) {
          var t6 = u4("months").indexOf(e5) + 1;
          if (t6 < 1) throw new Error();
          this.month = t6 % 12 || t6;
        }], Y: [/[+-]?\d+/, f4("year")], YY: [r4, function(e5) {
          this.year = a4(e5);
        }], YYYY: [/\d{4}/, f4("year")], Z: h4, ZZ: h4 };
        function l4(n5) {
          var r5, i5;
          r5 = n5, i5 = s4 && s4.formats;
          for (var o5 = (n5 = r5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n6, r6) {
            var o6 = r6 && r6.toUpperCase();
            return n6 || i5[r6] || e4[r6] || i5[o6].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e5, t7, n7) {
              return t7 || n7.slice(1);
            });
          })).match(t5), a5 = o5.length, f5 = 0; f5 < a5; f5 += 1) {
            var h5 = o5[f5], u5 = c4[h5], d5 = u5 && u5[0], l5 = u5 && u5[1];
            o5[f5] = l5 ? { regex: d5, parser: l5 } : h5.replace(/^\[|\]$/g, "");
          }
          return function(e5) {
            for (var t6 = {}, n6 = 0, r6 = 0; n6 < a5; n6 += 1) {
              var i6 = o5[n6];
              if ("string" == typeof i6) r6 += i6.length;
              else {
                var s5 = i6.regex, f6 = i6.parser, h6 = e5.slice(r6), u6 = s5.exec(h6)[0];
                f6.call(t6, u6), e5 = e5.replace(u6, "");
              }
            }
            return function(e6) {
              var t7 = e6.afternoon;
              if (void 0 !== t7) {
                var n7 = e6.hours;
                t7 ? n7 < 12 && (e6.hours += 12) : 12 === n7 && (e6.hours = 0), delete e6.afternoon;
              }
            }(t6), t6;
          };
        }
        return function(e5, t6, n5) {
          n5.p.customParseFormat = true, e5 && e5.parseTwoDigitYear && (a4 = e5.parseTwoDigitYear);
          var r5 = t6.prototype, i5 = r5.parse;
          r5.parse = function(e6) {
            var t7 = e6.date, r6 = e6.utc, o5 = e6.args;
            this.$u = r6;
            var a5 = o5[1];
            if ("string" == typeof a5) {
              var f5 = true === o5[2], h5 = true === o5[3], u5 = f5 || h5, d5 = o5[2];
              h5 && (d5 = o5[2]), s4 = this.$locale(), !f5 && d5 && (s4 = n5.Ls[d5]), this.$d = function(e7, t8, n6, r7) {
                try {
                  if (["x", "X"].indexOf(t8) > -1) return new Date(("X" === t8 ? 1e3 : 1) * e7);
                  var i6 = l4(t8)(e7), o6 = i6.year, s5 = i6.month, a6 = i6.day, f6 = i6.hours, h6 = i6.minutes, u6 = i6.seconds, d6 = i6.milliseconds, c6 = i6.zone, m5 = i6.week, M5 = /* @__PURE__ */ new Date(), Y3 = a6 || (o6 || s5 ? 1 : M5.getDate()), p4 = o6 || M5.getFullYear(), v4 = 0;
                  o6 && !s5 || (v4 = s5 > 0 ? s5 - 1 : M5.getMonth());
                  var D4, w4 = f6 || 0, g4 = h6 || 0, y4 = u6 || 0, L4 = d6 || 0;
                  return c6 ? new Date(Date.UTC(p4, v4, Y3, w4, g4, y4, L4 + 60 * c6.offset * 1e3)) : n6 ? new Date(Date.UTC(p4, v4, Y3, w4, g4, y4, L4)) : (D4 = new Date(p4, v4, Y3, w4, g4, y4, L4), m5 && (D4 = r7(D4).week(m5).toDate()), D4);
                } catch (e8) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t7, a5, r6, n5), this.init(), d5 && true !== d5 && (this.$L = this.locale(d5).$L), u5 && t7 != this.format(a5) && (this.$d = /* @__PURE__ */ new Date("")), s4 = {};
            } else if (a5 instanceof Array) for (var c5 = a5.length, m4 = 1; m4 <= c5; m4 += 1) {
              o5[1] = a5[m4 - 1];
              var M4 = n5.apply(this, o5);
              if (M4.isValid()) {
                this.$d = M4.$d, this.$L = M4.$L, this.init();
                break;
              }
              m4 === c5 && (this.$d = /* @__PURE__ */ new Date(""));
            }
            else i5.call(this, e6);
          };
        };
      });
    }
  });

  // ../../node_modules/@eonasdan/tempus-dominus/dist/plugins/customDateFormat.js
  var require_customDateFormat = __commonJS({
    "../../node_modules/@eonasdan/tempus-dominus/dist/plugins/customDateFormat.js"(exports, module) {
      (function(g4, f4) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = f4() : typeof define === "function" && define.amd ? define(f4) : (g4 = typeof globalThis !== "undefined" ? globalThis : g4 || self, g4.tempusDominus = g4.tempusDominus || {}, g4.tempusDominus.plugins = g4.tempusDominus.plugins || {}, g4.tempusDominus.plugins.customDateFormat = f4());
      })(exports, function() {
        "use strict";
        var index = () => {
          console.warn("This plugin has been merged with the main picker and is now longer required");
        };
        return index;
      });
    }
  });

  // ../../node_modules/namespace-emitter/index.js
  var require_namespace_emitter = __commonJS({
    "../../node_modules/namespace-emitter/index.js"(exports, module) {
      module.exports = function createNamespaceEmitter() {
        var emitter = {};
        var _fns = emitter._fns = {};
        emitter.emit = function emit(event, arg1, arg2, arg3, arg4, arg5, arg6) {
          var toEmit = getListeners(event);
          if (toEmit.length) {
            emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6]);
          }
        };
        emitter.on = function on2(event, fn4) {
          if (!_fns[event]) {
            _fns[event] = [];
          }
          _fns[event].push(fn4);
        };
        emitter.once = function once(event, fn4) {
          function one() {
            fn4.apply(this, arguments);
            emitter.off(event, one);
          }
          this.on(event, one);
        };
        emitter.off = function off(event, fn4) {
          var keep = [];
          if (event && fn4) {
            var fns = this._fns[event];
            var i4 = 0;
            var l4 = fns ? fns.length : 0;
            for (i4; i4 < l4; i4++) {
              if (fns[i4] !== fn4) {
                keep.push(fns[i4]);
              }
            }
          }
          keep.length ? this._fns[event] = keep : delete this._fns[event];
        };
        function getListeners(e4) {
          var out = _fns[e4] ? _fns[e4] : [];
          var idx = e4.indexOf(":");
          var args = idx === -1 ? [e4] : [e4.substring(0, idx), e4.substring(idx + 1)];
          var keys = Object.keys(_fns);
          var i4 = 0;
          var l4 = keys.length;
          for (i4; i4 < l4; i4++) {
            var key = keys[i4];
            if (key === "*") {
              out = out.concat(_fns[key]);
            }
            if (args.length === 2 && args[0] === key) {
              out = out.concat(_fns[key]);
              break;
            }
          }
          return out;
        }
        function emitAll(e4, fns, args) {
          var i4 = 0;
          var l4 = fns.length;
          for (i4; i4 < l4; i4++) {
            if (!fns[i4]) break;
            fns[i4].event = e4;
            fns[i4].apply(fns[i4], args);
          }
        }
        return emitter;
      };
    }
  });

  // ../../node_modules/lodash.throttle/index.js
  var require_lodash = __commonJS({
    "../../node_modules/lodash.throttle/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString2 = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now2 = function() {
        return root.Date.now();
      };
      function debounce6(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush2() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush2;
        return debounced;
      }
      function throttle3(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce6(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString2.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = throttle3;
    }
  });

  // ../../node_modules/@transloadit/prettier-bytes/prettierBytes.js
  var require_prettierBytes = __commonJS({
    "../../node_modules/@transloadit/prettier-bytes/prettierBytes.js"(exports, module) {
      module.exports = function prettierBytes3(num) {
        if (typeof num !== "number" || isNaN(num)) {
          throw new TypeError(`Expected a number, got ${typeof num}`);
        }
        const neg = num < 0;
        const units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        if (neg) {
          num = -num;
        }
        if (num < 1) {
          return `${(neg ? "-" : "") + num} B`;
        }
        const exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
        num = Number(num / Math.pow(1024, exponent));
        const unit = units[exponent];
        if (num >= 10 || num % 1 === 0) {
          return `${(neg ? "-" : "") + num.toFixed(0)} ${unit}`;
        }
        return `${(neg ? "-" : "") + num.toFixed(1)} ${unit}`;
      };
    }
  });

  // ../../node_modules/wildcard/index.js
  var require_wildcard = __commonJS({
    "../../node_modules/wildcard/index.js"(exports, module) {
      "use strict";
      function WildcardMatcher(text, separator) {
        this.text = text = text || "";
        this.hasWild = ~text.indexOf("*");
        this.separator = separator;
        this.parts = text.split(separator);
      }
      WildcardMatcher.prototype.match = function(input) {
        var matches = true;
        var parts = this.parts;
        var ii2;
        var partsCount = parts.length;
        var testParts;
        if (typeof input == "string" || input instanceof String) {
          if (!this.hasWild && this.text != input) {
            matches = false;
          } else {
            testParts = (input || "").split(this.separator);
            for (ii2 = 0; matches && ii2 < partsCount; ii2++) {
              if (parts[ii2] === "*") {
                continue;
              } else if (ii2 < testParts.length) {
                matches = parts[ii2] === testParts[ii2];
              } else {
                matches = false;
              }
            }
            matches = matches && testParts;
          }
        } else if (typeof input.splice == "function") {
          matches = [];
          for (ii2 = input.length; ii2--; ) {
            if (this.match(input[ii2])) {
              matches[matches.length] = input[ii2];
            }
          }
        } else if (typeof input == "object") {
          matches = {};
          for (var key in input) {
            if (this.match(key)) {
              matches[key] = input[key];
            }
          }
        }
        return matches;
      };
      module.exports = function(text, test, separator) {
        var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
        if (typeof test != "undefined") {
          return matcher.match(test);
        }
        return matcher;
      };
    }
  });

  // ../../node_modules/mime-match/index.js
  var require_mime_match = __commonJS({
    "../../node_modules/mime-match/index.js"(exports, module) {
      var wildcard = require_wildcard();
      var reMimePartSplit = /[\/\+\.]/;
      module.exports = function(target, pattern) {
        function test(pattern2) {
          var result = wildcard(pattern2, target, reMimePartSplit);
          return result && result.length >= 2;
        }
        return pattern ? test(pattern.split(";")[0]) : test;
      };
    }
  });

  // ../../node_modules/@uppy/compressor/node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js
  var require_prettierBytes2 = __commonJS({
    "../../node_modules/@uppy/compressor/node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js"(exports, module) {
      "use strict";
      module.exports = function prettierBytes3(num) {
        if (typeof num !== "number" || Number.isNaN(num)) {
          throw new TypeError(`Expected a number, got ${typeof num}`);
        }
        const neg = num < 0;
        const units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        if (neg) {
          num = -num;
        }
        if (num < 1) {
          return `${(neg ? "-" : "") + num} B`;
        }
        const exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
        num = Number(num / 1024 ** exponent);
        const unit = units[exponent];
        if (num >= 10 || num % 1 === 0) {
          return `${(neg ? "-" : "") + num.toFixed(0)} ${unit}`;
        }
        return `${(neg ? "-" : "") + num.toFixed(1)} ${unit}`;
      };
    }
  });

  // ../../node_modules/compressorjs/dist/compressor.js
  var require_compressor = __commonJS({
    "../../node_modules/compressorjs/dist/compressor.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Compressor = factory());
      })(exports, function() {
        "use strict";
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i4 = 1; i4 < arguments.length; i4++) {
            var source = null != arguments[i4] ? arguments[i4] : {};
            i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i4 = 0; i4 < props.length; i4++) {
            var descriptor = props[i4];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _extends() {
          _extends = Object.assign ? Object.assign.bind() : function(target) {
            for (var i4 = 1; i4 < arguments.length; i4++) {
              var source = arguments[i4];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        function _toPrimitive(input, hint) {
          if (typeof input !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== void 0) {
            var res = prim.call(input, hint || "default");
            if (typeof res !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        var canvasToBlob2 = { exports: {} };
        (function(module2) {
          if (typeof window === "undefined") {
            return;
          }
          (function(window2) {
            var CanvasPrototype = window2.HTMLCanvasElement && window2.HTMLCanvasElement.prototype;
            var hasBlobConstructor = window2.Blob && function() {
              try {
                return Boolean(new Blob());
              } catch (e4) {
                return false;
              }
            }();
            var hasArrayBufferViewSupport = hasBlobConstructor && window2.Uint8Array && function() {
              try {
                return new Blob([new Uint8Array(100)]).size === 100;
              } catch (e4) {
                return false;
              }
            }();
            var BlobBuilder = window2.BlobBuilder || window2.WebKitBlobBuilder || window2.MozBlobBuilder || window2.MSBlobBuilder;
            var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;
            var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window2.atob && window2.ArrayBuffer && window2.Uint8Array && function(dataURI) {
              var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i4, bb;
              matches = dataURI.match(dataURIPattern);
              if (!matches) {
                throw new Error("invalid data URI");
              }
              mediaType = matches[2] ? matches[1] : "text/plain" + (matches[3] || ";charset=US-ASCII");
              isBase64 = !!matches[4];
              dataString = dataURI.slice(matches[0].length);
              if (isBase64) {
                byteString = atob(dataString);
              } else {
                byteString = decodeURIComponent(dataString);
              }
              arrayBuffer = new ArrayBuffer(byteString.length);
              intArray = new Uint8Array(arrayBuffer);
              for (i4 = 0; i4 < byteString.length; i4 += 1) {
                intArray[i4] = byteString.charCodeAt(i4);
              }
              if (hasBlobConstructor) {
                return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
                  type: mediaType
                });
              }
              bb = new BlobBuilder();
              bb.append(arrayBuffer);
              return bb.getBlob(mediaType);
            };
            if (window2.HTMLCanvasElement && !CanvasPrototype.toBlob) {
              if (CanvasPrototype.mozGetAsFile) {
                CanvasPrototype.toBlob = function(callback, type, quality) {
                  var self2 = this;
                  setTimeout(function() {
                    if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
                      callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                    } else {
                      callback(self2.mozGetAsFile("blob", type));
                    }
                  });
                };
              } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
                if (CanvasPrototype.msToBlob) {
                  CanvasPrototype.toBlob = function(callback, type, quality) {
                    var self2 = this;
                    setTimeout(function() {
                      if ((type && type !== "image/png" || quality) && CanvasPrototype.toDataURL && dataURLtoBlob) {
                        callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                      } else {
                        callback(self2.msToBlob(type));
                      }
                    });
                  };
                } else {
                  CanvasPrototype.toBlob = function(callback, type, quality) {
                    var self2 = this;
                    setTimeout(function() {
                      callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                    });
                  };
                }
              }
            }
            if (module2.exports) {
              module2.exports = dataURLtoBlob;
            } else {
              window2.dataURLtoBlob = dataURLtoBlob;
            }
          })(window);
        })(canvasToBlob2);
        var toBlob = canvasToBlob2.exports;
        var isBlob = function isBlob2(value) {
          if (typeof Blob === "undefined") {
            return false;
          }
          return value instanceof Blob || Object.prototype.toString.call(value) === "[object Blob]";
        };
        var DEFAULTS = {
          /**
           * Indicates if output the original image instead of the compressed one
           * when the size of the compressed image is greater than the original one's
           * @type {boolean}
           */
          strict: true,
          /**
           * Indicates if read the image's Exif Orientation information,
           * and then rotate or flip the image automatically.
           * @type {boolean}
           */
          checkOrientation: true,
          /**
           * Indicates if retain the image's Exif information after compressed.
           * @type {boolean}
          */
          retainExif: false,
          /**
           * The max width of the output image.
           * @type {number}
           */
          maxWidth: Infinity,
          /**
           * The max height of the output image.
           * @type {number}
           */
          maxHeight: Infinity,
          /**
           * The min width of the output image.
           * @type {number}
           */
          minWidth: 0,
          /**
           * The min height of the output image.
           * @type {number}
           */
          minHeight: 0,
          /**
           * The width of the output image.
           * If not specified, the natural width of the source image will be used.
           * @type {number}
           */
          width: void 0,
          /**
           * The height of the output image.
           * If not specified, the natural height of the source image will be used.
           * @type {number}
           */
          height: void 0,
          /**
           * Sets how the size of the image should be resized to the container
           * specified by the `width` and `height` options.
           * @type {string}
           */
          resize: "none",
          /**
           * The quality of the output image.
           * It must be a number between `0` and `1`,
           * and only available for `image/jpeg` and `image/webp` images.
           * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.
           * @type {number}
           */
          quality: 0.8,
          /**
           * The mime type of the output image.
           * By default, the original mime type of the source image file will be used.
           * @type {string}
           */
          mimeType: "auto",
          /**
           * Files whose file type is included in this list,
           * and whose file size exceeds the `convertSize` value will be converted to JPEGs.
           * @type {stringArray}
           */
          convertTypes: ["image/png"],
          /**
           * PNG files over this size (5 MB by default) will be converted to JPEGs.
           * To disable this, just set the value to `Infinity`.
           * @type {number}
           */
          convertSize: 5e6,
          /**
           * The hook function to execute before draw the image into the canvas for compression.
           * @type {Function}
           * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
           * @param {HTMLCanvasElement} canvas - The canvas for compression.
           * @example
           * function (context, canvas) {
           *   context.fillStyle = '#fff';
           * }
           */
          beforeDraw: null,
          /**
           * The hook function to execute after drew the image into the canvas for compression.
           * @type {Function}
           * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
           * @param {HTMLCanvasElement} canvas - The canvas for compression.
           * @example
           * function (context, canvas) {
           *   context.filter = 'grayscale(100%)';
           * }
           */
          drew: null,
          /**
           * The hook function to execute when success to compress the image.
           * @type {Function}
           * @param {File} file - The compressed image File object.
           * @example
           * function (file) {
           *   console.log(file);
           * }
           */
          success: null,
          /**
           * The hook function to execute when fail to compress the image.
           * @type {Function}
           * @param {Error} err - An Error object.
           * @example
           * function (err) {
           *   console.log(err.message);
           * }
           */
          error: null
        };
        var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
        var WINDOW = IS_BROWSER ? window : {};
        var isPositiveNumber = function isPositiveNumber2(value) {
          return value > 0 && value < Infinity;
        };
        var slice = Array.prototype.slice;
        function toArray(value) {
          return Array.from ? Array.from(value) : slice.call(value);
        }
        var REGEXP_IMAGE_TYPE = /^image\/.+$/;
        function isImageType(value) {
          return REGEXP_IMAGE_TYPE.test(value);
        }
        function imageTypeToExtension(value) {
          var extension = isImageType(value) ? value.substr(6) : "";
          if (extension === "jpeg") {
            extension = "jpg";
          }
          return ".".concat(extension);
        }
        var fromCharCode = String.fromCharCode;
        function getStringFromCharCode(dataView, start4, length) {
          var str = "";
          var i4;
          length += start4;
          for (i4 = start4; i4 < length; i4 += 1) {
            str += fromCharCode(dataView.getUint8(i4));
          }
          return str;
        }
        var btoa2 = WINDOW.btoa;
        function arrayBufferToDataURL(arrayBuffer, mimeType) {
          var chunks = [];
          var chunkSize = 8192;
          var uint8 = new Uint8Array(arrayBuffer);
          while (uint8.length > 0) {
            chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
            uint8 = uint8.subarray(chunkSize);
          }
          return "data:".concat(mimeType, ";base64,").concat(btoa2(chunks.join("")));
        }
        function resetAndGetOrientation(arrayBuffer) {
          var dataView = new DataView(arrayBuffer);
          var orientation;
          try {
            var littleEndian;
            var app1Start;
            var ifdStart;
            if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
              var length = dataView.byteLength;
              var offset3 = 2;
              while (offset3 + 1 < length) {
                if (dataView.getUint8(offset3) === 255 && dataView.getUint8(offset3 + 1) === 225) {
                  app1Start = offset3;
                  break;
                }
                offset3 += 1;
              }
            }
            if (app1Start) {
              var exifIDCode = app1Start + 4;
              var tiffOffset = app1Start + 10;
              if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
                var endianness = dataView.getUint16(tiffOffset);
                littleEndian = endianness === 18761;
                if (littleEndian || endianness === 19789) {
                  if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
                    var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                    if (firstIFDOffset >= 8) {
                      ifdStart = tiffOffset + firstIFDOffset;
                    }
                  }
                }
              }
            }
            if (ifdStart) {
              var _length = dataView.getUint16(ifdStart, littleEndian);
              var _offset;
              var i4;
              for (i4 = 0; i4 < _length; i4 += 1) {
                _offset = ifdStart + i4 * 12 + 2;
                if (dataView.getUint16(_offset, littleEndian) === 274) {
                  _offset += 8;
                  orientation = dataView.getUint16(_offset, littleEndian);
                  dataView.setUint16(_offset, 1, littleEndian);
                  break;
                }
              }
            }
          } catch (e4) {
            orientation = 1;
          }
          return orientation;
        }
        function parseOrientation(orientation) {
          var rotate = 0;
          var scaleX = 1;
          var scaleY = 1;
          switch (orientation) {
            // Flip horizontal
            case 2:
              scaleX = -1;
              break;
            // Rotate left 180
            case 3:
              rotate = -180;
              break;
            // Flip vertical
            case 4:
              scaleY = -1;
              break;
            // Flip vertical and rotate right 90
            case 5:
              rotate = 90;
              scaleY = -1;
              break;
            // Rotate right 90
            case 6:
              rotate = 90;
              break;
            // Flip horizontal and rotate right 90
            case 7:
              rotate = 90;
              scaleX = -1;
              break;
            // Rotate left 90
            case 8:
              rotate = -90;
              break;
          }
          return {
            rotate,
            scaleX,
            scaleY
          };
        }
        var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
        function normalizeDecimalNumber(value) {
          var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
          return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
        }
        function getAdjustedSizes(_ref) {
          var aspectRatio = _ref.aspectRatio, height = _ref.height, width = _ref.width;
          var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
          var isValidWidth = isPositiveNumber(width);
          var isValidHeight = isPositiveNumber(height);
          if (isValidWidth && isValidHeight) {
            var adjustedWidth = height * aspectRatio;
            if ((type === "contain" || type === "none") && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
              height = width / aspectRatio;
            } else {
              width = height * aspectRatio;
            }
          } else if (isValidWidth) {
            height = width / aspectRatio;
          } else if (isValidHeight) {
            width = height * aspectRatio;
          }
          return {
            width,
            height
          };
        }
        function getExif(arrayBuffer) {
          var array = toArray(new Uint8Array(arrayBuffer));
          var length = array.length;
          var segments = [];
          var start4 = 0;
          while (start4 + 3 < length) {
            var value = array[start4];
            var next = array[start4 + 1];
            if (value === 255 && next === 218) {
              break;
            }
            if (value === 255 && next === 216) {
              start4 += 2;
            } else {
              var offset3 = array[start4 + 2] * 256 + array[start4 + 3];
              var end3 = start4 + offset3 + 2;
              var segment = array.slice(start4, end3);
              segments.push(segment);
              start4 = end3;
            }
          }
          return segments.reduce(function(exifArray, current) {
            if (current[0] === 255 && current[1] === 225) {
              return exifArray.concat(current);
            }
            return exifArray;
          }, []);
        }
        function insertExif(arrayBuffer, exifArray) {
          var array = toArray(new Uint8Array(arrayBuffer));
          if (array[2] !== 255 || array[3] !== 224) {
            return arrayBuffer;
          }
          var app0Length = array[4] * 256 + array[5];
          var newArrayBuffer = [255, 216].concat(exifArray, array.slice(4 + app0Length));
          return new Uint8Array(newArrayBuffer);
        }
        var ArrayBuffer$1 = WINDOW.ArrayBuffer, FileReader2 = WINDOW.FileReader;
        var URL2 = WINDOW.URL || WINDOW.webkitURL;
        var REGEXP_EXTENSION = /\.\w+$/;
        var AnotherCompressor = WINDOW.Compressor;
        var Compressor2 = /* @__PURE__ */ function() {
          function Compressor3(file, options) {
            _classCallCheck(this, Compressor3);
            this.file = file;
            this.exif = [];
            this.image = new Image();
            this.options = _objectSpread2(_objectSpread2({}, DEFAULTS), options);
            this.aborted = false;
            this.result = null;
            this.init();
          }
          _createClass(Compressor3, [{
            key: "init",
            value: function init() {
              var _this = this;
              var file = this.file, options = this.options;
              if (!isBlob(file)) {
                this.fail(new Error("The first argument must be a File or Blob object."));
                return;
              }
              var mimeType = file.type;
              if (!isImageType(mimeType)) {
                this.fail(new Error("The first argument must be an image File or Blob object."));
                return;
              }
              if (!URL2 || !FileReader2) {
                this.fail(new Error("The current browser does not support image compression."));
                return;
              }
              if (!ArrayBuffer$1) {
                options.checkOrientation = false;
                options.retainExif = false;
              }
              var isJPEGImage = mimeType === "image/jpeg";
              var checkOrientation = isJPEGImage && options.checkOrientation;
              var retainExif = isJPEGImage && options.retainExif;
              if (URL2 && !checkOrientation && !retainExif) {
                this.load({
                  url: URL2.createObjectURL(file)
                });
              } else {
                var reader = new FileReader2();
                this.reader = reader;
                reader.onload = function(_ref) {
                  var target = _ref.target;
                  var result = target.result;
                  var data = {};
                  var orientation = 1;
                  if (checkOrientation) {
                    orientation = resetAndGetOrientation(result);
                    if (orientation > 1) {
                      _extends(data, parseOrientation(orientation));
                    }
                  }
                  if (retainExif) {
                    _this.exif = getExif(result);
                  }
                  if (checkOrientation || retainExif) {
                    if (!URL2 || orientation > 1) {
                      data.url = arrayBufferToDataURL(result, mimeType);
                    } else {
                      data.url = URL2.createObjectURL(file);
                    }
                  } else {
                    data.url = result;
                  }
                  _this.load(data);
                };
                reader.onabort = function() {
                  _this.fail(new Error("Aborted to read the image with FileReader."));
                };
                reader.onerror = function() {
                  _this.fail(new Error("Failed to read the image with FileReader."));
                };
                reader.onloadend = function() {
                  _this.reader = null;
                };
                if (checkOrientation || retainExif) {
                  reader.readAsArrayBuffer(file);
                } else {
                  reader.readAsDataURL(file);
                }
              }
            }
          }, {
            key: "load",
            value: function load2(data) {
              var _this2 = this;
              var file = this.file, image = this.image;
              image.onload = function() {
                _this2.draw(_objectSpread2(_objectSpread2({}, data), {}, {
                  naturalWidth: image.naturalWidth,
                  naturalHeight: image.naturalHeight
                }));
              };
              image.onabort = function() {
                _this2.fail(new Error("Aborted to load the image."));
              };
              image.onerror = function() {
                _this2.fail(new Error("Failed to load the image."));
              };
              if (WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent)) {
                image.crossOrigin = "anonymous";
              }
              image.alt = file.name;
              image.src = data.url;
            }
          }, {
            key: "draw",
            value: function draw(_ref2) {
              var _this3 = this;
              var naturalWidth = _ref2.naturalWidth, naturalHeight = _ref2.naturalHeight, _ref2$rotate = _ref2.rotate, rotate = _ref2$rotate === void 0 ? 0 : _ref2$rotate, _ref2$scaleX = _ref2.scaleX, scaleX = _ref2$scaleX === void 0 ? 1 : _ref2$scaleX, _ref2$scaleY = _ref2.scaleY, scaleY = _ref2$scaleY === void 0 ? 1 : _ref2$scaleY;
              var file = this.file, image = this.image, options = this.options;
              var canvas = document.createElement("canvas");
              var context = canvas.getContext("2d");
              var is90DegreesRotated = Math.abs(rotate) % 180 === 90;
              var resizable = (options.resize === "contain" || options.resize === "cover") && isPositiveNumber(options.width) && isPositiveNumber(options.height);
              var maxWidth = Math.max(options.maxWidth, 0) || Infinity;
              var maxHeight = Math.max(options.maxHeight, 0) || Infinity;
              var minWidth = Math.max(options.minWidth, 0) || 0;
              var minHeight = Math.max(options.minHeight, 0) || 0;
              var aspectRatio = naturalWidth / naturalHeight;
              var width = options.width, height = options.height;
              if (is90DegreesRotated) {
                var _ref3 = [maxHeight, maxWidth];
                maxWidth = _ref3[0];
                maxHeight = _ref3[1];
                var _ref4 = [minHeight, minWidth];
                minWidth = _ref4[0];
                minHeight = _ref4[1];
                var _ref5 = [height, width];
                width = _ref5[0];
                height = _ref5[1];
              }
              if (resizable) {
                aspectRatio = width / height;
              }
              var _getAdjustedSizes = getAdjustedSizes({
                aspectRatio,
                width: maxWidth,
                height: maxHeight
              }, "contain");
              maxWidth = _getAdjustedSizes.width;
              maxHeight = _getAdjustedSizes.height;
              var _getAdjustedSizes2 = getAdjustedSizes({
                aspectRatio,
                width: minWidth,
                height: minHeight
              }, "cover");
              minWidth = _getAdjustedSizes2.width;
              minHeight = _getAdjustedSizes2.height;
              if (resizable) {
                var _getAdjustedSizes3 = getAdjustedSizes({
                  aspectRatio,
                  width,
                  height
                }, options.resize);
                width = _getAdjustedSizes3.width;
                height = _getAdjustedSizes3.height;
              } else {
                var _getAdjustedSizes4 = getAdjustedSizes({
                  aspectRatio,
                  width,
                  height
                });
                var _getAdjustedSizes4$wi = _getAdjustedSizes4.width;
                width = _getAdjustedSizes4$wi === void 0 ? naturalWidth : _getAdjustedSizes4$wi;
                var _getAdjustedSizes4$he = _getAdjustedSizes4.height;
                height = _getAdjustedSizes4$he === void 0 ? naturalHeight : _getAdjustedSizes4$he;
              }
              width = Math.floor(normalizeDecimalNumber(Math.min(Math.max(width, minWidth), maxWidth)));
              height = Math.floor(normalizeDecimalNumber(Math.min(Math.max(height, minHeight), maxHeight)));
              var destX = -width / 2;
              var destY = -height / 2;
              var destWidth = width;
              var destHeight = height;
              var params = [];
              if (resizable) {
                var srcX = 0;
                var srcY = 0;
                var srcWidth = naturalWidth;
                var srcHeight = naturalHeight;
                var _getAdjustedSizes5 = getAdjustedSizes({
                  aspectRatio,
                  width: naturalWidth,
                  height: naturalHeight
                }, {
                  contain: "cover",
                  cover: "contain"
                }[options.resize]);
                srcWidth = _getAdjustedSizes5.width;
                srcHeight = _getAdjustedSizes5.height;
                srcX = (naturalWidth - srcWidth) / 2;
                srcY = (naturalHeight - srcHeight) / 2;
                params.push(srcX, srcY, srcWidth, srcHeight);
              }
              params.push(destX, destY, destWidth, destHeight);
              if (is90DegreesRotated) {
                var _ref6 = [height, width];
                width = _ref6[0];
                height = _ref6[1];
              }
              canvas.width = width;
              canvas.height = height;
              if (!isImageType(options.mimeType)) {
                options.mimeType = file.type;
              }
              var fillStyle = "transparent";
              if (file.size > options.convertSize && options.convertTypes.indexOf(options.mimeType) >= 0) {
                options.mimeType = "image/jpeg";
              }
              var isJPEGImage = options.mimeType === "image/jpeg";
              if (isJPEGImage) {
                fillStyle = "#fff";
              }
              context.fillStyle = fillStyle;
              context.fillRect(0, 0, width, height);
              if (options.beforeDraw) {
                options.beforeDraw.call(this, context, canvas);
              }
              if (this.aborted) {
                return;
              }
              context.save();
              context.translate(width / 2, height / 2);
              context.rotate(rotate * Math.PI / 180);
              context.scale(scaleX, scaleY);
              context.drawImage.apply(context, [image].concat(params));
              context.restore();
              if (options.drew) {
                options.drew.call(this, context, canvas);
              }
              if (this.aborted) {
                return;
              }
              var callback = function callback2(blob) {
                if (!_this3.aborted) {
                  var done = function done2(result) {
                    return _this3.done({
                      naturalWidth,
                      naturalHeight,
                      result
                    });
                  };
                  if (blob && isJPEGImage && options.retainExif && _this3.exif && _this3.exif.length > 0) {
                    var next = function next2(arrayBuffer) {
                      return done(toBlob(arrayBufferToDataURL(insertExif(arrayBuffer, _this3.exif), options.mimeType)));
                    };
                    if (blob.arrayBuffer) {
                      blob.arrayBuffer().then(next).catch(function() {
                        _this3.fail(new Error("Failed to read the compressed image with Blob.arrayBuffer()."));
                      });
                    } else {
                      var reader = new FileReader2();
                      _this3.reader = reader;
                      reader.onload = function(_ref7) {
                        var target = _ref7.target;
                        next(target.result);
                      };
                      reader.onabort = function() {
                        _this3.fail(new Error("Aborted to read the compressed image with FileReader."));
                      };
                      reader.onerror = function() {
                        _this3.fail(new Error("Failed to read the compressed image with FileReader."));
                      };
                      reader.onloadend = function() {
                        _this3.reader = null;
                      };
                      reader.readAsArrayBuffer(blob);
                    }
                  } else {
                    done(blob);
                  }
                }
              };
              if (canvas.toBlob) {
                canvas.toBlob(callback, options.mimeType, options.quality);
              } else {
                callback(toBlob(canvas.toDataURL(options.mimeType, options.quality)));
              }
            }
          }, {
            key: "done",
            value: function done(_ref8) {
              var naturalWidth = _ref8.naturalWidth, naturalHeight = _ref8.naturalHeight, result = _ref8.result;
              var file = this.file, image = this.image, options = this.options;
              if (URL2 && image.src.indexOf("blob:") === 0) {
                URL2.revokeObjectURL(image.src);
              }
              if (result) {
                if (options.strict && !options.retainExif && result.size > file.size && options.mimeType === file.type && !(options.width > naturalWidth || options.height > naturalHeight || options.minWidth > naturalWidth || options.minHeight > naturalHeight || options.maxWidth < naturalWidth || options.maxHeight < naturalHeight)) {
                  result = file;
                } else {
                  var date = /* @__PURE__ */ new Date();
                  result.lastModified = date.getTime();
                  result.lastModifiedDate = date;
                  result.name = file.name;
                  if (result.name && result.type !== file.type) {
                    result.name = result.name.replace(REGEXP_EXTENSION, imageTypeToExtension(result.type));
                  }
                }
              } else {
                result = file;
              }
              this.result = result;
              if (options.success) {
                options.success.call(this, result);
              }
            }
          }, {
            key: "fail",
            value: function fail(err) {
              var options = this.options;
              if (options.error) {
                options.error.call(this, err);
              } else {
                throw err;
              }
            }
          }, {
            key: "abort",
            value: function abort() {
              if (!this.aborted) {
                this.aborted = true;
                if (this.reader) {
                  this.reader.abort();
                } else if (!this.image.complete) {
                  this.image.onload = null;
                  this.image.onabort();
                } else {
                  this.fail(new Error("The compression process has been aborted."));
                }
              }
            }
            /**
             * Get the no conflict compressor class.
             * @returns {Compressor} The compressor class.
             */
          }], [{
            key: "noConflict",
            value: function noConflict() {
              window.Compressor = AnotherCompressor;
              return Compressor3;
            }
            /**
             * Change the default options.
             * @param {Object} options - The new default options.
             */
          }, {
            key: "setDefaults",
            value: function setDefaults(options) {
              _extends(DEFAULTS, options);
            }
          }]);
          return Compressor3;
        }();
        return Compressor2;
      });
    }
  });

  // ../../node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "../../node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w4) {
            if (!w4.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w4);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i4, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i4 in preservedScriptAttributes) {
              val = node[i4] || node.getAttribute && node.getAttribute(i4);
              if (val) {
                script.setAttribute(i4, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
          return new jQuery2.fn.init(selector, context);
        };
        jQuery2.fn = jQuery2.prototype = {
          // The current version of jQuery being used
          jquery: version2,
          constructor: jQuery2,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery2.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery2.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery2.map(this, function(elem, i4) {
              return callback.call(elem, i4, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i4) {
              return (i4 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i4) {
              return i4 % 2;
            }));
          },
          eq: function(i4) {
            var len = this.length, j4 = +i4 + (i4 < 0 ? len : 0);
            return this.pushStack(j4 >= 0 && j4 < len ? [this[j4]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery2.extend = jQuery2.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i4 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i4] || {};
            i4++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i4 === length) {
            target = this;
            i4--;
          }
          for (; i4 < length; i4++) {
            if ((options = arguments[i4]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery2.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery2.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i4 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i4 < length; i4++) {
                if (callback.call(obj[i4], i4, obj[i4]) === false) {
                  break;
                }
              }
            } else {
              for (i4 in obj) {
                if (callback.call(obj[i4], i4, obj[i4]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i4 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i4++]) {
                ret += jQuery2.text(node);
              }
            }
            if (nodeType === 1 || nodeType === 11) {
              return elem.textContent;
            }
            if (nodeType === 9) {
              return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery2.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i4) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i4);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j4 = 0, i4 = first.length;
            for (; j4 < len; j4++) {
              first[i4++] = second[j4];
            }
            first.length = i4;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i4 = 0, length = elems.length, callbackExpect = !invert;
            for (; i4 < length; i4++) {
              callbackInverse = !callback(elems[i4], i4);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i4]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i4 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i4 < length; i4++) {
                value = callback(elems[i4], i4, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i4 in elems) {
                value = callback(elems[i4], i4, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery2.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i2, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var pop = arr.pop;
        var sort = arr.sort;
        var splice = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery2.contains = function(a4, b4) {
          var bup = b4 && b4.parentNode;
          return a4 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a4.contains ? a4.contains(bup) : a4.compareDocumentPosition && a4.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery2.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i4, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a4, b4) {
            if (a4 === b4) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
            var high = "0x" + escape2.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e4) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find(selector, context, results, seed) {
            var m4, i5, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
                  if (m4 = match2[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m4)) {
                        if (elem.id === m4) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m4)) && find.contains(context, elem) && elem.id === m4) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match2[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m4 = match2[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m4));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery2.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize2(selector);
                    i5 = groups.length;
                    while (i5--) {
                      groups[i5] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i5]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache2(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache2[keys.shift()];
              }
              return cache2[key + " "] = value;
            }
            return cache2;
          }
          function markFunction(fn4) {
            fn4[expando] = true;
            return fn4;
          }
          function assert(fn4) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn4(el);
            } catch (e4) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn4) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j4, matchIndexes = fn4([], seed.length, argument), i5 = matchIndexes.length;
                while (i5--) {
                  if (seed[j4 = matchIndexes[i5]]) {
                    seed[j4] = !(matches2[j4] = seed[j4]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery2.isXMLDoc(document3);
            matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert(function(el) {
              documentElement2.appendChild(el).id = jQuery2.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
            });
            support.disconnectedMatch = assert(function(el) {
              return matches.call(el, "*");
            });
            support.scope = assert(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e4) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id14) {
                var attrId = id14.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id14, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id14);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id14) {
                var attrId = id14.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id14, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i5, elems, elem = context.getElementById(id14);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id14) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id14);
                    i5 = 0;
                    while (elem = elems[i5++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id14) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyQSA = [];
            assert(function(el) {
              var input;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a4, b4) {
              if (a4 === b4) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a4.compareDocumentPosition - !b4.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a4.ownerDocument || a4) == (b4.ownerDocument || b4) ? a4.compareDocumentPosition(b4) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b4.compareDocumentPosition(a4) === compare) {
                if (a4 === document3 || a4.ownerDocument == preferredDoc && find.contains(preferredDoc, a4)) {
                  return -1;
                }
                if (b4 === document3 || b4.ownerDocument == preferredDoc && find.contains(preferredDoc, b4)) {
                  return 1;
                }
                return sortInput ? indexOf2.call(sortInput, a4) - indexOf2.call(sortInput, b4) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find.matches = function(expr, elements) {
            return find(expr, null, null, elements);
          };
          find.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e4) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find(expr, document3, null, [elem]).length > 0;
          };
          find.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery2.contains(context, elem);
          };
          find.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn4 = Expr.attrHandle[name.toLowerCase()], val = fn4 && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn4(elem, name, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name);
          };
          find.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery2.uniqueSort = function(results) {
            var elem, duplicates = [], j4 = 0, i5 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i5++]) {
                if (elem === results[i5]) {
                  j4 = duplicates.push(i5);
                }
              }
              while (j4--) {
                splice.call(results, duplicates[j4], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery2.fn.uniqueSort = function() {
            return this.pushStack(jQuery2.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery2.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match2) {
                match2[1] = match2[1].replace(runescape, funescape);
                match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
                if (match2[2] === "~=") {
                  match2[3] = " " + match2[3] + " ";
                }
                return match2.slice(0, 4);
              },
              CHILD: function(match2) {
                match2[1] = match2[1].toLowerCase();
                if (match2[1].slice(0, 3) === "nth") {
                  if (!match2[3]) {
                    find.error(match2[0]);
                  }
                  match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                  match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
                } else if (match2[3]) {
                  find.error(match2[0]);
                }
                return match2;
              },
              PSEUDO: function(match2) {
                var excess, unquoted = !match2[6] && match2[2];
                if (matchExpr.CHILD.test(match2[0])) {
                  return null;
                }
                if (match2[3]) {
                  match2[2] = match2[4] || match2[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match2[0] = match2[0].slice(0, excess);
                  match2[2] = unquoted.slice(0, excess);
                }
                return match2.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name, operator, check) {
                return function(elem) {
                  var result = find.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check;
                  }
                  if (operator === "!=") {
                    return result !== check;
                  }
                  if (operator === "^=") {
                    return check && result.indexOf(check) === 0;
                  }
                  if (operator === "*=") {
                    return check && result.indexOf(check) > -1;
                  }
                  if (operator === "$=") {
                    return check && result.slice(-check.length) === check;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                  }
                  if (operator === "|=") {
                    return result === check || result.slice(0, check.length + 1) === check + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache2, outerCache, node, nodeIndex, start4, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start4 = dir2 = type === "only" && !start4 && "nextSibling";
                      }
                      return true;
                    }
                    start4 = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex && cache2[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start4.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        cache2 = outerCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start4.pop()) {
                          if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn4 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                if (fn4[expando]) {
                  return fn4(argument);
                }
                if (fn4.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn4(seed, argument), i5 = matched.length;
                    while (i5--) {
                      idx = indexOf2.call(seed, matched[i5]);
                      seed[idx] = !(matches2[idx] = matched[i5]);
                    }
                  }) : function(elem) {
                    return fn4(elem, 0, args);
                  };
                }
                return fn4;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i5 = seed.length;
                  while (i5--) {
                    if (elem = unmatched[i5]) {
                      seed[i5] = !(matches2[i5] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery2.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash5 = window2.location && window2.location.hash;
                return hash5 && hash5.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i5 = 0;
                for (; i5 < length; i5 += 2) {
                  matchIndexes.push(i5);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i5 = 1;
                for (; i5 < length; i5 += 2) {
                  matchIndexes.push(i5);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i5;
                if (argument < 0) {
                  i5 = argument + length;
                } else if (argument > length) {
                  i5 = length;
                } else {
                  i5 = argument;
                }
                for (; --i5 >= 0; ) {
                  matchIndexes.push(i5);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i5 = argument < 0 ? argument + length : argument;
                for (; ++i5 < length; ) {
                  matchIndexes.push(i5);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i4 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i4] = createInputPseudo(i4);
          }
          for (i4 in { submit: true, reset: true }) {
            Expr.pseudos[i4] = createButtonPseudo(i4);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize2(selector, parseOnly) {
            var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match2 = rcomma.exec(soFar))) {
                if (match2) {
                  soFar = soFar.slice(match2[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match2 = rleadingCombinator.exec(soFar)) {
                matched = match2.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match2[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
                  matched = match2.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match2
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i5 = 0, len = tokens.length, selector = "";
            for (; i5 < len; i5++) {
              selector += tokens[i5].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i5 = matchers.length;
              while (i5--) {
                if (!matchers[i5](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i5 = 0, len = contexts.length;
            for (; i5 < len; i5++) {
              find(selector, contexts[i5], results);
            }
            return results;
          }
          function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i5 = 0, len = unmatched.length, mapped = map != null;
            for (; i5 < len; i5++) {
              if (elem = unmatched[i5]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i5);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i5, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i5 = temp.length;
                while (i5--) {
                  if (elem = temp[i5]) {
                    matcherOut[postMap[i5]] = !(matcherIn[postMap[i5]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i5 = matcherOut.length;
                    while (i5--) {
                      if (elem = matcherOut[i5]) {
                        temp.push(matcherIn[i5] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i5 = matcherOut.length;
                  while (i5--) {
                    if ((elem = matcherOut[i5]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i5]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j4, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i5 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i5 < len; i5++) {
              if (matcher = Expr.relative[tokens[i5].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i5].type].apply(null, tokens[i5].matches);
                if (matcher[expando]) {
                  j4 = ++i5;
                  for (; j4 < len; j4++) {
                    if (Expr.relative[tokens[j4].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i5 > 1 && elementMatcher(matchers),
                    i5 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i5 - 1).concat({ value: tokens[i5 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i5 < j4 && matcherFromTokens(tokens.slice(i5, j4)),
                    j4 < len && matcherFromTokens(tokens = tokens.slice(j4)),
                    j4 < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j4, matcher, matchedCount = 0, i5 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i5 !== len && (elem = elems[i5]) != null; i5++) {
                if (byElement && elem) {
                  j4 = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j4++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i5;
              if (bySet && i5 !== matchedCount) {
                j4 = 0;
                while (matcher = setMatchers[j4++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i5--) {
                      if (!(unmatched[i5] || setMatched[i5])) {
                        setMatched[i5] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery2.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile(selector, match2) {
            var i5, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match2) {
                match2 = tokenize2(selector);
              }
              i5 = match2.length;
              while (i5--) {
                cached = matcherFromTokens(match2[i5]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i5, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match2 = !seed && tokenize2(selector = compiled.selector || selector);
            results = results || [];
            if (match2.length === 1) {
              tokens = match2[0] = match2[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i5 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i5--) {
                token = tokens[i5];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find2 = Expr.find[type]) {
                  if (seed = find2(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i5, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match2))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          setDocument();
          support.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery2.find = find;
          jQuery2.expr[":"] = jQuery2.expr.pseudos;
          jQuery2.unique = jQuery2.uniqueSort;
          find.compile = compile;
          find.select = select;
          find.setDocument = setDocument;
          find.tokenize = tokenize2;
          find.escape = jQuery2.escapeSelector;
          find.getText = jQuery2.text;
          find.isXML = jQuery2.isXMLDoc;
          find.selectors = jQuery2.expr;
          find.support = jQuery2.support;
          find.uniqueSort = jQuery2.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery2(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n4, elem) {
          var matched = [];
          for (; n4; n4 = n4.nextSibling) {
            if (n4.nodeType === 1 && n4 !== elem) {
              matched.push(n4);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery2.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery2.grep(elements, function(elem, i4) {
              return !!qualifier.call(elem, i4, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery2.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery2.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery2.filter(qualifier, elements, not);
        }
        jQuery2.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery2.fn.extend({
          find: function(selector) {
            var i4, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery2(selector).filter(function() {
                for (i4 = 0; i4 < len; i4++) {
                  if (jQuery2.contains(self2[i4], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i4 = 0; i4 < len; i4++) {
              jQuery2.find(selector, self2[i4], ret);
            }
            return len > 1 ? jQuery2.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root) {
          var match2, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match2 = [null, selector, null];
            } else {
              match2 = rquickExpr.exec(selector);
            }
            if (match2 && (match2[1] || !context)) {
              if (match2[1]) {
                context = context instanceof jQuery2 ? context[0] : context;
                jQuery2.merge(this, jQuery2.parseHTML(
                  match2[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match2[1]) && jQuery2.isPlainObject(context)) {
                  for (match2 in context) {
                    if (isFunction(this[match2])) {
                      this[match2](context[match2]);
                    } else {
                      this.attr(match2, context[match2]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match2[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery2)
            );
          }
          return jQuery2.makeArray(selector, this);
        };
        init.prototype = jQuery2.fn;
        rootjQuery = jQuery2(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery2.fn.extend({
          has: function(target) {
            var targets = jQuery2(target, this), l4 = targets.length;
            return this.filter(function() {
              var i4 = 0;
              for (; i4 < l4; i4++) {
                if (jQuery2.contains(this, targets[i4])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i4 = 0, l4 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i4 < l4; i4++) {
                for (cur = this[i4]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery2(elem), this[0]);
            }
            return indexOf2.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery2.uniqueSort(
                jQuery2.merge(this.get(), jQuery2(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery2.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i2, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i2, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i2, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery2.merge([], elem.childNodes);
          }
        }, function(name, fn4) {
          jQuery2.fn[name] = function(until, selector) {
            var matched = jQuery2.map(this, fn4, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery2.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery2.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery2.each(options.match(rnothtmlwhite) || [], function(_4, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery2.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add2(args) {
                  jQuery2.each(args, function(_4, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add2(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery2.each(arguments, function(_4, arg) {
                var index;
                while ((index = jQuery2.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn4) {
              return fn4 ? jQuery2.inArray(fn4, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v4) {
          return v4;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery2.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery2.Callbacks("memory"),
                jQuery2.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn4) {
                return promise.then(null, fn4);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery2.Deferred(function(newDefer) {
                  jQuery2.each(tuples, function(_i2, tuple) {
                    var fn4 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn4 && fn4.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn4 ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e4) {
                        if (jQuery2.Deferred.exceptionHook) {
                          jQuery2.Deferred.exceptionHook(
                            e4,
                            process2.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e4];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery2.Deferred.getErrorHook) {
                        process2.error = jQuery2.Deferred.getErrorHook();
                      } else if (jQuery2.Deferred.getStackHook) {
                        process2.error = jQuery2.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery2.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery2.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery2.each(tuples, function(i4, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i4][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i4][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i4 = remaining, resolveContexts = Array(i4), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i5) {
              return function(value) {
                resolveContexts[i5] = this;
                resolveValues[i5] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i4)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i4] && resolveValues[i4].then)) {
                return primary.then();
              }
            }
            while (i4--) {
              adoptValue(resolveValues[i4], updateFunc(i4), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery2.Deferred.exceptionHook = function(error2, asyncError) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error2.message,
              error2.stack,
              asyncError
            );
          }
        };
        jQuery2.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery2.Deferred();
        jQuery2.fn.ready = function(fn4) {
          readyList.then(fn4).catch(function(error2) {
            jQuery2.readyException(error2);
          });
          return this;
        };
        jQuery2.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
              return;
            }
            jQuery2.isReady = true;
            if (wait !== true && --jQuery2.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery2]);
          }
        });
        jQuery2.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery2.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery2.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn4, key, value, chainable, emptyGet, raw) {
          var i4 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i4 in key) {
              access(elems, fn4, i4, key[i4], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn4.call(elems, value);
                fn4 = null;
              } else {
                bulk = fn4;
                fn4 = function(elem, _key, value2) {
                  return bulk.call(jQuery2(elem), value2);
                };
              }
            }
            if (fn4) {
              for (; i4 < len; i4++) {
                fn4(
                  elems[i4],
                  key,
                  raw ? value : value.call(elems[i4], i4, fn4(elems[i4], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn4.call(elems);
          }
          return len ? fn4(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery2.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i4, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i4 = key.length;
              while (i4--) {
                delete cache2[key[i4]];
              }
            }
            if (key === void 0 || jQuery2.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery2.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e4) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery2.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery2.fn.extend({
          data: function(key, value) {
            var i4, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i4 = attrs.length;
                  while (i4--) {
                    if (attrs[i4]) {
                      name = attrs[i4].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery2.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery2.queue(elem, type), startLength = queue.length, fn4 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
              jQuery2.dequeue(elem, type);
            };
            if (fn4 === "inprogress") {
              fn4 = queue.shift();
              startLength--;
            }
            if (fn4) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn4.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery2.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery2.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery2.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery2.queue(this, type, data);
              jQuery2._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery2.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery2.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i4 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i4--) {
              tmp = dataPriv.get(elements[i4], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery2.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery2.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery2.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery2.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery2.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery2.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery2(this).show();
              } else {
                jQuery2(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div2 = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div2.appendChild(input);
          support.checkClone = div2.cloneNode(true).cloneNode(true).lastChild.checked;
          div2.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div2.cloneNode(true).lastChild.defaultValue;
          div2.innerHTML = "<option></option>";
          support.option = !!div2.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery2.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i4 = 0, l4 = elems.length;
          for (; i4 < l4; i4++) {
            dataPriv.set(
              elems[i4],
              "globalEval",
              !refElements || dataPriv.get(refElements[i4], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j4, fragment = context.createDocumentFragment(), nodes = [], i4 = 0, l4 = elems.length;
          for (; i4 < l4; i4++) {
            elem = elems[i4];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
                j4 = wrap[0];
                while (j4--) {
                  tmp = tmp.lastChild;
                }
                jQuery2.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i4 = 0;
          while (elem = nodes[i4++]) {
            if (selection && jQuery2.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j4 = 0;
              while (elem = tmp[j4++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on2(elem, types, selector, data, fn4, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on2(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn4 == null) {
            fn4 = selector;
            data = selector = void 0;
          } else if (fn4 == null) {
            if (typeof selector === "string") {
              fn4 = data;
              data = void 0;
            } else {
              fn4 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn4 === false) {
            fn4 = returnFalse;
          } else if (!fn4) {
            return elem;
          }
          if (one === 1) {
            origFn = fn4;
            fn4 = function(event) {
              jQuery2().off(event);
              return origFn.apply(this, arguments);
            };
            fn4.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
          }
          return elem.each(function() {
            jQuery2.event.add(this, types, fn4, data, selector);
          });
        }
        jQuery2.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t5, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery2.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery2.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e4) {
                return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e4.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t5 = types.length;
            while (t5--) {
              tmp = rtypenamespace.exec(types[t5]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery2.event.special[type] || {};
              handleObj = jQuery2.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery2.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j4, origCount, tmp, events, t5, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t5 = types.length;
            while (t5--) {
              tmp = rtypenamespace.exec(types[t5]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery2.event.remove(elem, type + types[t5], handler, selector, true);
                }
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j4 = handlers.length;
              while (j4--) {
                handleObj = handlers[j4];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j4, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery2.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery2.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i4, j4, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
            args[0] = event;
            for (i4 = 1; i4 < arguments.length; i4++) {
              args[i4] = arguments[i4];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
            i4 = 0;
            while ((matched = handlerQueue[i4++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j4 = 0;
              while ((handleObj = matched.handlers[j4++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i4, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i4 = 0; i4 < delegateCount; i4++) {
                    handleObj = handlers[i4];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery2.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery2.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery2.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery2.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery2.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery2.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery2.Event = function(src, props) {
          if (!(this instanceof jQuery2.Event)) {
            return new jQuery2.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery2.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery2.expando] = true;
        };
        jQuery2.Event.prototype = {
          constructor: jQuery2.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e4 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e4 && !this.isSimulated) {
              e4.preventDefault();
            }
          },
          stopPropagation: function() {
            var e4 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e4 && !this.isSimulated) {
              e4.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e4 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e4 && !this.isSimulated) {
              e4.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery2.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery2.event.addProp);
        jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery2.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery2.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery2.event.fix(nativeEvent)
              );
            }
          }
          jQuery2.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery2.event.special[delegateType] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery2.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery2.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery2.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery2.fn.extend({
          on: function(types, selector, data, fn4) {
            return on2(this, types, selector, data, fn4);
          },
          one: function(types, selector, data, fn4) {
            return on2(this, types, selector, data, fn4, 1);
          },
          off: function(types, selector, fn4) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery2(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn4 = selector;
              selector = void 0;
            }
            if (fn4 === false) {
              fn4 = returnFalse;
            }
            return this.each(function() {
              jQuery2.event.remove(this, types, fn4, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery2(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i4, l4, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i4 = 0, l4 = events[type].length; i4 < l4; i4++) {
                  jQuery2.event.add(dest, type, events[type][i4]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery2.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i4 = 0, l4 = collection.length, iNoClone = l4 - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l4 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l4) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i4 < l4; i4++) {
                node = fragment;
                if (i4 !== iNoClone) {
                  node = jQuery2.clone(node, true, true);
                  if (hasScripts) {
                    jQuery2.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i4], node, i4);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery2.map(scripts, restoreScript);
                for (i4 = 0; i4 < hasScripts; i4++) {
                  node = scripts[i4];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery2._evalUrl && !node.noModule) {
                        jQuery2._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i4 = 0;
          for (; (node = nodes[i4]) != null; i4++) {
            if (!keepData && node.nodeType === 1) {
              jQuery2.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery2.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i4, l4, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i4 = 0, l4 = srcElements.length; i4 < l4; i4++) {
                fixInput(srcElements[i4], destElements[i4]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i4 = 0, l4 = srcElements.length; i4 < l4; i4++) {
                  cloneCopyEvent(srcElements[i4], destElements[i4]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery2.event.special, i4 = 0;
            for (; (elem = elems[i4]) !== void 0; i4++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery2.event.remove(elem, type);
                      } else {
                        jQuery2.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery2.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i4 = 0;
            for (; (elem = this[i4]) != null; i4++) {
              if (elem.nodeType === 1) {
                jQuery2.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i4 = 0, l4 = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery2.htmlPrefilter(value2);
                try {
                  for (; i4 < l4; i4++) {
                    elem = this[i4] || {};
                    if (elem.nodeType === 1) {
                      jQuery2.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e4) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery2.inArray(this, ignored) < 0) {
                jQuery2.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery2.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery2.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i4 = 0;
            for (; i4 <= last; i4++) {
              elems = i4 === last ? this : this.clone(true);
              jQuery2(insert[i4])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div2) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div2);
            var divStyle = window2.getComputedStyle(div2);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div2.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div2.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div2.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div2 = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div2 = document2.createElement("div");
          if (!div2.style) {
            return;
          }
          div2.style.backgroundClip = "content-box";
          div2.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div2.style.backgroundClip === "content-box";
          jQuery2.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr2, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr2 = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr2.style.cssText = "box-sizing:content-box;border:1px solid";
                tr2.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr2).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr2);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr2.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery2.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i4 = cssPrefixes.length;
          while (i4--) {
            name = cssPrefixes[i4] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery2.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i4 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i4 < 4; i4 += 2) {
            if (box === "margin") {
              marginDelta += jQuery2.css(elem, box + cssExpand[i4], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery2.css(elem, "padding" + cssExpand[i4], true, styles);
              if (box !== "padding") {
                delta += jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
              } else {
                extra += jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery2.css(elem, "padding" + cssExpand[i4], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery2.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery2.each(["height", "width"], function(_i2, dimension) {
          jQuery2.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery2.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery2.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery2.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery2.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i4 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i4 < 4; i4++) {
                expanded[prefix + cssExpand[i4] + suffix] = parts[i4] || parts[i4 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery2.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i4 = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i4 < len; i4++) {
                  map[name2[i4]] = jQuery2.css(elem, name2[i4], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end3, easing) {
          return new Tween.prototype.init(elem, options, prop, end3, easing);
        }
        jQuery2.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end3, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery2.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end3;
            this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery2.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery2.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery2.fx.step[tween.prop]) {
                jQuery2.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery2.easing = {
          linear: function(p4) {
            return p4;
          },
          swing: function(p4) {
            return 0.5 - Math.cos(p4 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery2.fx = Tween.prototype.init;
        jQuery2.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery2.fx.interval);
            }
            jQuery2.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i4 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i4 < 4; i4 += 2 - includeWidth) {
            which = cssExpand[i4];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery2._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery2.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
            }
          }
          propTween = !jQuery2.isEmptyObject(props);
          if (!propTween && jQuery2.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery2.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery2.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery2.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery2.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery2.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery2.extend({}, properties),
            opts: jQuery2.extend(true, {
              specialEasing: {},
              easing: jQuery2.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end3) {
              var tween = jQuery2.Tween(
                elem,
                animation.opts,
                prop,
                end3,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery2.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery2.fx.timer(
            jQuery2.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery2.Animation = jQuery2.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery2.speed = function(speed, easing, fn4) {
          var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
            complete: fn4 || !fn4 && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn4 && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery2.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery2.fx.speeds) {
                opt.duration = jQuery2.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery2.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery2.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery2.fn.extend({
          fadeTo: function(speed, to2, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to2 }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery2.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery2.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery2.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery2.each(["toggle", "show", "hide"], function(_i2, name) {
          var cssFn = jQuery2.fn[name];
          jQuery2.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery2.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery2.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery2.timers = [];
        jQuery2.fx.tick = function() {
          var timer, i4 = 0, timers = jQuery2.timers;
          fxNow = Date.now();
          for (; i4 < timers.length; i4++) {
            timer = timers[i4];
            if (!timer() && timers[i4] === timer) {
              timers.splice(i4--, 1);
            }
          }
          if (!timers.length) {
            jQuery2.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery2.fx.timer = function(timer) {
          jQuery2.timers.push(timer);
          jQuery2.fx.start();
        };
        jQuery2.fx.interval = 13;
        jQuery2.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery2.fx.stop = function() {
          inProgress = null;
        };
        jQuery2.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery2.fn.delay = function(time, type) {
          time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery2.expr.attrHandle;
        jQuery2.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery2.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery2.removeAttr(this, name);
            });
          }
        });
        jQuery2.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery2.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery2.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery2.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i4 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i4++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery2.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i2, name) {
          var getter = attrHandle[name] || jQuery2.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery2.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery2.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery2.propFix[name] || name];
            });
          }
        });
        jQuery2.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              name = jQuery2.propFix[name] || name;
              hooks = jQuery2.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery2.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery2.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery2.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery2.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery2.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i4, finalValue;
            if (isFunction(value)) {
              return this.each(function(j4) {
                jQuery2(this).addClass(value.call(this, j4, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i4 = 0; i4 < classNames.length; i4++) {
                    className = classNames[i4];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i4, finalValue;
            if (isFunction(value)) {
              return this.each(function(j4) {
                jQuery2(this).removeClass(value.call(this, j4, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i4 = 0; i4 < classNames.length; i4++) {
                    className = classNames[i4];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i4, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i5) {
                jQuery2(this).toggleClass(
                  value.call(this, i5, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery2(this);
                for (i4 = 0; i4 < classNames.length; i4++) {
                  className = classNames[i4];
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i4 = 0;
            className = " " + selector + " ";
            while (elem = this[i4++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery2.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i4) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i4, jQuery2(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery2.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery2.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery2.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery2.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i4, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max3 = one ? index + 1 : options.length;
                if (index < 0) {
                  i4 = max3;
                } else {
                  i4 = one ? index : 0;
                }
                for (; i4 < max3; i4++) {
                  option = options[i4];
                  if ((option.selected || i4 === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery2(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i4 = options.length;
                while (i4--) {
                  option = options[i4];
                  if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery2.each(["radio", "checkbox"], function() {
          jQuery2.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery2.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery2.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e4) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e4) {
          e4.stopPropagation();
        };
        jQuery2.extend(jQuery2.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i4, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery2.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery2.makeArray(data, [event]);
            special = jQuery2.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i4 = 0;
            while ((cur = eventPath[i4++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i4 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery2.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery2.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e4 = jQuery2.extend(
              new jQuery2.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery2.event.trigger(e4, null, elem);
          }
        });
        jQuery2.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery2.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery2.event.trigger(type, data, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add2) {
          var name;
          if (Array.isArray(obj)) {
            jQuery2.each(obj, function(i4, v4) {
              if (traditional || rbracket.test(prefix)) {
                add2(prefix, v4);
              } else {
                buildParams(
                  prefix + "[" + (typeof v4 === "object" && v4 != null ? i4 : "") + "]",
                  v4,
                  traditional,
                  add2
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
            }
          } else {
            add2(prefix, obj);
          }
        }
        jQuery2.param = function(a4, traditional) {
          var prefix, s4 = [], add2 = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s4[s4.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a4 == null) {
            return "";
          }
          if (Array.isArray(a4) || a4.jquery && !jQuery2.isPlainObject(a4)) {
            jQuery2.each(a4, function() {
              add2(this.name, this.value);
            });
          } else {
            for (prefix in a4) {
              buildParams(prefix, a4[prefix], traditional, add2);
            }
          }
          return s4.join("&");
        };
        jQuery2.fn.extend({
          serialize: function() {
            return jQuery2.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery2.prop(this, "elements");
              return elements ? jQuery2.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i2, elem) {
              var val = jQuery2(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery2.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i4 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i4++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery2.each(structure[dataType] || [], function(_4, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery2.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s4, jqXHR, responses) {
          var ct2, type, finalDataType, firstDataType, contents = s4.contents, dataTypes = s4.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct2 === void 0) {
              ct2 = s4.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct2) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct2)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s4.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s4, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s4.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s4.converters) {
              converters[conv.toLowerCase()] = s4.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s4.responseFields[current]) {
              jqXHR[s4.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s4.dataFilter) {
              response = s4.dataFilter(response, s4.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s4.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e4) {
                      return {
                        state: "parsererror",
                        error: conv ? e4 : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery2.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery2.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery2.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i4, uncached, s4 = jQuery2.ajaxSetup({}, options), callbackContext = s4.context || s4, globalEventContext = s4.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s4.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match2;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match2 = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                    }
                  }
                  match2 = responseHeaders[key.toLowerCase() + " "];
                }
                return match2 == null ? null : match2.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s4.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s4.url = ((url || s4.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s4.type = options.method || options.type || s4.method || s4.type;
            s4.dataTypes = (s4.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s4.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s4.url;
                urlAnchor.href = urlAnchor.href;
                s4.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e4) {
                s4.crossDomain = true;
              }
            }
            if (s4.data && s4.processData && typeof s4.data !== "string") {
              s4.data = jQuery2.param(s4.data, s4.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s4, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery2.event && s4.global;
            if (fireGlobals && jQuery2.active++ === 0) {
              jQuery2.event.trigger("ajaxStart");
            }
            s4.type = s4.type.toUpperCase();
            s4.hasContent = !rnoContent.test(s4.type);
            cacheURL = s4.url.replace(rhash, "");
            if (!s4.hasContent) {
              uncached = s4.url.slice(cacheURL.length);
              if (s4.data && (s4.processData || typeof s4.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s4.data;
                delete s4.data;
              }
              if (s4.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s4.url = cacheURL + uncached;
            } else if (s4.data && s4.processData && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s4.data = s4.data.replace(r20, "+");
            }
            if (s4.ifModified) {
              if (jQuery2.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
              }
              if (jQuery2.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
              }
            }
            if (s4.data && s4.hasContent && s4.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s4.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s4.dataTypes[0] && s4.accepts[s4.dataTypes[0]] ? s4.accepts[s4.dataTypes[0]] + (s4.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s4.accepts["*"]
            );
            for (i4 in s4.headers) {
              jqXHR.setRequestHeader(i4, s4.headers[i4]);
            }
            if (s4.beforeSend && (s4.beforeSend.call(callbackContext, jqXHR, s4) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s4.complete);
            jqXHR.done(s4.success);
            jqXHR.fail(s4.error);
            transport = inspectPrefiltersOrTransports(transports, s4, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s4]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s4.async && s4.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s4.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e4) {
                if (completed2) {
                  throw e4;
                }
                done(-1, e4);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s4, jqXHR, responses);
              }
              if (!isSuccess && jQuery2.inArray("script", s4.dataTypes) > -1 && jQuery2.inArray("json", s4.dataTypes) < 0) {
                s4.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s4, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s4.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery2.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery2.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s4.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s4, isSuccess ? success : error2]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s4]);
                if (!--jQuery2.active) {
                  jQuery2.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery2.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery2.get(url, void 0, callback, "script");
          }
        });
        jQuery2.each(["get", "post"], function(_i2, method) {
          jQuery2[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery2.ajax(jQuery2.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery2.isPlainObject(url) && url));
          };
        });
        jQuery2.ajaxPrefilter(function(s4) {
          var i4;
          for (i4 in s4.headers) {
            if (i4.toLowerCase() === "content-type") {
              s4.contentType = s4.headers[i4] || "";
            }
          }
        });
        jQuery2._evalUrl = function(url, options, doc) {
          return jQuery2.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery2.globalEval(response, options, doc);
            }
          });
        };
        jQuery2.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i4) {
                jQuery2(this).wrapInner(html.call(this, i4));
              });
            }
            return this.each(function() {
              var self2 = jQuery2(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i4) {
              jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i4) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery2(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery2.expr.pseudos.hidden = function(elem) {
          return !jQuery2.expr.pseudos.visible(elem);
        };
        jQuery2.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery2.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e4) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery2.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery2.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i4, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i4 in options.xhrFields) {
                    xhr[i4] = options.xhrFields[i4];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i4 in headers) {
                  xhr.setRequestHeader(i4, headers[i4]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e4) {
                  if (callback) {
                    throw e4;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery2.ajaxPrefilter(function(s4) {
          if (s4.crossDomain) {
            s4.contents.script = false;
          }
        });
        jQuery2.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery2.globalEval(text);
              return text;
            }
          }
        });
        jQuery2.ajaxPrefilter("script", function(s4) {
          if (s4.cache === void 0) {
            s4.cache = false;
          }
          if (s4.crossDomain) {
            s4.type = "GET";
          }
        });
        jQuery2.ajaxTransport("script", function(s4) {
          if (s4.crossDomain || s4.scriptAttrs) {
            var script, callback;
            return {
              send: function(_4, complete) {
                script = jQuery2("<script>").attr(s4.scriptAttrs || {}).prop({ charset: s4.scriptCharset, src: s4.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery2.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery2.ajaxPrefilter("json jsonp", function(s4, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s4.jsonp !== false && (rjsonp.test(s4.url) ? "url" : typeof s4.data === "string" && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s4.data) && "data");
          if (jsonProp || s4.dataTypes[0] === "jsonp") {
            callbackName = s4.jsonpCallback = isFunction(s4.jsonpCallback) ? s4.jsonpCallback() : s4.jsonpCallback;
            if (jsonProp) {
              s4[jsonProp] = s4[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s4.jsonp !== false) {
              s4.url += (rquery.test(s4.url) ? "&" : "?") + s4.jsonp + "=" + callbackName;
            }
            s4.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery2.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s4.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery2(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s4[callbackName]) {
                s4.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery2.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery2(scripts).remove();
          }
          return jQuery2.merge([], parsed.childNodes);
        };
        jQuery2.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery2.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery2.expr.pseudos.animated = function(elem) {
          return jQuery2.grep(jQuery2.timers, function(fn4) {
            return elem === fn4.elem;
          }).length;
        };
        jQuery2.offset = {
          setOffset: function(elem, options, i4) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery2.css(elem, "top");
            curCSSLeft = jQuery2.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i4, jQuery2.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery2.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i4) {
                jQuery2.offset.setOffset(this, options, i4);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset3, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery2.css(elem, "position") === "fixed") {
              offset3 = elem.getBoundingClientRect();
            } else {
              offset3 = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery2(offsetParent).offset();
                parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset3.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
              left: offset3.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top3 = "pageYOffset" === prop;
          jQuery2.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top3 ? val2 : win.pageXOffset,
                  top3 ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery2.each(["top", "left"], function(_i2, prop) {
          jQuery2.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery2.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery2.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery2.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery2.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery2.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i2, type) {
          jQuery2.fn[type] = function(fn4) {
            return this.on(type, fn4);
          };
        });
        jQuery2.fn.extend({
          bind: function(types, data, fn4) {
            return this.on(types, null, data, fn4);
          },
          unbind: function(types, fn4) {
            return this.off(types, null, fn4);
          },
          delegate: function(selector, types, data, fn4) {
            return this.on(types, selector, data, fn4);
          },
          undelegate: function(selector, types, fn4) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn4);
          },
          hover: function(fnOver, fnOut) {
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
          }
        });
        jQuery2.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i2, name) {
            jQuery2.fn[name] = function(data, fn4) {
              return arguments.length > 0 ? this.on(name, null, data, fn4) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery2.proxy = function(fn4, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn4[context];
            context = fn4;
            fn4 = tmp;
          }
          if (!isFunction(fn4)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn4.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn4.guid = fn4.guid || jQuery2.guid++;
          return proxy;
        };
        jQuery2.holdReady = function(hold) {
          if (hold) {
            jQuery2.readyWait++;
          } else {
            jQuery2.ready(true);
          }
        };
        jQuery2.isArray = Array.isArray;
        jQuery2.parseJSON = JSON.parse;
        jQuery2.nodeName = nodeName;
        jQuery2.isFunction = isFunction;
        jQuery2.isWindow = isWindow;
        jQuery2.camelCase = camelCase;
        jQuery2.type = toType;
        jQuery2.now = Date.now;
        jQuery2.isNumeric = function(obj) {
          var type = jQuery2.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery2.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery2;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery2.noConflict = function(deep) {
          if (window2.$ === jQuery2) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery2) {
            window2.jQuery = _jQuery;
          }
          return jQuery2;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery2;
        }
        return jQuery2;
      });
    }
  });

  // ../../node_modules/select2/dist/js/select2.js
  var require_select2 = __commonJS({
    "../../node_modules/select2/dist/js/select2.js"(exports, module) {
      (function(factory) {
        if (typeof define === "function" && define.amd) {
          define(["jquery"], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = function(root, jQuery2) {
            if (jQuery2 === void 0) {
              if (typeof window !== "undefined") {
                jQuery2 = require_jquery();
              } else {
                jQuery2 = require_jquery()(root);
              }
            }
            factory(jQuery2);
            return jQuery2;
          };
        } else {
          factory(jQuery);
        }
      })(function(jQuery2) {
        var S22 = function() {
          if (jQuery2 && jQuery2.fn && jQuery2.fn.select2 && jQuery2.fn.select2.amd) {
            var S23 = jQuery2.fn.select2.amd;
          }
          var S23;
          (function() {
            if (!S23 || !S23.requirejs) {
              if (!S23) {
                S23 = {};
              } else {
                require2 = S23;
              }
              var requirejs, require2, define2;
              (function(undef) {
                var main3, req, makeMap, handlers, defined = {}, waiting = {}, config2 = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                function hasProp(obj, prop) {
                  return hasOwn.call(obj, prop);
                }
                function normalize(name, baseName) {
                  var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i4, j4, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map = config2.map, starMap = map && map["*"] || {};
                  if (name) {
                    name = name.split("/");
                    lastIndex = name.length - 1;
                    if (config2.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                      name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                    }
                    if (name[0].charAt(0) === "." && baseParts) {
                      normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                      name = normalizedBaseParts.concat(name);
                    }
                    for (i4 = 0; i4 < name.length; i4++) {
                      part = name[i4];
                      if (part === ".") {
                        name.splice(i4, 1);
                        i4 -= 1;
                      } else if (part === "..") {
                        if (i4 === 0 || i4 === 1 && name[2] === ".." || name[i4 - 1] === "..") {
                          continue;
                        } else if (i4 > 0) {
                          name.splice(i4 - 1, 2);
                          i4 -= 2;
                        }
                      }
                    }
                    name = name.join("/");
                  }
                  if ((baseParts || starMap) && map) {
                    nameParts = name.split("/");
                    for (i4 = nameParts.length; i4 > 0; i4 -= 1) {
                      nameSegment = nameParts.slice(0, i4).join("/");
                      if (baseParts) {
                        for (j4 = baseParts.length; j4 > 0; j4 -= 1) {
                          mapValue = map[baseParts.slice(0, j4).join("/")];
                          if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                              foundMap = mapValue;
                              foundI = i4;
                              break;
                            }
                          }
                        }
                      }
                      if (foundMap) {
                        break;
                      }
                      if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i4;
                      }
                    }
                    if (!foundMap && foundStarMap) {
                      foundMap = foundStarMap;
                      foundI = starI;
                    }
                    if (foundMap) {
                      nameParts.splice(0, foundI, foundMap);
                      name = nameParts.join("/");
                    }
                  }
                  return name;
                }
                function makeRequire(relName, forceSync) {
                  return function() {
                    var args = aps.call(arguments, 0);
                    if (typeof args[0] !== "string" && args.length === 1) {
                      args.push(null);
                    }
                    return req.apply(undef, args.concat([relName, forceSync]));
                  };
                }
                function makeNormalize(relName) {
                  return function(name) {
                    return normalize(name, relName);
                  };
                }
                function makeLoad(depName) {
                  return function(value) {
                    defined[depName] = value;
                  };
                }
                function callDep(name) {
                  if (hasProp(waiting, name)) {
                    var args = waiting[name];
                    delete waiting[name];
                    defining[name] = true;
                    main3.apply(undef, args);
                  }
                  if (!hasProp(defined, name) && !hasProp(defining, name)) {
                    throw new Error("No " + name);
                  }
                  return defined[name];
                }
                function splitPrefix(name) {
                  var prefix, index = name ? name.indexOf("!") : -1;
                  if (index > -1) {
                    prefix = name.substring(0, index);
                    name = name.substring(index + 1, name.length);
                  }
                  return [prefix, name];
                }
                function makeRelParts(relName) {
                  return relName ? splitPrefix(relName) : [];
                }
                makeMap = function(name, relParts) {
                  var plugin, parts = splitPrefix(name), prefix = parts[0], relResourceName = relParts[1];
                  name = parts[1];
                  if (prefix) {
                    prefix = normalize(prefix, relResourceName);
                    plugin = callDep(prefix);
                  }
                  if (prefix) {
                    if (plugin && plugin.normalize) {
                      name = plugin.normalize(name, makeNormalize(relResourceName));
                    } else {
                      name = normalize(name, relResourceName);
                    }
                  } else {
                    name = normalize(name, relResourceName);
                    parts = splitPrefix(name);
                    prefix = parts[0];
                    name = parts[1];
                    if (prefix) {
                      plugin = callDep(prefix);
                    }
                  }
                  return {
                    f: prefix ? prefix + "!" + name : name,
                    //fullName
                    n: name,
                    pr: prefix,
                    p: plugin
                  };
                };
                function makeConfig(name) {
                  return function() {
                    return config2 && config2.config && config2.config[name] || {};
                  };
                }
                handlers = {
                  require: function(name) {
                    return makeRequire(name);
                  },
                  exports: function(name) {
                    var e4 = defined[name];
                    if (typeof e4 !== "undefined") {
                      return e4;
                    } else {
                      return defined[name] = {};
                    }
                  },
                  module: function(name) {
                    return {
                      id: name,
                      uri: "",
                      exports: defined[name],
                      config: makeConfig(name)
                    };
                  }
                };
                main3 = function(name, deps, callback, relName) {
                  var cjsModule, depName, ret, map, i4, relParts, args = [], callbackType = typeof callback, usingExports;
                  relName = relName || name;
                  relParts = makeRelParts(relName);
                  if (callbackType === "undefined" || callbackType === "function") {
                    deps = !deps.length && callback.length ? ["require", "exports", "module"] : deps;
                    for (i4 = 0; i4 < deps.length; i4 += 1) {
                      map = makeMap(deps[i4], relParts);
                      depName = map.f;
                      if (depName === "require") {
                        args[i4] = handlers.require(name);
                      } else if (depName === "exports") {
                        args[i4] = handlers.exports(name);
                        usingExports = true;
                      } else if (depName === "module") {
                        cjsModule = args[i4] = handlers.module(name);
                      } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                        args[i4] = callDep(depName);
                      } else if (map.p) {
                        map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i4] = defined[depName];
                      } else {
                        throw new Error(name + " missing " + depName);
                      }
                    }
                    ret = callback ? callback.apply(defined[name], args) : void 0;
                    if (name) {
                      if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                        defined[name] = cjsModule.exports;
                      } else if (ret !== undef || !usingExports) {
                        defined[name] = ret;
                      }
                    }
                  } else if (name) {
                    defined[name] = callback;
                  }
                };
                requirejs = require2 = req = function(deps, callback, relName, forceSync, alt) {
                  if (typeof deps === "string") {
                    if (handlers[deps]) {
                      return handlers[deps](callback);
                    }
                    return callDep(makeMap(deps, makeRelParts(callback)).f);
                  } else if (!deps.splice) {
                    config2 = deps;
                    if (config2.deps) {
                      req(config2.deps, config2.callback);
                    }
                    if (!callback) {
                      return;
                    }
                    if (callback.splice) {
                      deps = callback;
                      callback = relName;
                      relName = null;
                    } else {
                      deps = undef;
                    }
                  }
                  callback = callback || function() {
                  };
                  if (typeof relName === "function") {
                    relName = forceSync;
                    forceSync = alt;
                  }
                  if (forceSync) {
                    main3(undef, deps, callback, relName);
                  } else {
                    setTimeout(function() {
                      main3(undef, deps, callback, relName);
                    }, 4);
                  }
                  return req;
                };
                req.config = function(cfg) {
                  return req(cfg);
                };
                requirejs._defined = defined;
                define2 = function(name, deps, callback) {
                  if (typeof name !== "string") {
                    throw new Error("See almond README: incorrect module build, no module name");
                  }
                  if (!deps.splice) {
                    callback = deps;
                    deps = [];
                  }
                  if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                    waiting[name] = [name, deps, callback];
                  }
                };
                define2.amd = {
                  jQuery: true
                };
              })();
              S23.requirejs = requirejs;
              S23.require = require2;
              S23.define = define2;
            }
          })();
          S23.define("almond", function() {
          });
          S23.define("jquery", [], function() {
            var _$ = jQuery2 || $;
            if (_$ == null && console && console.error) {
              console.error(
                "Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."
              );
            }
            return _$;
          });
          S23.define("select2/utils", [
            "jquery"
          ], function($5) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
              var __hasProp = {}.hasOwnProperty;
              function BaseConstructor() {
                this.constructor = ChildClass;
              }
              for (var key in SuperClass) {
                if (__hasProp.call(SuperClass, key)) {
                  ChildClass[key] = SuperClass[key];
                }
              }
              BaseConstructor.prototype = SuperClass.prototype;
              ChildClass.prototype = new BaseConstructor();
              ChildClass.__super__ = SuperClass.prototype;
              return ChildClass;
            };
            function getMethods(theClass) {
              var proto = theClass.prototype;
              var methods = [];
              for (var methodName in proto) {
                var m4 = proto[methodName];
                if (typeof m4 !== "function") {
                  continue;
                }
                if (methodName === "constructor") {
                  continue;
                }
                methods.push(methodName);
              }
              return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
              var decoratedMethods = getMethods(DecoratorClass);
              var superMethods = getMethods(SuperClass);
              function DecoratedClass() {
                var unshift = Array.prototype.unshift;
                var argCount = DecoratorClass.prototype.constructor.length;
                var calledConstructor = SuperClass.prototype.constructor;
                if (argCount > 0) {
                  unshift.call(arguments, SuperClass.prototype.constructor);
                  calledConstructor = DecoratorClass.prototype.constructor;
                }
                calledConstructor.apply(this, arguments);
              }
              DecoratorClass.displayName = SuperClass.displayName;
              function ctr() {
                this.constructor = DecoratedClass;
              }
              DecoratedClass.prototype = new ctr();
              for (var m4 = 0; m4 < superMethods.length; m4++) {
                var superMethod = superMethods[m4];
                DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
              }
              var calledMethod = function(methodName) {
                var originalMethod = function() {
                };
                if (methodName in DecoratedClass.prototype) {
                  originalMethod = DecoratedClass.prototype[methodName];
                }
                var decoratedMethod2 = DecoratorClass.prototype[methodName];
                return function() {
                  var unshift = Array.prototype.unshift;
                  unshift.call(arguments, originalMethod);
                  return decoratedMethod2.apply(this, arguments);
                };
              };
              for (var d4 = 0; d4 < decoratedMethods.length; d4++) {
                var decoratedMethod = decoratedMethods[d4];
                DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
              }
              return DecoratedClass;
            };
            var Observable = function() {
              this.listeners = {};
            };
            Observable.prototype.on = function(event, callback) {
              this.listeners = this.listeners || {};
              if (event in this.listeners) {
                this.listeners[event].push(callback);
              } else {
                this.listeners[event] = [callback];
              }
            };
            Observable.prototype.trigger = function(event) {
              var slice = Array.prototype.slice;
              var params = slice.call(arguments, 1);
              this.listeners = this.listeners || {};
              if (params == null) {
                params = [];
              }
              if (params.length === 0) {
                params.push({});
              }
              params[0]._type = event;
              if (event in this.listeners) {
                this.invoke(this.listeners[event], slice.call(arguments, 1));
              }
              if ("*" in this.listeners) {
                this.invoke(this.listeners["*"], arguments);
              }
            };
            Observable.prototype.invoke = function(listeners, params) {
              for (var i4 = 0, len = listeners.length; i4 < len; i4++) {
                listeners[i4].apply(this, params);
              }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
              var chars = "";
              for (var i4 = 0; i4 < length; i4++) {
                var randomChar = Math.floor(Math.random() * 36);
                chars += randomChar.toString(36);
              }
              return chars;
            };
            Utils.bind = function(func, context) {
              return function() {
                func.apply(context, arguments);
              };
            };
            Utils._convertData = function(data) {
              for (var originalKey in data) {
                var keys = originalKey.split("-");
                var dataLevel = data;
                if (keys.length === 1) {
                  continue;
                }
                for (var k4 = 0; k4 < keys.length; k4++) {
                  var key = keys[k4];
                  key = key.substring(0, 1).toLowerCase() + key.substring(1);
                  if (!(key in dataLevel)) {
                    dataLevel[key] = {};
                  }
                  if (k4 == keys.length - 1) {
                    dataLevel[key] = data[originalKey];
                  }
                  dataLevel = dataLevel[key];
                }
                delete data[originalKey];
              }
              return data;
            };
            Utils.hasScroll = function(index, el) {
              var $el = $5(el);
              var overflowX = el.style.overflowX;
              var overflowY = el.style.overflowY;
              if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                return false;
              }
              if (overflowX === "scroll" || overflowY === "scroll") {
                return true;
              }
              return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
              var replaceMap = {
                "\\": "&#92;",
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#47;"
              };
              if (typeof markup !== "string") {
                return markup;
              }
              return String(markup).replace(/[&<>"'\/\\]/g, function(match2) {
                return replaceMap[match2];
              });
            };
            Utils.__cache = {};
            var id14 = 0;
            Utils.GetUniqueElementId = function(element) {
              var select2Id = element.getAttribute("data-select2-id");
              if (select2Id != null) {
                return select2Id;
              }
              if (element.id) {
                select2Id = "select2-data-" + element.id;
              } else {
                select2Id = "select2-data-" + (++id14).toString() + "-" + Utils.generateChars(4);
              }
              element.setAttribute("data-select2-id", select2Id);
              return select2Id;
            };
            Utils.StoreData = function(element, name, value) {
              var id15 = Utils.GetUniqueElementId(element);
              if (!Utils.__cache[id15]) {
                Utils.__cache[id15] = {};
              }
              Utils.__cache[id15][name] = value;
            };
            Utils.GetData = function(element, name) {
              var id15 = Utils.GetUniqueElementId(element);
              if (name) {
                if (Utils.__cache[id15]) {
                  if (Utils.__cache[id15][name] != null) {
                    return Utils.__cache[id15][name];
                  }
                  return $5(element).data(name);
                }
                return $5(element).data(name);
              } else {
                return Utils.__cache[id15];
              }
            };
            Utils.RemoveData = function(element) {
              var id15 = Utils.GetUniqueElementId(element);
              if (Utils.__cache[id15] != null) {
                delete Utils.__cache[id15];
              }
              element.removeAttribute("data-select2-id");
            };
            Utils.copyNonInternalCssClasses = function(dest, src) {
              var classes;
              var destinationClasses = dest.getAttribute("class").trim().split(/\s+/);
              destinationClasses = destinationClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") === 0;
              });
              var sourceClasses = src.getAttribute("class").trim().split(/\s+/);
              sourceClasses = sourceClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") !== 0;
              });
              var replacements = destinationClasses.concat(sourceClasses);
              dest.setAttribute("class", replacements.join(" "));
            };
            return Utils;
          });
          S23.define("select2/results", [
            "jquery",
            "./utils"
          ], function($5, Utils) {
            function Results($element, options, dataAdapter) {
              this.$element = $element;
              this.data = dataAdapter;
              this.options = options;
              Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
              var $results = $5(
                '<ul class="select2-results__options" role="listbox"></ul>'
              );
              if (this.options.get("multiple")) {
                $results.attr("aria-multiselectable", "true");
              }
              this.$results = $results;
              return $results;
            };
            Results.prototype.clear = function() {
              this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
              var escapeMarkup = this.options.get("escapeMarkup");
              this.clear();
              this.hideLoading();
              var $message = $5(
                '<li role="alert" aria-live="assertive" class="select2-results__option"></li>'
              );
              var message = this.options.get("translations").get(params.message);
              $message.append(
                escapeMarkup(
                  message(params.args)
                )
              );
              $message[0].className += " select2-results__message";
              this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
              this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
              this.hideLoading();
              var $options = [];
              if (data.results == null || data.results.length === 0) {
                if (this.$results.children().length === 0) {
                  this.trigger("results:message", {
                    message: "noResults"
                  });
                }
                return;
              }
              data.results = this.sort(data.results);
              for (var d4 = 0; d4 < data.results.length; d4++) {
                var item = data.results[d4];
                var $option = this.option(item);
                $options.push($option);
              }
              this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
              var $resultsContainer = $dropdown.find(".select2-results");
              $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
              var sorter = this.options.get("sorter");
              return sorter(data);
            };
            Results.prototype.highlightFirstItem = function() {
              var $options = this.$results.find(".select2-results__option--selectable");
              var $selected = $options.filter(".select2-results__option--selected");
              if ($selected.length > 0) {
                $selected.first().trigger("mouseenter");
              } else {
                $options.first().trigger("mouseenter");
              }
              this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
              var self2 = this;
              this.data.current(function(selected) {
                var selectedIds = selected.map(function(s4) {
                  return s4.id.toString();
                });
                var $options = self2.$results.find(".select2-results__option--selectable");
                $options.each(function() {
                  var $option = $5(this);
                  var item = Utils.GetData(this, "data");
                  var id14 = "" + item.id;
                  if (item.element != null && item.element.selected || item.element == null && selectedIds.indexOf(id14) > -1) {
                    this.classList.add("select2-results__option--selected");
                    $option.attr("aria-selected", "true");
                  } else {
                    this.classList.remove("select2-results__option--selected");
                    $option.attr("aria-selected", "false");
                  }
                });
              });
            };
            Results.prototype.showLoading = function(params) {
              this.hideLoading();
              var loadingMore = this.options.get("translations").get("searching");
              var loading = {
                disabled: true,
                loading: true,
                text: loadingMore(params)
              };
              var $loading = this.option(loading);
              $loading.className += " loading-results";
              this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
              this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
              var option = document.createElement("li");
              option.classList.add("select2-results__option");
              option.classList.add("select2-results__option--selectable");
              var attrs = {
                "role": "option"
              };
              var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
              if (data.element != null && matches.call(data.element, ":disabled") || data.element == null && data.disabled) {
                attrs["aria-disabled"] = "true";
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--disabled");
              }
              if (data.id == null) {
                option.classList.remove("select2-results__option--selectable");
              }
              if (data._resultId != null) {
                option.id = data._resultId;
              }
              if (data.title) {
                option.title = data.title;
              }
              if (data.children) {
                attrs.role = "group";
                attrs["aria-label"] = data.text;
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--group");
              }
              for (var attr in attrs) {
                var val = attrs[attr];
                option.setAttribute(attr, val);
              }
              if (data.children) {
                var $option = $5(option);
                var label = document.createElement("strong");
                label.className = "select2-results__group";
                this.template(data, label);
                var $children = [];
                for (var c4 = 0; c4 < data.children.length; c4++) {
                  var child = data.children[c4];
                  var $child = this.option(child);
                  $children.push($child);
                }
                var $childrenContainer = $5("<ul></ul>", {
                  "class": "select2-results__options select2-results__options--nested",
                  "role": "none"
                });
                $childrenContainer.append($children);
                $option.append(label);
                $option.append($childrenContainer);
              } else {
                this.template(data, option);
              }
              Utils.StoreData(option, "data", data);
              return option;
            };
            Results.prototype.bind = function(container, $container) {
              var self2 = this;
              var id14 = container.id + "-results";
              this.$results.attr("id", id14);
              container.on("results:all", function(params) {
                self2.clear();
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                  self2.highlightFirstItem();
                }
              });
              container.on("results:append", function(params) {
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                }
              });
              container.on("query", function(params) {
                self2.hideMessages();
                self2.showLoading(params);
              });
              container.on("select", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("unselect", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("open", function() {
                self2.$results.attr("aria-expanded", "true");
                self2.$results.attr("aria-hidden", "false");
                self2.setClasses();
                self2.ensureHighlightVisible();
              });
              container.on("close", function() {
                self2.$results.attr("aria-expanded", "false");
                self2.$results.attr("aria-hidden", "true");
                self2.$results.removeAttr("aria-activedescendant");
              });
              container.on("results:toggle", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                $highlighted.trigger("mouseup");
              });
              container.on("results:select", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                var data = Utils.GetData($highlighted[0], "data");
                if ($highlighted.hasClass("select2-results__option--selected")) {
                  self2.trigger("close", {});
                } else {
                  self2.trigger("select", {
                    data
                  });
                }
              });
              container.on("results:previous", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                if (currentIndex <= 0) {
                  return;
                }
                var nextIndex = currentIndex - 1;
                if ($highlighted.length === 0) {
                  nextIndex = 0;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top;
                var nextTop = $next.offset().top;
                var nextOffset = self2.$results.scrollTop() + (nextTop - currentOffset);
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextTop - currentOffset < 0) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:next", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                var nextIndex = currentIndex + 1;
                if (nextIndex >= $options.length) {
                  return;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top + self2.$results.outerHeight(false);
                var nextBottom = $next.offset().top + $next.outerHeight(false);
                var nextOffset = self2.$results.scrollTop() + nextBottom - currentOffset;
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextBottom > currentOffset) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:focus", function(params) {
                params.element[0].classList.add("select2-results__option--highlighted");
                params.element[0].setAttribute("aria-selected", "true");
              });
              container.on("results:message", function(params) {
                self2.displayMessage(params);
              });
              if ($5.fn.mousewheel) {
                this.$results.on("mousewheel", function(e4) {
                  var top3 = self2.$results.scrollTop();
                  var bottom3 = self2.$results.get(0).scrollHeight - top3 + e4.deltaY;
                  var isAtTop = e4.deltaY > 0 && top3 - e4.deltaY <= 0;
                  var isAtBottom = e4.deltaY < 0 && bottom3 <= self2.$results.height();
                  if (isAtTop) {
                    self2.$results.scrollTop(0);
                    e4.preventDefault();
                    e4.stopPropagation();
                  } else if (isAtBottom) {
                    self2.$results.scrollTop(
                      self2.$results.get(0).scrollHeight - self2.$results.height()
                    );
                    e4.preventDefault();
                    e4.stopPropagation();
                  }
                });
              }
              this.$results.on(
                "mouseup",
                ".select2-results__option--selectable",
                function(evt) {
                  var $this = $5(this);
                  var data = Utils.GetData(this, "data");
                  if ($this.hasClass("select2-results__option--selected")) {
                    if (self2.options.get("multiple")) {
                      self2.trigger("unselect", {
                        originalEvent: evt,
                        data
                      });
                    } else {
                      self2.trigger("close", {});
                    }
                    return;
                  }
                  self2.trigger("select", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$results.on(
                "mouseenter",
                ".select2-results__option--selectable",
                function(evt) {
                  var data = Utils.GetData(this, "data");
                  self2.getHighlightedResults().removeClass("select2-results__option--highlighted").attr("aria-selected", "false");
                  self2.trigger("results:focus", {
                    data,
                    element: $5(this)
                  });
                }
              );
            };
            Results.prototype.getHighlightedResults = function() {
              var $highlighted = this.$results.find(".select2-results__option--highlighted");
              return $highlighted;
            };
            Results.prototype.destroy = function() {
              this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
              var $highlighted = this.getHighlightedResults();
              if ($highlighted.length === 0) {
                return;
              }
              var $options = this.$results.find(".select2-results__option--selectable");
              var currentIndex = $options.index($highlighted);
              var currentOffset = this.$results.offset().top;
              var nextTop = $highlighted.offset().top;
              var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
              var offsetDelta = nextTop - currentOffset;
              nextOffset -= $highlighted.outerHeight(false) * 2;
              if (currentIndex <= 2) {
                this.$results.scrollTop(0);
              } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                this.$results.scrollTop(nextOffset);
              }
            };
            Results.prototype.template = function(result, container) {
              var template = this.options.get("templateResult");
              var escapeMarkup = this.options.get("escapeMarkup");
              var content = template(result, container);
              if (content == null) {
                container.style.display = "none";
              } else if (typeof content === "string") {
                container.innerHTML = escapeMarkup(content);
              } else {
                $5(container).append(content);
              }
            };
            return Results;
          });
          S23.define("select2/keys", [], function() {
            var KEYS = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              DELETE: 46
            };
            return KEYS;
          });
          S23.define("select2/selection/base", [
            "jquery",
            "../utils",
            "../keys"
          ], function($5, Utils, KEYS) {
            function BaseSelection($element, options) {
              this.$element = $element;
              this.options = options;
              BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
              var $selection = $5(
                '<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'
              );
              this._tabindex = 0;
              if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
              } else if (this.$element.attr("tabindex") != null) {
                this._tabindex = this.$element.attr("tabindex");
              }
              $selection.attr("title", this.$element.attr("title"));
              $selection.attr("tabindex", this._tabindex);
              $selection.attr("aria-disabled", "false");
              this.$selection = $selection;
              return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              this.container = container;
              this.$selection.on("focus", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("blur", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                if (evt.which === KEYS.SPACE) {
                  evt.preventDefault();
                }
              });
              container.on("results:focus", function(params) {
                self2.$selection.attr("aria-activedescendant", params.data._resultId);
              });
              container.on("selection:update", function(params) {
                self2.update(params.data);
              });
              container.on("open", function() {
                self2.$selection.attr("aria-expanded", "true");
                self2.$selection.attr("aria-owns", resultsId);
                self2._attachCloseHandler(container);
              });
              container.on("close", function() {
                self2.$selection.attr("aria-expanded", "false");
                self2.$selection.removeAttr("aria-activedescendant");
                self2.$selection.removeAttr("aria-owns");
                self2.$selection.trigger("focus");
                self2._detachCloseHandler(container);
              });
              container.on("enable", function() {
                self2.$selection.attr("tabindex", self2._tabindex);
                self2.$selection.attr("aria-disabled", "false");
              });
              container.on("disable", function() {
                self2.$selection.attr("tabindex", "-1");
                self2.$selection.attr("aria-disabled", "true");
              });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
              var self2 = this;
              window.setTimeout(function() {
                if (document.activeElement == self2.$selection[0] || $5.contains(self2.$selection[0], document.activeElement)) {
                  return;
                }
                self2.trigger("blur", evt);
              }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
              $5(document.body).on("mousedown.select2." + container.id, function(e4) {
                var $target = $5(e4.target);
                var $select = $target.closest(".select2");
                var $all = $5(".select2.select2-container--open");
                $all.each(function() {
                  if (this == $select[0]) {
                    return;
                  }
                  var $element = Utils.GetData(this, "element");
                  $element.select2("close");
                });
              });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
              $5(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
              var $selectionContainer = $container.find(".selection");
              $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
              this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
              throw new Error("The `update` method must be defined in child classes.");
            };
            BaseSelection.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            BaseSelection.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            return BaseSelection;
          });
          S23.define("select2/selection/single", [
            "jquery",
            "./base",
            "../utils",
            "../keys"
          ], function($5, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
              SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
              var $selection = SingleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--single");
              $selection.html(
                '<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'
              );
              return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              SingleSelection.__super__.bind.apply(this, arguments);
              var id14 = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id14).attr("role", "textbox").attr("aria-readonly", "true");
              this.$selection.attr("aria-labelledby", id14);
              this.$selection.attr("aria-controls", id14);
              this.$selection.on("mousedown", function(evt) {
                if (evt.which !== 1) {
                  return;
                }
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on("focus", function(evt) {
              });
              this.$selection.on("blur", function(evt) {
              });
              container.on("focus", function(evt) {
                if (!container.isOpen()) {
                  self2.$selection.trigger("focus");
                }
              });
            };
            SingleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
              return $5("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
              if (data.length === 0) {
                this.clear();
                return;
              }
              var selection = data[0];
              var $rendered = this.$selection.find(".select2-selection__rendered");
              var formatted = this.display(selection, $rendered);
              $rendered.empty().append(formatted);
              var title = selection.title || selection.text;
              if (title) {
                $rendered.attr("title", title);
              } else {
                $rendered.removeAttr("title");
              }
            };
            return SingleSelection;
          });
          S23.define("select2/selection/multiple", [
            "jquery",
            "./base",
            "../utils"
          ], function($5, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
              MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
              var $selection = MultipleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--multiple");
              $selection.html(
                '<ul class="select2-selection__rendered"></ul>'
              );
              return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              MultipleSelection.__super__.bind.apply(this, arguments);
              var id14 = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id14);
              this.$selection.on("click", function(evt) {
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on(
                "click",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  var $remove = $5(this);
                  var $selection = $remove.parent();
                  var data = Utils.GetData($selection[0], "data");
                  self2.trigger("unselect", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$selection.on(
                "keydown",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  evt.stopPropagation();
                }
              );
            };
            MultipleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
              var $container = $5(
                '<li class="select2-selection__choice"><button type="button" class="select2-selection__choice__remove" tabindex="-1"><span aria-hidden="true">&times;</span></button><span class="select2-selection__choice__display"></span></li>'
              );
              return $container;
            };
            MultipleSelection.prototype.update = function(data) {
              this.clear();
              if (data.length === 0) {
                return;
              }
              var $selections = [];
              var selectionIdPrefix = this.$selection.find(".select2-selection__rendered").attr("id") + "-choice-";
              for (var d4 = 0; d4 < data.length; d4++) {
                var selection = data[d4];
                var $selection = this.selectionContainer();
                var formatted = this.display(selection, $selection);
                var selectionId = selectionIdPrefix + Utils.generateChars(4) + "-";
                if (selection.id) {
                  selectionId += selection.id;
                } else {
                  selectionId += Utils.generateChars(4);
                }
                $selection.find(".select2-selection__choice__display").append(formatted).attr("id", selectionId);
                var title = selection.title || selection.text;
                if (title) {
                  $selection.attr("title", title);
                }
                var removeItem2 = this.options.get("translations").get("removeItem");
                var $remove = $selection.find(".select2-selection__choice__remove");
                $remove.attr("title", removeItem2());
                $remove.attr("aria-label", removeItem2());
                $remove.attr("aria-describedby", selectionId);
                Utils.StoreData($selection[0], "data", selection);
                $selections.push($selection);
              }
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.append($selections);
            };
            return MultipleSelection;
          });
          S23.define("select2/selection/placeholder", [], function() {
            function Placeholder(decorated, $element, options) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_4, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
              var $placeholder = this.selectionContainer();
              $placeholder.html(this.display(placeholder));
              $placeholder[0].classList.add("select2-selection__placeholder");
              $placeholder[0].classList.remove("select2-selection__choice");
              var placeholderTitle = placeholder.title || placeholder.text || $placeholder.text();
              this.$selection.find(".select2-selection__rendered").attr(
                "title",
                placeholderTitle
              );
              return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
              var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
              var multipleSelections = data.length > 1;
              if (multipleSelections || singlePlaceholder) {
                return decorated.call(this, data);
              }
              this.clear();
              var $placeholder = this.createPlaceholder(this.placeholder);
              this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
          });
          S23.define("select2/selection/allowClear", [
            "jquery",
            "../keys",
            "../utils"
          ], function($5, KEYS, Utils) {
            function AllowClear() {
            }
            AllowClear.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              if (this.placeholder == null) {
                if (this.options.get("debug") && window.console && console.error) {
                  console.error(
                    "Select2: The `allowClear` option should be used in combination with the `placeholder` option."
                  );
                }
              }
              this.$selection.on(
                "mousedown",
                ".select2-selection__clear",
                function(evt) {
                  self2._handleClear(evt);
                }
              );
              container.on("keypress", function(evt) {
                self2._handleKeyboardClear(evt, container);
              });
            };
            AllowClear.prototype._handleClear = function(_4, evt) {
              if (this.isDisabled()) {
                return;
              }
              var $clear = this.$selection.find(".select2-selection__clear");
              if ($clear.length === 0) {
                return;
              }
              evt.stopPropagation();
              var data = Utils.GetData($clear[0], "data");
              var previousVal = this.$element.val();
              this.$element.val(this.placeholder.id);
              var unselectData = {
                data
              };
              this.trigger("clear", unselectData);
              if (unselectData.prevented) {
                this.$element.val(previousVal);
                return;
              }
              for (var d4 = 0; d4 < data.length; d4++) {
                unselectData = {
                  data: data[d4]
                };
                this.trigger("unselect", unselectData);
                if (unselectData.prevented) {
                  this.$element.val(previousVal);
                  return;
                }
              }
              this.$element.trigger("input").trigger("change");
              this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_4, evt, container) {
              if (container.isOpen()) {
                return;
              }
              if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                this._handleClear(evt);
              }
            };
            AllowClear.prototype.update = function(decorated, data) {
              decorated.call(this, data);
              this.$selection.find(".select2-selection__clear").remove();
              this.$selection[0].classList.remove("select2-selection--clearable");
              if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                return;
              }
              var selectionId = this.$selection.find(".select2-selection__rendered").attr("id");
              var removeAll = this.options.get("translations").get("removeAllItems");
              var $remove = $5(
                '<button type="button" class="select2-selection__clear" tabindex="-1"><span aria-hidden="true">&times;</span></button>'
              );
              $remove.attr("title", removeAll());
              $remove.attr("aria-label", removeAll());
              $remove.attr("aria-describedby", selectionId);
              Utils.StoreData($remove[0], "data", data);
              this.$selection.prepend($remove);
              this.$selection[0].classList.add("select2-selection--clearable");
            };
            return AllowClear;
          });
          S23.define("select2/selection/search", [
            "jquery",
            "../utils",
            "../keys"
          ], function($5, Utils, KEYS) {
            function Search(decorated, $element, options) {
              decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
              var searchLabel = this.options.get("translations").get("search");
              var $search = $5(
                '<span class="select2-search select2-search--inline"><textarea class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" ></textarea></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("textarea");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              var $rendered = decorated.call(this);
              this._transferTabIndex();
              $rendered.append(this.$searchContainer);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              var selectionId = container.id + "-container";
              decorated.call(this, container, $container);
              self2.$search.attr("aria-describedby", selectionId);
              container.on("open", function() {
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
              });
              container.on("close", function() {
                self2.$search.val("");
                self2.resizeSearch();
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.trigger("focus");
              });
              container.on("enable", function() {
                self2.$search.prop("disabled", false);
                self2._transferTabIndex();
              });
              container.on("disable", function() {
                self2.$search.prop("disabled", true);
              });
              container.on("focus", function(evt) {
                self2.$search.trigger("focus");
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
              this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                evt.stopPropagation();
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
                var key = evt.which;
                if (key === KEYS.BACKSPACE && self2.$search.val() === "") {
                  var $previousChoice = self2.$selection.find(".select2-selection__choice").last();
                  if ($previousChoice.length > 0) {
                    var item = Utils.GetData($previousChoice[0], "data");
                    self2.searchRemoveChoice(item);
                    evt.preventDefault();
                  }
                }
              });
              this.$selection.on("click", ".select2-search--inline", function(evt) {
                if (self2.$search.val()) {
                  evt.stopPropagation();
                }
              });
              var msie = document.documentMode;
              var disableInputEvents = msie && msie <= 11;
              this.$selection.on(
                "input.searchcheck",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents) {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  self2.$selection.off("keyup.search");
                }
              );
              this.$selection.on(
                "keyup.search input.search",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents && evt.type === "input") {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  var key = evt.which;
                  if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                    return;
                  }
                  if (key == KEYS.TAB) {
                    return;
                  }
                  self2.handleSearch(evt);
                }
              );
            };
            Search.prototype._transferTabIndex = function(decorated) {
              this.$search.attr("tabindex", this.$selection.attr("tabindex"));
              this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
              this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
              var searchHadFocus = this.$search[0] == document.activeElement;
              this.$search.attr("placeholder", "");
              decorated.call(this, data);
              this.resizeSearch();
              if (searchHadFocus) {
                this.$search.trigger("focus");
              }
            };
            Search.prototype.handleSearch = function() {
              this.resizeSearch();
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
              this.trigger("unselect", {
                data: item
              });
              this.$search.val(item.text);
              this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
              this.$search.css("width", "25px");
              var width = "100%";
              if (this.$search.attr("placeholder") === "") {
                var minimumWidth = this.$search.val().length + 1;
                width = minimumWidth * 0.75 + "em";
              }
              this.$search.css("width", width);
            };
            return Search;
          });
          S23.define("select2/selection/selectionCss", [
            "../utils"
          ], function(Utils) {
            function SelectionCSS() {
            }
            SelectionCSS.prototype.render = function(decorated) {
              var $selection = decorated.call(this);
              var selectionCssClass = this.options.get("selectionCssClass") || "";
              if (selectionCssClass.indexOf(":all:") !== -1) {
                selectionCssClass = selectionCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
              }
              $selection.addClass(selectionCssClass);
              return $selection;
            };
            return SelectionCSS;
          });
          S23.define("select2/selection/eventRelay", [
            "jquery"
          ], function($5) {
            function EventRelay() {
            }
            EventRelay.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var relayEvents = [
                "open",
                "opening",
                "close",
                "closing",
                "select",
                "selecting",
                "unselect",
                "unselecting",
                "clear",
                "clearing"
              ];
              var preventableEvents = [
                "opening",
                "closing",
                "selecting",
                "unselecting",
                "clearing"
              ];
              decorated.call(this, container, $container);
              container.on("*", function(name, params) {
                if (relayEvents.indexOf(name) === -1) {
                  return;
                }
                params = params || {};
                var evt = $5.Event("select2:" + name, {
                  params
                });
                self2.$element.trigger(evt);
                if (preventableEvents.indexOf(name) === -1) {
                  return;
                }
                params.prevented = evt.isDefaultPrevented();
              });
            };
            return EventRelay;
          });
          S23.define("select2/translation", [
            "jquery",
            "require"
          ], function($5, require2) {
            function Translation(dict) {
              this.dict = dict || {};
            }
            Translation.prototype.all = function() {
              return this.dict;
            };
            Translation.prototype.get = function(key) {
              return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
              this.dict = $5.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
              if (!(path in Translation._cache)) {
                var translations = require2(path);
                Translation._cache[path] = translations;
              }
              return new Translation(Translation._cache[path]);
            };
            return Translation;
          });
          S23.define("select2/diacritics", [], function() {
            var diacritics = {
              "\u24B6": "A",
              "\uFF21": "A",
              "\xC0": "A",
              "\xC1": "A",
              "\xC2": "A",
              "\u1EA6": "A",
              "\u1EA4": "A",
              "\u1EAA": "A",
              "\u1EA8": "A",
              "\xC3": "A",
              "\u0100": "A",
              "\u0102": "A",
              "\u1EB0": "A",
              "\u1EAE": "A",
              "\u1EB4": "A",
              "\u1EB2": "A",
              "\u0226": "A",
              "\u01E0": "A",
              "\xC4": "A",
              "\u01DE": "A",
              "\u1EA2": "A",
              "\xC5": "A",
              "\u01FA": "A",
              "\u01CD": "A",
              "\u0200": "A",
              "\u0202": "A",
              "\u1EA0": "A",
              "\u1EAC": "A",
              "\u1EB6": "A",
              "\u1E00": "A",
              "\u0104": "A",
              "\u023A": "A",
              "\u2C6F": "A",
              "\uA732": "AA",
              "\xC6": "AE",
              "\u01FC": "AE",
              "\u01E2": "AE",
              "\uA734": "AO",
              "\uA736": "AU",
              "\uA738": "AV",
              "\uA73A": "AV",
              "\uA73C": "AY",
              "\u24B7": "B",
              "\uFF22": "B",
              "\u1E02": "B",
              "\u1E04": "B",
              "\u1E06": "B",
              "\u0243": "B",
              "\u0182": "B",
              "\u0181": "B",
              "\u24B8": "C",
              "\uFF23": "C",
              "\u0106": "C",
              "\u0108": "C",
              "\u010A": "C",
              "\u010C": "C",
              "\xC7": "C",
              "\u1E08": "C",
              "\u0187": "C",
              "\u023B": "C",
              "\uA73E": "C",
              "\u24B9": "D",
              "\uFF24": "D",
              "\u1E0A": "D",
              "\u010E": "D",
              "\u1E0C": "D",
              "\u1E10": "D",
              "\u1E12": "D",
              "\u1E0E": "D",
              "\u0110": "D",
              "\u018B": "D",
              "\u018A": "D",
              "\u0189": "D",
              "\uA779": "D",
              "\u01F1": "DZ",
              "\u01C4": "DZ",
              "\u01F2": "Dz",
              "\u01C5": "Dz",
              "\u24BA": "E",
              "\uFF25": "E",
              "\xC8": "E",
              "\xC9": "E",
              "\xCA": "E",
              "\u1EC0": "E",
              "\u1EBE": "E",
              "\u1EC4": "E",
              "\u1EC2": "E",
              "\u1EBC": "E",
              "\u0112": "E",
              "\u1E14": "E",
              "\u1E16": "E",
              "\u0114": "E",
              "\u0116": "E",
              "\xCB": "E",
              "\u1EBA": "E",
              "\u011A": "E",
              "\u0204": "E",
              "\u0206": "E",
              "\u1EB8": "E",
              "\u1EC6": "E",
              "\u0228": "E",
              "\u1E1C": "E",
              "\u0118": "E",
              "\u1E18": "E",
              "\u1E1A": "E",
              "\u0190": "E",
              "\u018E": "E",
              "\u24BB": "F",
              "\uFF26": "F",
              "\u1E1E": "F",
              "\u0191": "F",
              "\uA77B": "F",
              "\u24BC": "G",
              "\uFF27": "G",
              "\u01F4": "G",
              "\u011C": "G",
              "\u1E20": "G",
              "\u011E": "G",
              "\u0120": "G",
              "\u01E6": "G",
              "\u0122": "G",
              "\u01E4": "G",
              "\u0193": "G",
              "\uA7A0": "G",
              "\uA77D": "G",
              "\uA77E": "G",
              "\u24BD": "H",
              "\uFF28": "H",
              "\u0124": "H",
              "\u1E22": "H",
              "\u1E26": "H",
              "\u021E": "H",
              "\u1E24": "H",
              "\u1E28": "H",
              "\u1E2A": "H",
              "\u0126": "H",
              "\u2C67": "H",
              "\u2C75": "H",
              "\uA78D": "H",
              "\u24BE": "I",
              "\uFF29": "I",
              "\xCC": "I",
              "\xCD": "I",
              "\xCE": "I",
              "\u0128": "I",
              "\u012A": "I",
              "\u012C": "I",
              "\u0130": "I",
              "\xCF": "I",
              "\u1E2E": "I",
              "\u1EC8": "I",
              "\u01CF": "I",
              "\u0208": "I",
              "\u020A": "I",
              "\u1ECA": "I",
              "\u012E": "I",
              "\u1E2C": "I",
              "\u0197": "I",
              "\u24BF": "J",
              "\uFF2A": "J",
              "\u0134": "J",
              "\u0248": "J",
              "\u24C0": "K",
              "\uFF2B": "K",
              "\u1E30": "K",
              "\u01E8": "K",
              "\u1E32": "K",
              "\u0136": "K",
              "\u1E34": "K",
              "\u0198": "K",
              "\u2C69": "K",
              "\uA740": "K",
              "\uA742": "K",
              "\uA744": "K",
              "\uA7A2": "K",
              "\u24C1": "L",
              "\uFF2C": "L",
              "\u013F": "L",
              "\u0139": "L",
              "\u013D": "L",
              "\u1E36": "L",
              "\u1E38": "L",
              "\u013B": "L",
              "\u1E3C": "L",
              "\u1E3A": "L",
              "\u0141": "L",
              "\u023D": "L",
              "\u2C62": "L",
              "\u2C60": "L",
              "\uA748": "L",
              "\uA746": "L",
              "\uA780": "L",
              "\u01C7": "LJ",
              "\u01C8": "Lj",
              "\u24C2": "M",
              "\uFF2D": "M",
              "\u1E3E": "M",
              "\u1E40": "M",
              "\u1E42": "M",
              "\u2C6E": "M",
              "\u019C": "M",
              "\u24C3": "N",
              "\uFF2E": "N",
              "\u01F8": "N",
              "\u0143": "N",
              "\xD1": "N",
              "\u1E44": "N",
              "\u0147": "N",
              "\u1E46": "N",
              "\u0145": "N",
              "\u1E4A": "N",
              "\u1E48": "N",
              "\u0220": "N",
              "\u019D": "N",
              "\uA790": "N",
              "\uA7A4": "N",
              "\u01CA": "NJ",
              "\u01CB": "Nj",
              "\u24C4": "O",
              "\uFF2F": "O",
              "\xD2": "O",
              "\xD3": "O",
              "\xD4": "O",
              "\u1ED2": "O",
              "\u1ED0": "O",
              "\u1ED6": "O",
              "\u1ED4": "O",
              "\xD5": "O",
              "\u1E4C": "O",
              "\u022C": "O",
              "\u1E4E": "O",
              "\u014C": "O",
              "\u1E50": "O",
              "\u1E52": "O",
              "\u014E": "O",
              "\u022E": "O",
              "\u0230": "O",
              "\xD6": "O",
              "\u022A": "O",
              "\u1ECE": "O",
              "\u0150": "O",
              "\u01D1": "O",
              "\u020C": "O",
              "\u020E": "O",
              "\u01A0": "O",
              "\u1EDC": "O",
              "\u1EDA": "O",
              "\u1EE0": "O",
              "\u1EDE": "O",
              "\u1EE2": "O",
              "\u1ECC": "O",
              "\u1ED8": "O",
              "\u01EA": "O",
              "\u01EC": "O",
              "\xD8": "O",
              "\u01FE": "O",
              "\u0186": "O",
              "\u019F": "O",
              "\uA74A": "O",
              "\uA74C": "O",
              "\u0152": "OE",
              "\u01A2": "OI",
              "\uA74E": "OO",
              "\u0222": "OU",
              "\u24C5": "P",
              "\uFF30": "P",
              "\u1E54": "P",
              "\u1E56": "P",
              "\u01A4": "P",
              "\u2C63": "P",
              "\uA750": "P",
              "\uA752": "P",
              "\uA754": "P",
              "\u24C6": "Q",
              "\uFF31": "Q",
              "\uA756": "Q",
              "\uA758": "Q",
              "\u024A": "Q",
              "\u24C7": "R",
              "\uFF32": "R",
              "\u0154": "R",
              "\u1E58": "R",
              "\u0158": "R",
              "\u0210": "R",
              "\u0212": "R",
              "\u1E5A": "R",
              "\u1E5C": "R",
              "\u0156": "R",
              "\u1E5E": "R",
              "\u024C": "R",
              "\u2C64": "R",
              "\uA75A": "R",
              "\uA7A6": "R",
              "\uA782": "R",
              "\u24C8": "S",
              "\uFF33": "S",
              "\u1E9E": "S",
              "\u015A": "S",
              "\u1E64": "S",
              "\u015C": "S",
              "\u1E60": "S",
              "\u0160": "S",
              "\u1E66": "S",
              "\u1E62": "S",
              "\u1E68": "S",
              "\u0218": "S",
              "\u015E": "S",
              "\u2C7E": "S",
              "\uA7A8": "S",
              "\uA784": "S",
              "\u24C9": "T",
              "\uFF34": "T",
              "\u1E6A": "T",
              "\u0164": "T",
              "\u1E6C": "T",
              "\u021A": "T",
              "\u0162": "T",
              "\u1E70": "T",
              "\u1E6E": "T",
              "\u0166": "T",
              "\u01AC": "T",
              "\u01AE": "T",
              "\u023E": "T",
              "\uA786": "T",
              "\uA728": "TZ",
              "\u24CA": "U",
              "\uFF35": "U",
              "\xD9": "U",
              "\xDA": "U",
              "\xDB": "U",
              "\u0168": "U",
              "\u1E78": "U",
              "\u016A": "U",
              "\u1E7A": "U",
              "\u016C": "U",
              "\xDC": "U",
              "\u01DB": "U",
              "\u01D7": "U",
              "\u01D5": "U",
              "\u01D9": "U",
              "\u1EE6": "U",
              "\u016E": "U",
              "\u0170": "U",
              "\u01D3": "U",
              "\u0214": "U",
              "\u0216": "U",
              "\u01AF": "U",
              "\u1EEA": "U",
              "\u1EE8": "U",
              "\u1EEE": "U",
              "\u1EEC": "U",
              "\u1EF0": "U",
              "\u1EE4": "U",
              "\u1E72": "U",
              "\u0172": "U",
              "\u1E76": "U",
              "\u1E74": "U",
              "\u0244": "U",
              "\u24CB": "V",
              "\uFF36": "V",
              "\u1E7C": "V",
              "\u1E7E": "V",
              "\u01B2": "V",
              "\uA75E": "V",
              "\u0245": "V",
              "\uA760": "VY",
              "\u24CC": "W",
              "\uFF37": "W",
              "\u1E80": "W",
              "\u1E82": "W",
              "\u0174": "W",
              "\u1E86": "W",
              "\u1E84": "W",
              "\u1E88": "W",
              "\u2C72": "W",
              "\u24CD": "X",
              "\uFF38": "X",
              "\u1E8A": "X",
              "\u1E8C": "X",
              "\u24CE": "Y",
              "\uFF39": "Y",
              "\u1EF2": "Y",
              "\xDD": "Y",
              "\u0176": "Y",
              "\u1EF8": "Y",
              "\u0232": "Y",
              "\u1E8E": "Y",
              "\u0178": "Y",
              "\u1EF6": "Y",
              "\u1EF4": "Y",
              "\u01B3": "Y",
              "\u024E": "Y",
              "\u1EFE": "Y",
              "\u24CF": "Z",
              "\uFF3A": "Z",
              "\u0179": "Z",
              "\u1E90": "Z",
              "\u017B": "Z",
              "\u017D": "Z",
              "\u1E92": "Z",
              "\u1E94": "Z",
              "\u01B5": "Z",
              "\u0224": "Z",
              "\u2C7F": "Z",
              "\u2C6B": "Z",
              "\uA762": "Z",
              "\u24D0": "a",
              "\uFF41": "a",
              "\u1E9A": "a",
              "\xE0": "a",
              "\xE1": "a",
              "\xE2": "a",
              "\u1EA7": "a",
              "\u1EA5": "a",
              "\u1EAB": "a",
              "\u1EA9": "a",
              "\xE3": "a",
              "\u0101": "a",
              "\u0103": "a",
              "\u1EB1": "a",
              "\u1EAF": "a",
              "\u1EB5": "a",
              "\u1EB3": "a",
              "\u0227": "a",
              "\u01E1": "a",
              "\xE4": "a",
              "\u01DF": "a",
              "\u1EA3": "a",
              "\xE5": "a",
              "\u01FB": "a",
              "\u01CE": "a",
              "\u0201": "a",
              "\u0203": "a",
              "\u1EA1": "a",
              "\u1EAD": "a",
              "\u1EB7": "a",
              "\u1E01": "a",
              "\u0105": "a",
              "\u2C65": "a",
              "\u0250": "a",
              "\uA733": "aa",
              "\xE6": "ae",
              "\u01FD": "ae",
              "\u01E3": "ae",
              "\uA735": "ao",
              "\uA737": "au",
              "\uA739": "av",
              "\uA73B": "av",
              "\uA73D": "ay",
              "\u24D1": "b",
              "\uFF42": "b",
              "\u1E03": "b",
              "\u1E05": "b",
              "\u1E07": "b",
              "\u0180": "b",
              "\u0183": "b",
              "\u0253": "b",
              "\u24D2": "c",
              "\uFF43": "c",
              "\u0107": "c",
              "\u0109": "c",
              "\u010B": "c",
              "\u010D": "c",
              "\xE7": "c",
              "\u1E09": "c",
              "\u0188": "c",
              "\u023C": "c",
              "\uA73F": "c",
              "\u2184": "c",
              "\u24D3": "d",
              "\uFF44": "d",
              "\u1E0B": "d",
              "\u010F": "d",
              "\u1E0D": "d",
              "\u1E11": "d",
              "\u1E13": "d",
              "\u1E0F": "d",
              "\u0111": "d",
              "\u018C": "d",
              "\u0256": "d",
              "\u0257": "d",
              "\uA77A": "d",
              "\u01F3": "dz",
              "\u01C6": "dz",
              "\u24D4": "e",
              "\uFF45": "e",
              "\xE8": "e",
              "\xE9": "e",
              "\xEA": "e",
              "\u1EC1": "e",
              "\u1EBF": "e",
              "\u1EC5": "e",
              "\u1EC3": "e",
              "\u1EBD": "e",
              "\u0113": "e",
              "\u1E15": "e",
              "\u1E17": "e",
              "\u0115": "e",
              "\u0117": "e",
              "\xEB": "e",
              "\u1EBB": "e",
              "\u011B": "e",
              "\u0205": "e",
              "\u0207": "e",
              "\u1EB9": "e",
              "\u1EC7": "e",
              "\u0229": "e",
              "\u1E1D": "e",
              "\u0119": "e",
              "\u1E19": "e",
              "\u1E1B": "e",
              "\u0247": "e",
              "\u025B": "e",
              "\u01DD": "e",
              "\u24D5": "f",
              "\uFF46": "f",
              "\u1E1F": "f",
              "\u0192": "f",
              "\uA77C": "f",
              "\u24D6": "g",
              "\uFF47": "g",
              "\u01F5": "g",
              "\u011D": "g",
              "\u1E21": "g",
              "\u011F": "g",
              "\u0121": "g",
              "\u01E7": "g",
              "\u0123": "g",
              "\u01E5": "g",
              "\u0260": "g",
              "\uA7A1": "g",
              "\u1D79": "g",
              "\uA77F": "g",
              "\u24D7": "h",
              "\uFF48": "h",
              "\u0125": "h",
              "\u1E23": "h",
              "\u1E27": "h",
              "\u021F": "h",
              "\u1E25": "h",
              "\u1E29": "h",
              "\u1E2B": "h",
              "\u1E96": "h",
              "\u0127": "h",
              "\u2C68": "h",
              "\u2C76": "h",
              "\u0265": "h",
              "\u0195": "hv",
              "\u24D8": "i",
              "\uFF49": "i",
              "\xEC": "i",
              "\xED": "i",
              "\xEE": "i",
              "\u0129": "i",
              "\u012B": "i",
              "\u012D": "i",
              "\xEF": "i",
              "\u1E2F": "i",
              "\u1EC9": "i",
              "\u01D0": "i",
              "\u0209": "i",
              "\u020B": "i",
              "\u1ECB": "i",
              "\u012F": "i",
              "\u1E2D": "i",
              "\u0268": "i",
              "\u0131": "i",
              "\u24D9": "j",
              "\uFF4A": "j",
              "\u0135": "j",
              "\u01F0": "j",
              "\u0249": "j",
              "\u24DA": "k",
              "\uFF4B": "k",
              "\u1E31": "k",
              "\u01E9": "k",
              "\u1E33": "k",
              "\u0137": "k",
              "\u1E35": "k",
              "\u0199": "k",
              "\u2C6A": "k",
              "\uA741": "k",
              "\uA743": "k",
              "\uA745": "k",
              "\uA7A3": "k",
              "\u24DB": "l",
              "\uFF4C": "l",
              "\u0140": "l",
              "\u013A": "l",
              "\u013E": "l",
              "\u1E37": "l",
              "\u1E39": "l",
              "\u013C": "l",
              "\u1E3D": "l",
              "\u1E3B": "l",
              "\u017F": "l",
              "\u0142": "l",
              "\u019A": "l",
              "\u026B": "l",
              "\u2C61": "l",
              "\uA749": "l",
              "\uA781": "l",
              "\uA747": "l",
              "\u01C9": "lj",
              "\u24DC": "m",
              "\uFF4D": "m",
              "\u1E3F": "m",
              "\u1E41": "m",
              "\u1E43": "m",
              "\u0271": "m",
              "\u026F": "m",
              "\u24DD": "n",
              "\uFF4E": "n",
              "\u01F9": "n",
              "\u0144": "n",
              "\xF1": "n",
              "\u1E45": "n",
              "\u0148": "n",
              "\u1E47": "n",
              "\u0146": "n",
              "\u1E4B": "n",
              "\u1E49": "n",
              "\u019E": "n",
              "\u0272": "n",
              "\u0149": "n",
              "\uA791": "n",
              "\uA7A5": "n",
              "\u01CC": "nj",
              "\u24DE": "o",
              "\uFF4F": "o",
              "\xF2": "o",
              "\xF3": "o",
              "\xF4": "o",
              "\u1ED3": "o",
              "\u1ED1": "o",
              "\u1ED7": "o",
              "\u1ED5": "o",
              "\xF5": "o",
              "\u1E4D": "o",
              "\u022D": "o",
              "\u1E4F": "o",
              "\u014D": "o",
              "\u1E51": "o",
              "\u1E53": "o",
              "\u014F": "o",
              "\u022F": "o",
              "\u0231": "o",
              "\xF6": "o",
              "\u022B": "o",
              "\u1ECF": "o",
              "\u0151": "o",
              "\u01D2": "o",
              "\u020D": "o",
              "\u020F": "o",
              "\u01A1": "o",
              "\u1EDD": "o",
              "\u1EDB": "o",
              "\u1EE1": "o",
              "\u1EDF": "o",
              "\u1EE3": "o",
              "\u1ECD": "o",
              "\u1ED9": "o",
              "\u01EB": "o",
              "\u01ED": "o",
              "\xF8": "o",
              "\u01FF": "o",
              "\u0254": "o",
              "\uA74B": "o",
              "\uA74D": "o",
              "\u0275": "o",
              "\u0153": "oe",
              "\u01A3": "oi",
              "\u0223": "ou",
              "\uA74F": "oo",
              "\u24DF": "p",
              "\uFF50": "p",
              "\u1E55": "p",
              "\u1E57": "p",
              "\u01A5": "p",
              "\u1D7D": "p",
              "\uA751": "p",
              "\uA753": "p",
              "\uA755": "p",
              "\u24E0": "q",
              "\uFF51": "q",
              "\u024B": "q",
              "\uA757": "q",
              "\uA759": "q",
              "\u24E1": "r",
              "\uFF52": "r",
              "\u0155": "r",
              "\u1E59": "r",
              "\u0159": "r",
              "\u0211": "r",
              "\u0213": "r",
              "\u1E5B": "r",
              "\u1E5D": "r",
              "\u0157": "r",
              "\u1E5F": "r",
              "\u024D": "r",
              "\u027D": "r",
              "\uA75B": "r",
              "\uA7A7": "r",
              "\uA783": "r",
              "\u24E2": "s",
              "\uFF53": "s",
              "\xDF": "s",
              "\u015B": "s",
              "\u1E65": "s",
              "\u015D": "s",
              "\u1E61": "s",
              "\u0161": "s",
              "\u1E67": "s",
              "\u1E63": "s",
              "\u1E69": "s",
              "\u0219": "s",
              "\u015F": "s",
              "\u023F": "s",
              "\uA7A9": "s",
              "\uA785": "s",
              "\u1E9B": "s",
              "\u24E3": "t",
              "\uFF54": "t",
              "\u1E6B": "t",
              "\u1E97": "t",
              "\u0165": "t",
              "\u1E6D": "t",
              "\u021B": "t",
              "\u0163": "t",
              "\u1E71": "t",
              "\u1E6F": "t",
              "\u0167": "t",
              "\u01AD": "t",
              "\u0288": "t",
              "\u2C66": "t",
              "\uA787": "t",
              "\uA729": "tz",
              "\u24E4": "u",
              "\uFF55": "u",
              "\xF9": "u",
              "\xFA": "u",
              "\xFB": "u",
              "\u0169": "u",
              "\u1E79": "u",
              "\u016B": "u",
              "\u1E7B": "u",
              "\u016D": "u",
              "\xFC": "u",
              "\u01DC": "u",
              "\u01D8": "u",
              "\u01D6": "u",
              "\u01DA": "u",
              "\u1EE7": "u",
              "\u016F": "u",
              "\u0171": "u",
              "\u01D4": "u",
              "\u0215": "u",
              "\u0217": "u",
              "\u01B0": "u",
              "\u1EEB": "u",
              "\u1EE9": "u",
              "\u1EEF": "u",
              "\u1EED": "u",
              "\u1EF1": "u",
              "\u1EE5": "u",
              "\u1E73": "u",
              "\u0173": "u",
              "\u1E77": "u",
              "\u1E75": "u",
              "\u0289": "u",
              "\u24E5": "v",
              "\uFF56": "v",
              "\u1E7D": "v",
              "\u1E7F": "v",
              "\u028B": "v",
              "\uA75F": "v",
              "\u028C": "v",
              "\uA761": "vy",
              "\u24E6": "w",
              "\uFF57": "w",
              "\u1E81": "w",
              "\u1E83": "w",
              "\u0175": "w",
              "\u1E87": "w",
              "\u1E85": "w",
              "\u1E98": "w",
              "\u1E89": "w",
              "\u2C73": "w",
              "\u24E7": "x",
              "\uFF58": "x",
              "\u1E8B": "x",
              "\u1E8D": "x",
              "\u24E8": "y",
              "\uFF59": "y",
              "\u1EF3": "y",
              "\xFD": "y",
              "\u0177": "y",
              "\u1EF9": "y",
              "\u0233": "y",
              "\u1E8F": "y",
              "\xFF": "y",
              "\u1EF7": "y",
              "\u1E99": "y",
              "\u1EF5": "y",
              "\u01B4": "y",
              "\u024F": "y",
              "\u1EFF": "y",
              "\u24E9": "z",
              "\uFF5A": "z",
              "\u017A": "z",
              "\u1E91": "z",
              "\u017C": "z",
              "\u017E": "z",
              "\u1E93": "z",
              "\u1E95": "z",
              "\u01B6": "z",
              "\u0225": "z",
              "\u0240": "z",
              "\u2C6C": "z",
              "\uA763": "z",
              "\u0386": "\u0391",
              "\u0388": "\u0395",
              "\u0389": "\u0397",
              "\u038A": "\u0399",
              "\u03AA": "\u0399",
              "\u038C": "\u039F",
              "\u038E": "\u03A5",
              "\u03AB": "\u03A5",
              "\u038F": "\u03A9",
              "\u03AC": "\u03B1",
              "\u03AD": "\u03B5",
              "\u03AE": "\u03B7",
              "\u03AF": "\u03B9",
              "\u03CA": "\u03B9",
              "\u0390": "\u03B9",
              "\u03CC": "\u03BF",
              "\u03CD": "\u03C5",
              "\u03CB": "\u03C5",
              "\u03B0": "\u03C5",
              "\u03CE": "\u03C9",
              "\u03C2": "\u03C3",
              "\u2019": "'"
            };
            return diacritics;
          });
          S23.define("select2/data/base", [
            "../utils"
          ], function(Utils) {
            function BaseAdapter($element, options) {
              BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback) {
              throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback) {
              throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {
            };
            BaseAdapter.prototype.destroy = function() {
            };
            BaseAdapter.prototype.generateResultId = function(container, data) {
              var id14 = container.id + "-result-";
              id14 += Utils.generateChars(4);
              if (data.id != null) {
                id14 += "-" + data.id.toString();
              } else {
                id14 += "-" + Utils.generateChars(4);
              }
              return id14;
            };
            return BaseAdapter;
          });
          S23.define("select2/data/select", [
            "./base",
            "../utils",
            "jquery"
          ], function(BaseAdapter, Utils, $5) {
            function SelectAdapter($element, options) {
              this.$element = $element;
              this.options = options;
              SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback) {
              var self2 = this;
              var data = Array.prototype.map.call(
                this.$element[0].querySelectorAll(":checked"),
                function(selectedElement) {
                  return self2.item($5(selectedElement));
                }
              );
              callback(data);
            };
            SelectAdapter.prototype.select = function(data) {
              var self2 = this;
              data.selected = true;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = true;
                this.$element.trigger("input").trigger("change");
                return;
              }
              if (this.$element.prop("multiple")) {
                this.current(function(currentData) {
                  var val2 = [];
                  data = [data];
                  data.push.apply(data, currentData);
                  for (var d4 = 0; d4 < data.length; d4++) {
                    var id14 = data[d4].id;
                    if (val2.indexOf(id14) === -1) {
                      val2.push(id14);
                    }
                  }
                  self2.$element.val(val2);
                  self2.$element.trigger("input").trigger("change");
                });
              } else {
                var val = data.id;
                this.$element.val(val);
                this.$element.trigger("input").trigger("change");
              }
            };
            SelectAdapter.prototype.unselect = function(data) {
              var self2 = this;
              if (!this.$element.prop("multiple")) {
                return;
              }
              data.selected = false;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = false;
                this.$element.trigger("input").trigger("change");
                return;
              }
              this.current(function(currentData) {
                var val = [];
                for (var d4 = 0; d4 < currentData.length; d4++) {
                  var id14 = currentData[d4].id;
                  if (id14 !== data.id && val.indexOf(id14) === -1) {
                    val.push(id14);
                  }
                }
                self2.$element.val(val);
                self2.$element.trigger("input").trigger("change");
              });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
              var self2 = this;
              this.container = container;
              container.on("select", function(params) {
                self2.select(params.data);
              });
              container.on("unselect", function(params) {
                self2.unselect(params.data);
              });
            };
            SelectAdapter.prototype.destroy = function() {
              this.$element.find("*").each(function() {
                Utils.RemoveData(this);
              });
            };
            SelectAdapter.prototype.query = function(params, callback) {
              var data = [];
              var self2 = this;
              var $options = this.$element.children();
              $options.each(function() {
                if (this.tagName.toLowerCase() !== "option" && this.tagName.toLowerCase() !== "optgroup") {
                  return;
                }
                var $option = $5(this);
                var option = self2.item($option);
                var matches = self2.matches(params, option);
                if (matches !== null) {
                  data.push(matches);
                }
              });
              callback({
                results: data
              });
            };
            SelectAdapter.prototype.addOptions = function($options) {
              this.$element.append($options);
            };
            SelectAdapter.prototype.option = function(data) {
              var option;
              if (data.children) {
                option = document.createElement("optgroup");
                option.label = data.text;
              } else {
                option = document.createElement("option");
                if (option.textContent !== void 0) {
                  option.textContent = data.text;
                } else {
                  option.innerText = data.text;
                }
              }
              if (data.id !== void 0) {
                option.value = data.id;
              }
              if (data.disabled) {
                option.disabled = true;
              }
              if (data.selected) {
                option.selected = true;
              }
              if (data.title) {
                option.title = data.title;
              }
              var normalizedData = this._normalizeItem(data);
              normalizedData.element = option;
              Utils.StoreData(option, "data", normalizedData);
              return $5(option);
            };
            SelectAdapter.prototype.item = function($option) {
              var data = {};
              data = Utils.GetData($option[0], "data");
              if (data != null) {
                return data;
              }
              var option = $option[0];
              if (option.tagName.toLowerCase() === "option") {
                data = {
                  id: $option.val(),
                  text: $option.text(),
                  disabled: $option.prop("disabled"),
                  selected: $option.prop("selected"),
                  title: $option.prop("title")
                };
              } else if (option.tagName.toLowerCase() === "optgroup") {
                data = {
                  text: $option.prop("label"),
                  children: [],
                  title: $option.prop("title")
                };
                var $children = $option.children("option");
                var children = [];
                for (var c4 = 0; c4 < $children.length; c4++) {
                  var $child = $5($children[c4]);
                  var child = this.item($child);
                  children.push(child);
                }
                data.children = children;
              }
              data = this._normalizeItem(data);
              data.element = $option[0];
              Utils.StoreData($option[0], "data", data);
              return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
              if (item !== Object(item)) {
                item = {
                  id: item,
                  text: item
                };
              }
              item = $5.extend({}, {
                text: ""
              }, item);
              var defaults = {
                selected: false,
                disabled: false
              };
              if (item.id != null) {
                item.id = item.id.toString();
              }
              if (item.text != null) {
                item.text = item.text.toString();
              }
              if (item._resultId == null && item.id && this.container != null) {
                item._resultId = this.generateResultId(this.container, item);
              }
              return $5.extend({}, defaults, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
              var matcher = this.options.get("matcher");
              return matcher(params, data);
            };
            return SelectAdapter;
          });
          S23.define("select2/data/array", [
            "./select",
            "../utils",
            "jquery"
          ], function(SelectAdapter, Utils, $5) {
            function ArrayAdapter($element, options) {
              this._dataToConvert = options.get("data") || [];
              ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
              ArrayAdapter.__super__.bind.call(this, container, $container);
              this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
              var $option = this.$element.find("option").filter(function(i4, elm) {
                return elm.value == data.id.toString();
              });
              if ($option.length === 0) {
                $option = this.option(data);
                this.addOptions($option);
              }
              ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
              var self2 = this;
              var $existing = this.$element.find("option");
              var existingIds = $existing.map(function() {
                return self2.item($5(this)).id;
              }).get();
              var $options = [];
              function onlyItem(item2) {
                return function() {
                  return $5(this).val() == item2.id;
                };
              }
              for (var d4 = 0; d4 < data.length; d4++) {
                var item = this._normalizeItem(data[d4]);
                if (existingIds.indexOf(item.id) >= 0) {
                  var $existingOption = $existing.filter(onlyItem(item));
                  var existingData = this.item($existingOption);
                  var newData = $5.extend(true, {}, item, existingData);
                  var $newOption = this.option(newData);
                  $existingOption.replaceWith($newOption);
                  continue;
                }
                var $option = this.option(item);
                if (item.children) {
                  var $children = this.convertToOptions(item.children);
                  $option.append($children);
                }
                $options.push($option);
              }
              return $options;
            };
            return ArrayAdapter;
          });
          S23.define("select2/data/ajax", [
            "./array",
            "../utils",
            "jquery"
          ], function(ArrayAdapter, Utils, $5) {
            function AjaxAdapter($element, options) {
              this.ajaxOptions = this._applyDefaults(options.get("ajax"));
              if (this.ajaxOptions.processResults != null) {
                this.processResults = this.ajaxOptions.processResults;
              }
              AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
              var defaults = {
                data: function(params) {
                  return $5.extend({}, params, {
                    q: params.term
                  });
                },
                transport: function(params, success, failure) {
                  var $request = $5.ajax(params);
                  $request.then(success);
                  $request.fail(failure);
                  return $request;
                }
              };
              return $5.extend({}, defaults, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
              return results;
            };
            AjaxAdapter.prototype.query = function(params, callback) {
              var matches = [];
              var self2 = this;
              if (this._request != null) {
                if (typeof this._request.abort === "function") {
                  this._request.abort();
                }
                this._request = null;
              }
              var options = $5.extend({
                type: "GET"
              }, this.ajaxOptions);
              if (typeof options.url === "function") {
                options.url = options.url.call(this.$element, params);
              }
              if (typeof options.data === "function") {
                options.data = options.data.call(this.$element, params);
              }
              function request() {
                var $request = options.transport(options, function(data) {
                  var results = self2.processResults(data, params);
                  if (self2.options.get("debug") && window.console && console.error) {
                    if (!results || !results.results || !Array.isArray(results.results)) {
                      console.error(
                        "Select2: The AJAX results did not return an array in the `results` key of the response."
                      );
                    }
                  }
                  callback(results);
                }, function() {
                  if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                    return;
                  }
                  self2.trigger("results:message", {
                    message: "errorLoading"
                  });
                });
                self2._request = $request;
              }
              if (this.ajaxOptions.delay && params.term != null) {
                if (this._queryTimeout) {
                  window.clearTimeout(this._queryTimeout);
                }
                this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
              } else {
                request();
              }
            };
            return AjaxAdapter;
          });
          S23.define("select2/data/tags", [
            "jquery"
          ], function($5) {
            function Tags(decorated, $element, options) {
              var tags = options.get("tags");
              var createTag = options.get("createTag");
              if (createTag !== void 0) {
                this.createTag = createTag;
              }
              var insertTag = options.get("insertTag");
              if (insertTag !== void 0) {
                this.insertTag = insertTag;
              }
              decorated.call(this, $element, options);
              if (Array.isArray(tags)) {
                for (var t5 = 0; t5 < tags.length; t5++) {
                  var tag = tags[t5];
                  var item = this._normalizeItem(tag);
                  var $option = this.option(item);
                  this.$element.append($option);
                }
              }
            }
            Tags.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._removeOldTags();
              if (params.term == null || params.page != null) {
                decorated.call(this, params, callback);
                return;
              }
              function wrapper(obj, child) {
                var data = obj.results;
                for (var i4 = 0; i4 < data.length; i4++) {
                  var option = data[i4];
                  var checkChildren = option.children != null && !wrapper({
                    results: option.children
                  }, true);
                  var optionText = (option.text || "").toUpperCase();
                  var paramsTerm = (params.term || "").toUpperCase();
                  var checkText = optionText === paramsTerm;
                  if (checkText || checkChildren) {
                    if (child) {
                      return false;
                    }
                    obj.data = data;
                    callback(obj);
                    return;
                  }
                }
                if (child) {
                  return true;
                }
                var tag = self2.createTag(params);
                if (tag != null) {
                  var $option = self2.option(tag);
                  $option.attr("data-select2-tag", "true");
                  self2.addOptions([$option]);
                  self2.insertTag(data, tag);
                }
                obj.results = data;
                callback(obj);
              }
              decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
              if (params.term == null) {
                return null;
              }
              var term = params.term.trim();
              if (term === "") {
                return null;
              }
              return {
                id: term,
                text: term
              };
            };
            Tags.prototype.insertTag = function(_4, data, tag) {
              data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_4) {
              var $options = this.$element.find("option[data-select2-tag]");
              $options.each(function() {
                if (this.selected) {
                  return;
                }
                $5(this).remove();
              });
            };
            return Tags;
          });
          S23.define("select2/data/tokenizer", [
            "jquery"
          ], function($5) {
            function Tokenizer(decorated, $element, options) {
              var tokenizer = options.get("tokenizer");
              if (tokenizer !== void 0) {
                this.tokenizer = tokenizer;
              }
              decorated.call(this, $element, options);
            }
            Tokenizer.prototype.bind = function(decorated, container, $container) {
              decorated.call(this, container, $container);
              this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              function createAndSelect(data) {
                var item = self2._normalizeItem(data);
                var $existingOptions = self2.$element.find("option").filter(function() {
                  return $5(this).val() === item.id;
                });
                if (!$existingOptions.length) {
                  var $option = self2.option(item);
                  $option.attr("data-select2-tag", true);
                  self2._removeOldTags();
                  self2.addOptions([$option]);
                }
                select(item);
              }
              function select(data) {
                self2.trigger("select", {
                  data
                });
              }
              params.term = params.term || "";
              var tokenData = this.tokenizer(params, this.options, createAndSelect);
              if (tokenData.term !== params.term) {
                if (this.$search.length) {
                  this.$search.val(tokenData.term);
                  this.$search.trigger("focus");
                }
                params.term = tokenData.term;
              }
              decorated.call(this, params, callback);
            };
            Tokenizer.prototype.tokenizer = function(_4, params, options, callback) {
              var separators = options.get("tokenSeparators") || [];
              var term = params.term;
              var i4 = 0;
              var createTag = this.createTag || function(params2) {
                return {
                  id: params2.term,
                  text: params2.term
                };
              };
              while (i4 < term.length) {
                var termChar = term[i4];
                if (separators.indexOf(termChar) === -1) {
                  i4++;
                  continue;
                }
                var part = term.substr(0, i4);
                var partParams = $5.extend({}, params, {
                  term: part
                });
                var data = createTag(partParams);
                if (data == null) {
                  i4++;
                  continue;
                }
                callback(data);
                term = term.substr(i4 + 1) || "";
                i4 = 0;
              }
              return {
                term
              };
            };
            return Tokenizer;
          });
          S23.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e2, options) {
              this.minimumInputLength = options.get("minimumInputLength");
              decorated.call(this, $e2, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (params.term.length < this.minimumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooShort",
                  args: {
                    minimum: this.minimumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MinimumInputLength;
          });
          S23.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e2, options) {
              this.maximumInputLength = options.get("maximumInputLength");
              decorated.call(this, $e2, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooLong",
                  args: {
                    maximum: this.maximumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MaximumInputLength;
          });
          S23.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e2, options) {
              this.maximumSelectionLength = options.get("maximumSelectionLength");
              decorated.call(this, $e2, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function() {
                self2._checkIfMaximumSelected();
              });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._checkIfMaximumSelected(function() {
                decorated.call(self2, params, callback);
              });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_4, successCallback) {
              var self2 = this;
              this.current(function(currentData) {
                var count = currentData != null ? currentData.length : 0;
                if (self2.maximumSelectionLength > 0 && count >= self2.maximumSelectionLength) {
                  self2.trigger("results:message", {
                    message: "maximumSelected",
                    args: {
                      maximum: self2.maximumSelectionLength
                    }
                  });
                  return;
                }
                if (successCallback) {
                  successCallback();
                }
              });
            };
            return MaximumSelectionLength;
          });
          S23.define("select2/dropdown", [
            "jquery",
            "./utils"
          ], function($5, Utils) {
            function Dropdown($element, options) {
              this.$element = $element;
              this.options = options;
              Dropdown.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown, Utils.Observable);
            Dropdown.prototype.render = function() {
              var $dropdown = $5(
                '<span class="select2-dropdown"><span class="select2-results"></span></span>'
              );
              $dropdown.attr("dir", this.options.get("dir"));
              this.$dropdown = $dropdown;
              return $dropdown;
            };
            Dropdown.prototype.bind = function() {
            };
            Dropdown.prototype.position = function($dropdown, $container) {
            };
            Dropdown.prototype.destroy = function() {
              this.$dropdown.remove();
            };
            return Dropdown;
          });
          S23.define("select2/dropdown/search", [
            "jquery"
          ], function($5) {
            function Search() {
            }
            Search.prototype.render = function(decorated) {
              var $rendered = decorated.call(this);
              var searchLabel = this.options.get("translations").get("search");
              var $search = $5(
                '<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("input");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              $rendered.prepend($search);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              decorated.call(this, container, $container);
              this.$search.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
              });
              this.$search.on("input", function(evt) {
                $5(this).off("keyup");
              });
              this.$search.on("keyup input", function(evt) {
                self2.handleSearch(evt);
              });
              container.on("open", function() {
                self2.$search.attr("tabindex", 0);
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
                window.setTimeout(function() {
                  self2.$search.trigger("focus");
                }, 0);
              });
              container.on("close", function() {
                self2.$search.attr("tabindex", -1);
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.val("");
                self2.$search.trigger("blur");
              });
              container.on("focus", function() {
                if (!container.isOpen()) {
                  self2.$search.trigger("focus");
                }
              });
              container.on("results:all", function(params) {
                if (params.query.term == null || params.query.term === "") {
                  var showSearch = self2.showSearch(params);
                  if (showSearch) {
                    self2.$searchContainer[0].classList.remove("select2-search--hide");
                  } else {
                    self2.$searchContainer[0].classList.add("select2-search--hide");
                  }
                }
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
            };
            Search.prototype.handleSearch = function(evt) {
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_4, params) {
              return true;
            };
            return Search;
          });
          S23.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
              data.results = this.removePlaceholder(data.results);
              decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_4, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_4, data) {
              var modifiedData = data.slice(0);
              for (var d4 = data.length - 1; d4 >= 0; d4--) {
                var item = data[d4];
                if (this.placeholder.id === item.id) {
                  modifiedData.splice(d4, 1);
                }
              }
              return modifiedData;
            };
            return HidePlaceholder;
          });
          S23.define("select2/dropdown/infiniteScroll", [
            "jquery"
          ], function($5) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
              this.lastParams = {};
              decorated.call(this, $element, options, dataAdapter);
              this.$loadingMore = this.createLoadingMore();
              this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
              this.$loadingMore.remove();
              this.loading = false;
              decorated.call(this, data);
              if (this.showLoadingMore(data)) {
                this.$results.append(this.$loadingMore);
                this.loadMoreIfNeeded();
              }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("query", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              container.on("query:append", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
              var isLoadMoreVisible = $5.contains(
                document.documentElement,
                this.$loadingMore[0]
              );
              if (this.loading || !isLoadMoreVisible) {
                return;
              }
              var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
              var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
              if (currentOffset + 50 >= loadingMoreOffset) {
                this.loadMore();
              }
            };
            InfiniteScroll.prototype.loadMore = function() {
              this.loading = true;
              var params = $5.extend({}, { page: 1 }, this.lastParams);
              params.page++;
              this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_4, data) {
              return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
              var $option = $5(
                '<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'
              );
              var message = this.options.get("translations").get("loadingMore");
              $option.html(message(this.lastParams));
              return $option;
            };
            return InfiniteScroll;
          });
          S23.define("select2/dropdown/attachBody", [
            "jquery",
            "../utils"
          ], function($5, Utils) {
            function AttachBody(decorated, $element, options) {
              this.$dropdownParent = $5(options.get("dropdownParent") || document.body);
              decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("open", function() {
                self2._showDropdown();
                self2._attachPositioningHandler(container);
                self2._bindContainerResultHandlers(container);
              });
              container.on("close", function() {
                self2._hideDropdown();
                self2._detachPositioningHandler(container);
              });
              this.$dropdownContainer.on("mousedown", function(evt) {
                evt.stopPropagation();
              });
            };
            AttachBody.prototype.destroy = function(decorated) {
              decorated.call(this);
              this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
              $dropdown.attr("class", $container.attr("class"));
              $dropdown[0].classList.remove("select2");
              $dropdown[0].classList.add("select2-container--open");
              $dropdown.css({
                position: "absolute",
                top: -999999
              });
              this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
              var $container = $5("<span></span>");
              var $dropdown = decorated.call(this);
              $container.append($dropdown);
              this.$dropdownContainer = $container;
              return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
              this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
              if (this._containerResultsHandlersBound) {
                return;
              }
              var self2 = this;
              container.on("results:all", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:append", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:message", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("select", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("unselect", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
              var self2 = this;
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.each(function() {
                Utils.StoreData(this, "select2-scroll-position", {
                  x: $5(this).scrollLeft(),
                  y: $5(this).scrollTop()
                });
              });
              $watchers.on(scrollEvent, function(ev) {
                var position = Utils.GetData(this, "select2-scroll-position");
                $5(this).scrollTop(position.y);
              });
              $5(window).on(
                scrollEvent + " " + resizeEvent + " " + orientationEvent,
                function(e4) {
                  self2._positionDropdown();
                  self2._resizeDropdown();
                }
              );
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.off(scrollEvent);
              $5(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
              var $window = $5(window);
              var isCurrentlyAbove = this.$dropdown[0].classList.contains("select2-dropdown--above");
              var isCurrentlyBelow = this.$dropdown[0].classList.contains("select2-dropdown--below");
              var newDirection = null;
              var offset3 = this.$container.offset();
              offset3.bottom = offset3.top + this.$container.outerHeight(false);
              var container = {
                height: this.$container.outerHeight(false)
              };
              container.top = offset3.top;
              container.bottom = offset3.top + container.height;
              var dropdown = {
                height: this.$dropdown.outerHeight(false)
              };
              var viewport3 = {
                top: $window.scrollTop(),
                bottom: $window.scrollTop() + $window.height()
              };
              var enoughRoomAbove = viewport3.top < offset3.top - dropdown.height;
              var enoughRoomBelow = viewport3.bottom > offset3.bottom + dropdown.height;
              var css = {
                left: offset3.left,
                top: container.bottom
              };
              var $offsetParent = this.$dropdownParent;
              if ($offsetParent.css("position") === "static") {
                $offsetParent = $offsetParent.offsetParent();
              }
              var parentOffset = {
                top: 0,
                left: 0
              };
              if ($5.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
                parentOffset = $offsetParent.offset();
              }
              css.top -= parentOffset.top;
              css.left -= parentOffset.left;
              if (!isCurrentlyAbove && !isCurrentlyBelow) {
                newDirection = "below";
              }
              if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                newDirection = "above";
              } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                newDirection = "below";
              }
              if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                css.top = container.top - parentOffset.top - dropdown.height;
              }
              if (newDirection != null) {
                this.$dropdown[0].classList.remove("select2-dropdown--below");
                this.$dropdown[0].classList.remove("select2-dropdown--above");
                this.$dropdown[0].classList.add("select2-dropdown--" + newDirection);
                this.$container[0].classList.remove("select2-container--below");
                this.$container[0].classList.remove("select2-container--above");
                this.$container[0].classList.add("select2-container--" + newDirection);
              }
              this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
              var css = {
                width: this.$container.outerWidth(false) + "px"
              };
              if (this.options.get("dropdownAutoWidth")) {
                css.minWidth = css.width;
                css.position = "relative";
                css.width = "auto";
              }
              this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
              this.$dropdownContainer.appendTo(this.$dropdownParent);
              this._positionDropdown();
              this._resizeDropdown();
            };
            return AttachBody;
          });
          S23.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
              var count = 0;
              for (var d4 = 0; d4 < data.length; d4++) {
                var item = data[d4];
                if (item.children) {
                  count += countResults(item.children);
                } else {
                  count++;
                }
              }
              return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
              this.minimumResultsForSearch = options.get("minimumResultsForSearch");
              if (this.minimumResultsForSearch < 0) {
                this.minimumResultsForSearch = Infinity;
              }
              decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
              if (countResults(params.data.results) < this.minimumResultsForSearch) {
                return false;
              }
              return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
          });
          S23.define("select2/dropdown/selectOnClose", [
            "../utils"
          ], function(Utils) {
            function SelectOnClose() {
            }
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("close", function(params) {
                self2._handleSelectOnClose(params);
              });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_4, params) {
              if (params && params.originalSelect2Event != null) {
                var event = params.originalSelect2Event;
                if (event._type === "select" || event._type === "unselect") {
                  return;
                }
              }
              var $highlightedResults = this.getHighlightedResults();
              if ($highlightedResults.length < 1) {
                return;
              }
              var data = Utils.GetData($highlightedResults[0], "data");
              if (data.element != null && data.element.selected || data.element == null && data.selected) {
                return;
              }
              this.trigger("select", {
                data
              });
            };
            return SelectOnClose;
          });
          S23.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {
            }
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function(evt) {
                self2._selectTriggered(evt);
              });
              container.on("unselect", function(evt) {
                self2._selectTriggered(evt);
              });
            };
            CloseOnSelect.prototype._selectTriggered = function(_4, evt) {
              var originalEvent = evt.originalEvent;
              if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                return;
              }
              this.trigger("close", {
                originalEvent,
                originalSelect2Event: evt
              });
            };
            return CloseOnSelect;
          });
          S23.define("select2/dropdown/dropdownCss", [
            "../utils"
          ], function(Utils) {
            function DropdownCSS() {
            }
            DropdownCSS.prototype.render = function(decorated) {
              var $dropdown = decorated.call(this);
              var dropdownCssClass = this.options.get("dropdownCssClass") || "";
              if (dropdownCssClass.indexOf(":all:") !== -1) {
                dropdownCssClass = dropdownCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
              }
              $dropdown.addClass(dropdownCssClass);
              return $dropdown;
            };
            return DropdownCSS;
          });
          S23.define("select2/dropdown/tagsSearchHighlight", [
            "../utils"
          ], function(Utils) {
            function TagsSearchHighlight() {
            }
            TagsSearchHighlight.prototype.highlightFirstItem = function(decorated) {
              var $options = this.$results.find(
                ".select2-results__option--selectable:not(.select2-results__option--selected)"
              );
              if ($options.length > 0) {
                var $firstOption = $options.first();
                var data = Utils.GetData($firstOption[0], "data");
                var firstElement = data.element;
                if (firstElement && firstElement.getAttribute) {
                  if (firstElement.getAttribute("data-select2-tag") === "true") {
                    $firstOption.trigger("mouseenter");
                    return;
                  }
                }
              }
              decorated.call(this);
            };
            return TagsSearchHighlight;
          });
          S23.define("select2/i18n/en", [], function() {
            return {
              errorLoading: function() {
                return "The results could not be loaded.";
              },
              inputTooLong: function(args) {
                var overChars = args.input.length - args.maximum;
                var message = "Please delete " + overChars + " character";
                if (overChars != 1) {
                  message += "s";
                }
                return message;
              },
              inputTooShort: function(args) {
                var remainingChars = args.minimum - args.input.length;
                var message = "Please enter " + remainingChars + " or more characters";
                return message;
              },
              loadingMore: function() {
                return "Loading more results\u2026";
              },
              maximumSelected: function(args) {
                var message = "You can only select " + args.maximum + " item";
                if (args.maximum != 1) {
                  message += "s";
                }
                return message;
              },
              noResults: function() {
                return "No results found";
              },
              searching: function() {
                return "Searching\u2026";
              },
              removeAllItems: function() {
                return "Remove all items";
              },
              removeItem: function() {
                return "Remove item";
              },
              search: function() {
                return "Search";
              }
            };
          });
          S23.define("select2/defaults", [
            "jquery",
            "./results",
            "./selection/single",
            "./selection/multiple",
            "./selection/placeholder",
            "./selection/allowClear",
            "./selection/search",
            "./selection/selectionCss",
            "./selection/eventRelay",
            "./utils",
            "./translation",
            "./diacritics",
            "./data/select",
            "./data/array",
            "./data/ajax",
            "./data/tags",
            "./data/tokenizer",
            "./data/minimumInputLength",
            "./data/maximumInputLength",
            "./data/maximumSelectionLength",
            "./dropdown",
            "./dropdown/search",
            "./dropdown/hidePlaceholder",
            "./dropdown/infiniteScroll",
            "./dropdown/attachBody",
            "./dropdown/minimumResultsForSearch",
            "./dropdown/selectOnClose",
            "./dropdown/closeOnSelect",
            "./dropdown/dropdownCss",
            "./dropdown/tagsSearchHighlight",
            "./i18n/en"
          ], function($5, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, SelectionCSS, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, DropdownCSS, TagsSearchHighlight, EnglishTranslation) {
            function Defaults() {
              this.reset();
            }
            Defaults.prototype.apply = function(options) {
              options = $5.extend(true, {}, this.defaults, options);
              if (options.dataAdapter == null) {
                if (options.ajax != null) {
                  options.dataAdapter = AjaxData;
                } else if (options.data != null) {
                  options.dataAdapter = ArrayData;
                } else {
                  options.dataAdapter = SelectData;
                }
                if (options.minimumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MinimumInputLength
                  );
                }
                if (options.maximumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumInputLength
                  );
                }
                if (options.maximumSelectionLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumSelectionLength
                  );
                }
                if (options.tags) {
                  options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                }
                if (options.tokenSeparators != null || options.tokenizer != null) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    Tokenizer
                  );
                }
              }
              if (options.resultsAdapter == null) {
                options.resultsAdapter = ResultsList;
                if (options.ajax != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    InfiniteScroll
                  );
                }
                if (options.placeholder != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    HidePlaceholder
                  );
                }
                if (options.selectOnClose) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    SelectOnClose
                  );
                }
                if (options.tags) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    TagsSearchHighlight
                  );
                }
              }
              if (options.dropdownAdapter == null) {
                if (options.multiple) {
                  options.dropdownAdapter = Dropdown;
                } else {
                  var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                  options.dropdownAdapter = SearchableDropdown;
                }
                if (options.minimumResultsForSearch !== 0) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    MinimumResultsForSearch
                  );
                }
                if (options.closeOnSelect) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    CloseOnSelect
                  );
                }
                if (options.dropdownCssClass != null) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    DropdownCSS
                  );
                }
                options.dropdownAdapter = Utils.Decorate(
                  options.dropdownAdapter,
                  AttachBody
                );
              }
              if (options.selectionAdapter == null) {
                if (options.multiple) {
                  options.selectionAdapter = MultipleSelection;
                } else {
                  options.selectionAdapter = SingleSelection;
                }
                if (options.placeholder != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    Placeholder
                  );
                }
                if (options.allowClear) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    AllowClear
                  );
                }
                if (options.multiple) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionSearch
                  );
                }
                if (options.selectionCssClass != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionCSS
                  );
                }
                options.selectionAdapter = Utils.Decorate(
                  options.selectionAdapter,
                  EventRelay
                );
              }
              options.language = this._resolveLanguage(options.language);
              options.language.push("en");
              var uniqueLanguages = [];
              for (var l4 = 0; l4 < options.language.length; l4++) {
                var language = options.language[l4];
                if (uniqueLanguages.indexOf(language) === -1) {
                  uniqueLanguages.push(language);
                }
              }
              options.language = uniqueLanguages;
              options.translations = this._processTranslations(
                options.language,
                options.debug
              );
              return options;
            };
            Defaults.prototype.reset = function() {
              function stripDiacritics(text) {
                function match2(a4) {
                  return DIACRITICS[a4] || a4;
                }
                return text.replace(/[^\u0000-\u007E]/g, match2);
              }
              function matcher(params, data) {
                if (params.term == null || params.term.trim() === "") {
                  return data;
                }
                if (data.children && data.children.length > 0) {
                  var match2 = $5.extend(true, {}, data);
                  for (var c4 = data.children.length - 1; c4 >= 0; c4--) {
                    var child = data.children[c4];
                    var matches = matcher(params, child);
                    if (matches == null) {
                      match2.children.splice(c4, 1);
                    }
                  }
                  if (match2.children.length > 0) {
                    return match2;
                  }
                  return matcher(params, match2);
                }
                var original = stripDiacritics(data.text).toUpperCase();
                var term = stripDiacritics(params.term).toUpperCase();
                if (original.indexOf(term) > -1) {
                  return data;
                }
                return null;
              }
              this.defaults = {
                amdLanguageBase: "./i18n/",
                autocomplete: "off",
                closeOnSelect: true,
                debug: false,
                dropdownAutoWidth: false,
                escapeMarkup: Utils.escapeMarkup,
                language: {},
                matcher,
                minimumInputLength: 0,
                maximumInputLength: 0,
                maximumSelectionLength: 0,
                minimumResultsForSearch: 0,
                selectOnClose: false,
                scrollAfterSelect: false,
                sorter: function(data) {
                  return data;
                },
                templateResult: function(result) {
                  return result.text;
                },
                templateSelection: function(selection) {
                  return selection.text;
                },
                theme: "default",
                width: "resolve"
              };
            };
            Defaults.prototype.applyFromElement = function(options, $element) {
              var optionLanguage = options.language;
              var defaultLanguage = this.defaults.language;
              var elementLanguage = $element.prop("lang");
              var parentLanguage = $element.closest("[lang]").prop("lang");
              var languages = Array.prototype.concat.call(
                this._resolveLanguage(elementLanguage),
                this._resolveLanguage(optionLanguage),
                this._resolveLanguage(defaultLanguage),
                this._resolveLanguage(parentLanguage)
              );
              options.language = languages;
              return options;
            };
            Defaults.prototype._resolveLanguage = function(language) {
              if (!language) {
                return [];
              }
              if ($5.isEmptyObject(language)) {
                return [];
              }
              if ($5.isPlainObject(language)) {
                return [language];
              }
              var languages;
              if (!Array.isArray(language)) {
                languages = [language];
              } else {
                languages = language;
              }
              var resolvedLanguages = [];
              for (var l4 = 0; l4 < languages.length; l4++) {
                resolvedLanguages.push(languages[l4]);
                if (typeof languages[l4] === "string" && languages[l4].indexOf("-") > 0) {
                  var languageParts = languages[l4].split("-");
                  var baseLanguage = languageParts[0];
                  resolvedLanguages.push(baseLanguage);
                }
              }
              return resolvedLanguages;
            };
            Defaults.prototype._processTranslations = function(languages, debug) {
              var translations = new Translation();
              for (var l4 = 0; l4 < languages.length; l4++) {
                var languageData = new Translation();
                var language = languages[l4];
                if (typeof language === "string") {
                  try {
                    languageData = Translation.loadPath(language);
                  } catch (e4) {
                    try {
                      language = this.defaults.amdLanguageBase + language;
                      languageData = Translation.loadPath(language);
                    } catch (ex) {
                      if (debug && window.console && console.warn) {
                        console.warn(
                          'Select2: The language file for "' + language + '" could not be automatically loaded. A fallback will be used instead.'
                        );
                      }
                    }
                  }
                } else if ($5.isPlainObject(language)) {
                  languageData = new Translation(language);
                } else {
                  languageData = language;
                }
                translations.extend(languageData);
              }
              return translations;
            };
            Defaults.prototype.set = function(key, value) {
              var camelKey = $5.camelCase(key);
              var data = {};
              data[camelKey] = value;
              var convertedData = Utils._convertData(data);
              $5.extend(true, this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
          });
          S23.define("select2/options", [
            "jquery",
            "./defaults",
            "./utils"
          ], function($5, Defaults, Utils) {
            function Options(options, $element) {
              this.options = options;
              if ($element != null) {
                this.fromElement($element);
              }
              if ($element != null) {
                this.options = Defaults.applyFromElement(this.options, $element);
              }
              this.options = Defaults.apply(this.options);
            }
            Options.prototype.fromElement = function($e2) {
              var excludedData = ["select2"];
              if (this.options.multiple == null) {
                this.options.multiple = $e2.prop("multiple");
              }
              if (this.options.disabled == null) {
                this.options.disabled = $e2.prop("disabled");
              }
              if (this.options.autocomplete == null && $e2.prop("autocomplete")) {
                this.options.autocomplete = $e2.prop("autocomplete");
              }
              if (this.options.dir == null) {
                if ($e2.prop("dir")) {
                  this.options.dir = $e2.prop("dir");
                } else if ($e2.closest("[dir]").prop("dir")) {
                  this.options.dir = $e2.closest("[dir]").prop("dir");
                } else {
                  this.options.dir = "ltr";
                }
              }
              $e2.prop("disabled", this.options.disabled);
              $e2.prop("multiple", this.options.multiple);
              if (Utils.GetData($e2[0], "select2Tags")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'
                  );
                }
                Utils.StoreData($e2[0], "data", Utils.GetData($e2[0], "select2Tags"));
                Utils.StoreData($e2[0], "tags", true);
              }
              if (Utils.GetData($e2[0], "ajaxUrl")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    "Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."
                  );
                }
                $e2.attr("ajax--url", Utils.GetData($e2[0], "ajaxUrl"));
                Utils.StoreData($e2[0], "ajax-Url", Utils.GetData($e2[0], "ajaxUrl"));
              }
              var dataset = {};
              function upperCaseLetter(_4, letter) {
                return letter.toUpperCase();
              }
              for (var attr = 0; attr < $e2[0].attributes.length; attr++) {
                var attributeName = $e2[0].attributes[attr].name;
                var prefix = "data-";
                if (attributeName.substr(0, prefix.length) == prefix) {
                  var dataName = attributeName.substring(prefix.length);
                  var dataValue = Utils.GetData($e2[0], dataName);
                  var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                  dataset[camelDataName] = dataValue;
                }
              }
              if ($5.fn.jquery && $5.fn.jquery.substr(0, 2) == "1." && $e2[0].dataset) {
                dataset = $5.extend(true, {}, $e2[0].dataset, dataset);
              }
              var data = $5.extend(true, {}, Utils.GetData($e2[0]), dataset);
              data = Utils._convertData(data);
              for (var key in data) {
                if (excludedData.indexOf(key) > -1) {
                  continue;
                }
                if ($5.isPlainObject(this.options[key])) {
                  $5.extend(this.options[key], data[key]);
                } else {
                  this.options[key] = data[key];
                }
              }
              return this;
            };
            Options.prototype.get = function(key) {
              return this.options[key];
            };
            Options.prototype.set = function(key, val) {
              this.options[key] = val;
            };
            return Options;
          });
          S23.define("select2/core", [
            "jquery",
            "./options",
            "./utils",
            "./keys"
          ], function($5, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
              if (Utils.GetData($element[0], "select2") != null) {
                Utils.GetData($element[0], "select2").destroy();
              }
              this.$element = $element;
              this.id = this._generateId($element);
              options = options || {};
              this.options = new Options(options, $element);
              Select2.__super__.constructor.call(this);
              var tabindex = $element.attr("tabindex") || 0;
              Utils.StoreData($element[0], "old-tabindex", tabindex);
              $element.attr("tabindex", "-1");
              var DataAdapter = this.options.get("dataAdapter");
              this.dataAdapter = new DataAdapter($element, this.options);
              var $container = this.render();
              this._placeContainer($container);
              var SelectionAdapter = this.options.get("selectionAdapter");
              this.selection = new SelectionAdapter($element, this.options);
              this.$selection = this.selection.render();
              this.selection.position(this.$selection, $container);
              var DropdownAdapter = this.options.get("dropdownAdapter");
              this.dropdown = new DropdownAdapter($element, this.options);
              this.$dropdown = this.dropdown.render();
              this.dropdown.position(this.$dropdown, $container);
              var ResultsAdapter = this.options.get("resultsAdapter");
              this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
              this.$results = this.results.render();
              this.results.position(this.$results, this.$dropdown);
              var self2 = this;
              this._bindAdapters();
              this._registerDomEvents();
              this._registerDataEvents();
              this._registerSelectionEvents();
              this._registerDropdownEvents();
              this._registerResultsEvents();
              this._registerEvents();
              this.dataAdapter.current(function(initialData) {
                self2.trigger("selection:update", {
                  data: initialData
                });
              });
              $element[0].classList.add("select2-hidden-accessible");
              $element.attr("aria-hidden", "true");
              this._syncAttributes();
              Utils.StoreData($element[0], "select2", this);
              $element.data("select2", this);
            };
            Utils.Extend(Select2, Utils.Observable);
            Select2.prototype._generateId = function($element) {
              var id14 = "";
              if ($element.attr("id") != null) {
                id14 = $element.attr("id");
              } else if ($element.attr("name") != null) {
                id14 = $element.attr("name") + "-" + Utils.generateChars(2);
              } else {
                id14 = Utils.generateChars(4);
              }
              id14 = id14.replace(/(:|\.|\[|\]|,)/g, "");
              id14 = "select2-" + id14;
              return id14;
            };
            Select2.prototype._placeContainer = function($container) {
              $container.insertAfter(this.$element);
              var width = this._resolveWidth(this.$element, this.options.get("width"));
              if (width != null) {
                $container.css("width", width);
              }
            };
            Select2.prototype._resolveWidth = function($element, method) {
              var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
              if (method == "resolve") {
                var styleWidth = this._resolveWidth($element, "style");
                if (styleWidth != null) {
                  return styleWidth;
                }
                return this._resolveWidth($element, "element");
              }
              if (method == "element") {
                var elementWidth = $element.outerWidth(false);
                if (elementWidth <= 0) {
                  return "auto";
                }
                return elementWidth + "px";
              }
              if (method == "style") {
                var style = $element.attr("style");
                if (typeof style !== "string") {
                  return null;
                }
                var attrs = style.split(";");
                for (var i4 = 0, l4 = attrs.length; i4 < l4; i4 = i4 + 1) {
                  var attr = attrs[i4].replace(/\s/g, "");
                  var matches = attr.match(WIDTH);
                  if (matches !== null && matches.length >= 1) {
                    return matches[1];
                  }
                }
                return null;
              }
              if (method == "computedstyle") {
                var computedStyle = window.getComputedStyle($element[0]);
                return computedStyle.width;
              }
              return method;
            };
            Select2.prototype._bindAdapters = function() {
              this.dataAdapter.bind(this, this.$container);
              this.selection.bind(this, this.$container);
              this.dropdown.bind(this, this.$container);
              this.results.bind(this, this.$container);
            };
            Select2.prototype._registerDomEvents = function() {
              var self2 = this;
              this.$element.on("change.select2", function() {
                self2.dataAdapter.current(function(data) {
                  self2.trigger("selection:update", {
                    data
                  });
                });
              });
              this.$element.on("focus.select2", function(evt) {
                self2.trigger("focus", evt);
              });
              this._syncA = Utils.bind(this._syncAttributes, this);
              this._syncS = Utils.bind(this._syncSubtree, this);
              this._observer = new window.MutationObserver(function(mutations) {
                self2._syncA();
                self2._syncS(mutations);
              });
              this._observer.observe(this.$element[0], {
                attributes: true,
                childList: true,
                subtree: false
              });
            };
            Select2.prototype._registerDataEvents = function() {
              var self2 = this;
              this.dataAdapter.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerSelectionEvents = function() {
              var self2 = this;
              var nonRelayEvents = ["toggle", "focus"];
              this.selection.on("toggle", function() {
                self2.toggleDropdown();
              });
              this.selection.on("focus", function(params) {
                self2.focus(params);
              });
              this.selection.on("*", function(name, params) {
                if (nonRelayEvents.indexOf(name) !== -1) {
                  return;
                }
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerDropdownEvents = function() {
              var self2 = this;
              this.dropdown.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerResultsEvents = function() {
              var self2 = this;
              this.results.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerEvents = function() {
              var self2 = this;
              this.on("open", function() {
                self2.$container[0].classList.add("select2-container--open");
              });
              this.on("close", function() {
                self2.$container[0].classList.remove("select2-container--open");
              });
              this.on("enable", function() {
                self2.$container[0].classList.remove("select2-container--disabled");
              });
              this.on("disable", function() {
                self2.$container[0].classList.add("select2-container--disabled");
              });
              this.on("blur", function() {
                self2.$container[0].classList.remove("select2-container--focus");
              });
              this.on("query", function(params) {
                if (!self2.isOpen()) {
                  self2.trigger("open", {});
                }
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:all", {
                    data,
                    query: params
                  });
                });
              });
              this.on("query:append", function(params) {
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:append", {
                    data,
                    query: params
                  });
                });
              });
              this.on("keypress", function(evt) {
                var key = evt.which;
                if (self2.isOpen()) {
                  if (key === KEYS.ESC || key === KEYS.UP && evt.altKey) {
                    self2.close(evt);
                    evt.preventDefault();
                  } else if (key === KEYS.ENTER || key === KEYS.TAB) {
                    self2.trigger("results:select", {});
                    evt.preventDefault();
                  } else if (key === KEYS.SPACE && evt.ctrlKey) {
                    self2.trigger("results:toggle", {});
                    evt.preventDefault();
                  } else if (key === KEYS.UP) {
                    self2.trigger("results:previous", {});
                    evt.preventDefault();
                  } else if (key === KEYS.DOWN) {
                    self2.trigger("results:next", {});
                    evt.preventDefault();
                  }
                } else {
                  if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                    self2.open();
                    evt.preventDefault();
                  }
                }
              });
            };
            Select2.prototype._syncAttributes = function() {
              this.options.set("disabled", this.$element.prop("disabled"));
              if (this.isDisabled()) {
                if (this.isOpen()) {
                  this.close();
                }
                this.trigger("disable", {});
              } else {
                this.trigger("enable", {});
              }
            };
            Select2.prototype._isChangeMutation = function(mutations) {
              var self2 = this;
              if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                for (var n4 = 0; n4 < mutations.addedNodes.length; n4++) {
                  var node = mutations.addedNodes[n4];
                  if (node.selected) {
                    return true;
                  }
                }
              } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                return true;
              } else if (Array.isArray(mutations)) {
                return mutations.some(function(mutation) {
                  return self2._isChangeMutation(mutation);
                });
              }
              return false;
            };
            Select2.prototype._syncSubtree = function(mutations) {
              var changed = this._isChangeMutation(mutations);
              var self2 = this;
              if (changed) {
                this.dataAdapter.current(function(currentData) {
                  self2.trigger("selection:update", {
                    data: currentData
                  });
                });
              }
            };
            Select2.prototype.trigger = function(name, args) {
              var actualTrigger = Select2.__super__.trigger;
              var preTriggerMap = {
                "open": "opening",
                "close": "closing",
                "select": "selecting",
                "unselect": "unselecting",
                "clear": "clearing"
              };
              if (args === void 0) {
                args = {};
              }
              if (name in preTriggerMap) {
                var preTriggerName = preTriggerMap[name];
                var preTriggerArgs = {
                  prevented: false,
                  name,
                  args
                };
                actualTrigger.call(this, preTriggerName, preTriggerArgs);
                if (preTriggerArgs.prevented) {
                  args.prevented = true;
                  return;
                }
              }
              actualTrigger.call(this, name, args);
            };
            Select2.prototype.toggleDropdown = function() {
              if (this.isDisabled()) {
                return;
              }
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            };
            Select2.prototype.open = function() {
              if (this.isOpen()) {
                return;
              }
              if (this.isDisabled()) {
                return;
              }
              this.trigger("query", {});
            };
            Select2.prototype.close = function(evt) {
              if (!this.isOpen()) {
                return;
              }
              this.trigger("close", { originalEvent: evt });
            };
            Select2.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            Select2.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            Select2.prototype.isOpen = function() {
              return this.$container[0].classList.contains("select2-container--open");
            };
            Select2.prototype.hasFocus = function() {
              return this.$container[0].classList.contains("select2-container--focus");
            };
            Select2.prototype.focus = function(data) {
              if (this.hasFocus()) {
                return;
              }
              this.$container[0].classList.add("select2-container--focus");
              this.trigger("focus", {});
            };
            Select2.prototype.enable = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'
                );
              }
              if (args == null || args.length === 0) {
                args = [true];
              }
              var disabled = !args[0];
              this.$element.prop("disabled", disabled);
            };
            Select2.prototype.data = function() {
              if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                console.warn(
                  'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'
                );
              }
              var data = [];
              this.dataAdapter.current(function(currentData) {
                data = currentData;
              });
              return data;
            };
            Select2.prototype.val = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'
                );
              }
              if (args == null || args.length === 0) {
                return this.$element.val();
              }
              var newVal = args[0];
              if (Array.isArray(newVal)) {
                newVal = newVal.map(function(obj) {
                  return obj.toString();
                });
              }
              this.$element.val(newVal).trigger("input").trigger("change");
            };
            Select2.prototype.destroy = function() {
              Utils.RemoveData(this.$container[0]);
              this.$container.remove();
              this._observer.disconnect();
              this._observer = null;
              this._syncA = null;
              this._syncS = null;
              this.$element.off(".select2");
              this.$element.attr(
                "tabindex",
                Utils.GetData(this.$element[0], "old-tabindex")
              );
              this.$element[0].classList.remove("select2-hidden-accessible");
              this.$element.attr("aria-hidden", "false");
              Utils.RemoveData(this.$element[0]);
              this.$element.removeData("select2");
              this.dataAdapter.destroy();
              this.selection.destroy();
              this.dropdown.destroy();
              this.results.destroy();
              this.dataAdapter = null;
              this.selection = null;
              this.dropdown = null;
              this.results = null;
            };
            Select2.prototype.render = function() {
              var $container = $5(
                '<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'
              );
              $container.attr("dir", this.options.get("dir"));
              this.$container = $container;
              this.$container[0].classList.add("select2-container--" + this.options.get("theme"));
              Utils.StoreData($container[0], "element", this.$element);
              return $container;
            };
            return Select2;
          });
          S23.define("jquery-mousewheel", [
            "jquery"
          ], function($5) {
            return $5;
          });
          S23.define("jquery.select2", [
            "jquery",
            "jquery-mousewheel",
            "./select2/core",
            "./select2/defaults",
            "./select2/utils"
          ], function($5, _4, Select2, Defaults, Utils) {
            if ($5.fn.select2 == null) {
              var thisMethods = ["open", "close", "destroy"];
              $5.fn.select2 = function(options) {
                options = options || {};
                if (typeof options === "object") {
                  this.each(function() {
                    var instanceOptions = $5.extend(true, {}, options);
                    var instance = new Select2($5(this), instanceOptions);
                  });
                  return this;
                } else if (typeof options === "string") {
                  var ret;
                  var args = Array.prototype.slice.call(arguments, 1);
                  this.each(function() {
                    var instance = Utils.GetData(this, "select2");
                    if (instance == null && window.console && console.error) {
                      console.error(
                        "The select2('" + options + "') method was called on an element that is not using Select2."
                      );
                    }
                    ret = instance[options].apply(instance, args);
                  });
                  if (thisMethods.indexOf(options) > -1) {
                    return this;
                  }
                  return ret;
                } else {
                  throw new Error("Invalid arguments for Select2: " + options);
                }
              };
            }
            if ($5.fn.select2.defaults == null) {
              $5.fn.select2.defaults = Defaults;
            }
            return Select2;
          });
          return {
            define: S23.define,
            require: S23.require
          };
        }();
        var select2 = S22.require("jquery.select2");
        jQuery2.fn.select2.amd = S22;
        return select2;
      });
    }
  });

  // ../../node_modules/pluralize/pluralize.js
  var require_pluralize = __commonJS({
    "../../node_modules/pluralize/pluralize.js"(exports, module) {
      (function(root, pluralize) {
        if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
          module.exports = pluralize();
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return pluralize();
          });
        } else {
          root.pluralize = pluralize();
        }
      })(exports, function() {
        var pluralRules = [];
        var singularRules = [];
        var uncountables = {};
        var irregularPlurals = {};
        var irregularSingles = {};
        function sanitizeRule(rule) {
          if (typeof rule === "string") {
            return new RegExp("^" + rule + "$", "i");
          }
          return rule;
        }
        function restoreCase(word, token) {
          if (word === token) return token;
          if (word === word.toLowerCase()) return token.toLowerCase();
          if (word === word.toUpperCase()) return token.toUpperCase();
          if (word[0] === word[0].toUpperCase()) {
            return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
          }
          return token.toLowerCase();
        }
        function interpolate3(str, args) {
          return str.replace(/\$(\d{1,2})/g, function(match2, index) {
            return args[index] || "";
          });
        }
        function replace(word, rule) {
          return word.replace(rule[0], function(match2, index) {
            var result = interpolate3(rule[1], arguments);
            if (match2 === "") {
              return restoreCase(word[index - 1], result);
            }
            return restoreCase(match2, result);
          });
        }
        function sanitizeWord(token, word, rules) {
          if (!token.length || uncountables.hasOwnProperty(token)) {
            return word;
          }
          var len = rules.length;
          while (len--) {
            var rule = rules[len];
            if (rule[0].test(word)) return replace(word, rule);
          }
          return word;
        }
        function replaceWord(replaceMap, keepMap, rules) {
          return function(word) {
            var token = word.toLowerCase();
            if (keepMap.hasOwnProperty(token)) {
              return restoreCase(word, token);
            }
            if (replaceMap.hasOwnProperty(token)) {
              return restoreCase(word, replaceMap[token]);
            }
            return sanitizeWord(token, word, rules);
          };
        }
        function checkWord(replaceMap, keepMap, rules, bool) {
          return function(word) {
            var token = word.toLowerCase();
            if (keepMap.hasOwnProperty(token)) return true;
            if (replaceMap.hasOwnProperty(token)) return false;
            return sanitizeWord(token, token, rules) === token;
          };
        }
        function pluralize(word, count, inclusive) {
          var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
          return (inclusive ? count + " " : "") + pluralized;
        }
        pluralize.plural = replaceWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize.isPlural = checkWord(
          irregularSingles,
          irregularPlurals,
          pluralRules
        );
        pluralize.singular = replaceWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize.isSingular = checkWord(
          irregularPlurals,
          irregularSingles,
          singularRules
        );
        pluralize.addPluralRule = function(rule, replacement) {
          pluralRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize.addSingularRule = function(rule, replacement) {
          singularRules.push([sanitizeRule(rule), replacement]);
        };
        pluralize.addUncountableRule = function(word) {
          if (typeof word === "string") {
            uncountables[word.toLowerCase()] = true;
            return;
          }
          pluralize.addPluralRule(word, "$0");
          pluralize.addSingularRule(word, "$0");
        };
        pluralize.addIrregularRule = function(single, plural) {
          plural = plural.toLowerCase();
          single = single.toLowerCase();
          irregularSingles[single] = plural;
          irregularPlurals[plural] = single;
        };
        [
          // Pronouns.
          ["I", "we"],
          ["me", "us"],
          ["he", "they"],
          ["she", "they"],
          ["them", "them"],
          ["myself", "ourselves"],
          ["yourself", "yourselves"],
          ["itself", "themselves"],
          ["herself", "themselves"],
          ["himself", "themselves"],
          ["themself", "themselves"],
          ["is", "are"],
          ["was", "were"],
          ["has", "have"],
          ["this", "these"],
          ["that", "those"],
          // Words ending in with a consonant and `o`.
          ["echo", "echoes"],
          ["dingo", "dingoes"],
          ["volcano", "volcanoes"],
          ["tornado", "tornadoes"],
          ["torpedo", "torpedoes"],
          // Ends with `us`.
          ["genus", "genera"],
          ["viscus", "viscera"],
          // Ends with `ma`.
          ["stigma", "stigmata"],
          ["stoma", "stomata"],
          ["dogma", "dogmata"],
          ["lemma", "lemmata"],
          ["schema", "schemata"],
          ["anathema", "anathemata"],
          // Other irregular rules.
          ["ox", "oxen"],
          ["axe", "axes"],
          ["die", "dice"],
          ["yes", "yeses"],
          ["foot", "feet"],
          ["eave", "eaves"],
          ["goose", "geese"],
          ["tooth", "teeth"],
          ["quiz", "quizzes"],
          ["human", "humans"],
          ["proof", "proofs"],
          ["carve", "carves"],
          ["valve", "valves"],
          ["looey", "looies"],
          ["thief", "thieves"],
          ["groove", "grooves"],
          ["pickaxe", "pickaxes"],
          ["passerby", "passersby"]
        ].forEach(function(rule) {
          return pluralize.addIrregularRule(rule[0], rule[1]);
        });
        [
          [/s?$/i, "s"],
          [/[^\u0000-\u007F]$/i, "$0"],
          [/([^aeiou]ese)$/i, "$1"],
          [/(ax|test)is$/i, "$1es"],
          [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
          [/(e[mn]u)s?$/i, "$1s"],
          [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
          [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
          [/(seraph|cherub)(?:im)?$/i, "$1im"],
          [/(her|at|gr)o$/i, "$1oes"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
          [/sis$/i, "ses"],
          [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
          [/([^aeiouy]|qu)y$/i, "$1ies"],
          [/([^ch][ieo][ln])ey$/i, "$1ies"],
          [/(x|ch|ss|sh|zz)$/i, "$1es"],
          [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
          [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
          [/(pe)(?:rson|ople)$/i, "$1ople"],
          [/(child)(?:ren)?$/i, "$1ren"],
          [/eaux$/i, "$0"],
          [/m[ae]n$/i, "men"],
          ["thou", "you"]
        ].forEach(function(rule) {
          return pluralize.addPluralRule(rule[0], rule[1]);
        });
        [
          [/s$/i, ""],
          [/(ss)$/i, "$1"],
          [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
          [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
          [/ies$/i, "y"],
          [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
          [/\b(mon|smil)ies$/i, "$1ey"],
          [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
          [/(seraph|cherub)im$/i, "$1"],
          [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
          [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
          [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
          [/(test)(?:is|es)$/i, "$1is"],
          [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
          [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
          [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
          [/(alumn|alg|vertebr)ae$/i, "$1a"],
          [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
          [/(matr|append)ices$/i, "$1ix"],
          [/(pe)(rson|ople)$/i, "$1rson"],
          [/(child)ren$/i, "$1"],
          [/(eau)x?$/i, "$1"],
          [/men$/i, "man"]
        ].forEach(function(rule) {
          return pluralize.addSingularRule(rule[0], rule[1]);
        });
        [
          // Singular words with no plurals.
          "adulthood",
          "advice",
          "agenda",
          "aid",
          "aircraft",
          "alcohol",
          "ammo",
          "analytics",
          "anime",
          "athletics",
          "audio",
          "bison",
          "blood",
          "bream",
          "buffalo",
          "butter",
          "carp",
          "cash",
          "chassis",
          "chess",
          "clothing",
          "cod",
          "commerce",
          "cooperation",
          "corps",
          "debris",
          "diabetes",
          "digestion",
          "elk",
          "energy",
          "equipment",
          "excretion",
          "expertise",
          "firmware",
          "flounder",
          "fun",
          "gallows",
          "garbage",
          "graffiti",
          "hardware",
          "headquarters",
          "health",
          "herpes",
          "highjinks",
          "homework",
          "housework",
          "information",
          "jeans",
          "justice",
          "kudos",
          "labour",
          "literature",
          "machinery",
          "mackerel",
          "mail",
          "media",
          "mews",
          "moose",
          "music",
          "mud",
          "manga",
          "news",
          "only",
          "personnel",
          "pike",
          "plankton",
          "pliers",
          "police",
          "pollution",
          "premises",
          "rain",
          "research",
          "rice",
          "salmon",
          "scissors",
          "series",
          "sewage",
          "shambles",
          "shrimp",
          "software",
          "species",
          "staff",
          "swine",
          "tennis",
          "traffic",
          "transportation",
          "trout",
          "tuna",
          "wealth",
          "welfare",
          "whiting",
          "wildebeest",
          "wildlife",
          "you",
          /pok[e]mon$/i,
          // Regexes.
          /[^aeiou]ese$/i,
          // "chinese", "japanese"
          /deer$/i,
          // "deer", "reindeer"
          /fish$/i,
          // "fish", "blowfish", "angelfish"
          /measles$/i,
          /o[iu]s$/i,
          // "carnivorous"
          /pox$/i,
          // "chickpox", "smallpox"
          /sheep$/i
        ].forEach(pluralize.addUncountableRule);
        return pluralize;
      });
    }
  });

  // ../../node_modules/jstimezonedetect/dist/jstz.min.js
  var require_jstz_min = __commonJS({
    "../../node_modules/jstimezonedetect/dist/jstz.min.js"(exports, module) {
      !function(e4) {
        var a4 = function() {
          "use strict";
          var e5 = "s", s4 = { DAY: 864e5, HOUR: 36e5, MINUTE: 6e4, SECOND: 1e3, BASELINE_YEAR: 2014, MAX_SCORE: 864e6, AMBIGUITIES: { "America/Denver": ["America/Mazatlan"], "America/Chicago": ["America/Mexico_City"], "America/Asuncion": ["America/Campo_Grande", "America/Santiago"], "America/Montevideo": ["America/Sao_Paulo", "America/Santiago"], "Asia/Beirut": ["Asia/Amman", "Asia/Jerusalem", "Europe/Helsinki", "Asia/Damascus", "Africa/Cairo", "Asia/Gaza", "Europe/Minsk", "Africa/Windhoek"], "Pacific/Auckland": ["Pacific/Fiji"], "America/Los_Angeles": ["America/Santa_Isabel"], "America/New_York": ["America/Havana"], "America/Halifax": ["America/Goose_Bay"], "America/Godthab": ["America/Miquelon"], "Asia/Dubai": ["Asia/Yerevan"], "Asia/Jakarta": ["Asia/Krasnoyarsk"], "Asia/Shanghai": ["Asia/Irkutsk", "Australia/Perth"], "Australia/Sydney": ["Australia/Lord_Howe"], "Asia/Tokyo": ["Asia/Yakutsk"], "Asia/Dhaka": ["Asia/Omsk"], "Asia/Baku": ["Asia/Yerevan"], "Australia/Brisbane": ["Asia/Vladivostok"], "Pacific/Noumea": ["Asia/Vladivostok"], "Pacific/Majuro": ["Asia/Kamchatka", "Pacific/Fiji"], "Pacific/Tongatapu": ["Pacific/Apia"], "Asia/Baghdad": ["Europe/Minsk", "Europe/Moscow"], "Asia/Karachi": ["Asia/Yekaterinburg"], "Africa/Johannesburg": ["Asia/Gaza", "Africa/Cairo"] } }, i4 = function(e6) {
            var a5 = -e6.getTimezoneOffset();
            return null !== a5 ? a5 : 0;
          }, r4 = function() {
            for (var e6 = [], a5 = 0; a5 <= 11; a5++) for (var r5 = 1; r5 <= 28; r5++) {
              var n5 = i4(new Date(s4.BASELINE_YEAR, a5, r5));
              e6 ? e6 && e6[e6.length - 1] !== n5 && e6.push(n5) : e6.push();
            }
            return e6;
          }, n4 = function() {
            var a5 = 0, s5 = r4();
            return s5.length > 1 && (a5 = s5[0] - s5[1]), s5.length > 3 ? s5[0] + ",1,weird" : a5 < 0 ? s5[0] + ",1" : a5 > 0 ? s5[1] + ",1," + e5 : s5[0] + ",0";
          }, o4 = function() {
            var e6, a5;
            if (Intl && "undefined" != typeof Intl && "undefined" != typeof Intl.DateTimeFormat && (e6 = Intl.DateTimeFormat(), "undefined" != typeof e6 && "undefined" != typeof e6.resolvedOptions)) return a5 = e6.resolvedOptions().timeZone, a5 && (a5.indexOf("/") > -1 || "UTC" === a5) ? a5 : void 0;
          }, t5 = function(e6) {
            for (var a5 = new Date(e6, 0, 1, 0, 0, 1, 0).getTime(), s5 = new Date(e6, 12, 31, 23, 59, 59).getTime(), i5 = a5, r5 = new Date(i5).getTimezoneOffset(), n5 = null, o5 = null; i5 < s5 - 864e5; ) {
              var t6 = new Date(i5), A5 = t6.getTimezoneOffset();
              A5 !== r5 && (A5 < r5 && (n5 = t6), A5 > r5 && (o5 = t6), r5 = A5), i5 += 864e5;
            }
            return !(!n5 || !o5) && { s: u4(n5).getTime(), e: u4(o5).getTime() };
          }, u4 = function f4(e6, a5, i5) {
            "undefined" == typeof a5 && (a5 = s4.DAY, i5 = s4.HOUR);
            for (var r5 = new Date(e6.getTime() - a5).getTime(), n5 = e6.getTime() + a5, o5 = new Date(r5).getTimezoneOffset(), t6 = r5, u5 = null; t6 < n5 - i5; ) {
              var A5 = new Date(t6), c5 = A5.getTimezoneOffset();
              if (c5 !== o5) {
                u5 = A5;
                break;
              }
              t6 += i5;
            }
            return a5 === s4.DAY ? f4(u5, s4.HOUR, s4.MINUTE) : a5 === s4.HOUR ? f4(u5, s4.MINUTE, s4.SECOND) : u5;
          }, A4 = function(e6, a5, s5, i5) {
            if ("N/A" !== s5) return s5;
            if ("Asia/Beirut" === a5) {
              if ("Africa/Cairo" === i5.name && 13983768e5 === e6[6].s && 14116788e5 === e6[6].e) return 0;
              if ("Asia/Jerusalem" === i5.name && 13959648e5 === e6[6].s && 14118588e5 === e6[6].e) return 0;
            } else if ("America/Santiago" === a5) {
              if ("America/Asuncion" === i5.name && 14124816e5 === e6[6].s && 1397358e6 === e6[6].e) return 0;
              if ("America/Campo_Grande" === i5.name && 14136912e5 === e6[6].s && 13925196e5 === e6[6].e) return 0;
            } else if ("America/Montevideo" === a5) {
              if ("America/Sao_Paulo" === i5.name && 14136876e5 === e6[6].s && 1392516e6 === e6[6].e) return 0;
            } else if ("Pacific/Auckland" === a5 && "Pacific/Fiji" === i5.name && 14142456e5 === e6[6].s && 13961016e5 === e6[6].e) return 0;
            return s5;
          }, c4 = function(e6, i5) {
            for (var r5 = function(a5) {
              for (var r6 = 0, n6 = 0; n6 < e6.length; n6++) if (a5.rules[n6] && e6[n6]) {
                if (!(e6[n6].s >= a5.rules[n6].s && e6[n6].e <= a5.rules[n6].e)) {
                  r6 = "N/A";
                  break;
                }
                if (r6 = 0, r6 += Math.abs(e6[n6].s - a5.rules[n6].s), r6 += Math.abs(a5.rules[n6].e - e6[n6].e), r6 > s4.MAX_SCORE) {
                  r6 = "N/A";
                  break;
                }
              }
              return r6 = A4(e6, i5, r6, a5);
            }, n5 = {}, o5 = a4.olson.dst_rules.zones, t6 = o5.length, u5 = s4.AMBIGUITIES[i5], c5 = 0; c5 < t6; c5++) {
              var m5 = o5[c5], l5 = r5(o5[c5]);
              "N/A" !== l5 && (n5[m5.name] = l5);
            }
            for (var f4 in n5) if (n5.hasOwnProperty(f4)) {
              for (var d4 = 0; d4 < u5.length; d4++) if (u5[d4] === f4) return f4;
            }
            return i5;
          }, m4 = function(e6) {
            var s5 = function() {
              for (var e7 = [], s6 = 0; s6 < a4.olson.dst_rules.years.length; s6++) {
                var i6 = t5(a4.olson.dst_rules.years[s6]);
                e7.push(i6);
              }
              return e7;
            }, i5 = function(e7) {
              for (var a5 = 0; a5 < e7.length; a5++) if (e7[a5] !== false) return true;
              return false;
            }, r5 = s5(), n5 = i5(r5);
            return n5 ? c4(r5, e6) : e6;
          }, l4 = function(e6) {
            var i5 = false, t6 = n4();
            return (e6 || "undefined" == typeof e6) && (i5 = o4()), i5 || (i5 = a4.olson.timezones[t6], "undefined" != typeof s4.AMBIGUITIES[i5] && (i5 = m4(i5))), { name: function() {
              return i5;
            }, using_intl: e6 || "undefined" == typeof e6, needle: t6, offsets: r4() };
          };
          return { determine: l4 };
        }();
        a4.olson = a4.olson || {}, a4.olson.timezones = { "-720,0": "Etc/GMT+12", "-660,0": "Pacific/Pago_Pago", "-660,1,s": "Pacific/Apia", "-600,1": "America/Adak", "-600,0": "Pacific/Honolulu", "-570,0": "Pacific/Marquesas", "-540,0": "Pacific/Gambier", "-540,1": "America/Anchorage", "-480,1": "America/Los_Angeles", "-480,0": "Pacific/Pitcairn", "-420,0": "America/Phoenix", "-420,1": "America/Denver", "-360,0": "America/Guatemala", "-360,1": "America/Chicago", "-360,1,s": "Pacific/Easter", "-300,0": "America/Bogota", "-300,1": "America/New_York", "-270,0": "America/Caracas", "-240,1": "America/Halifax", "-240,0": "America/Santo_Domingo", "-240,1,s": "America/Asuncion", "-210,1": "America/St_Johns", "-180,1": "America/Godthab", "-180,0": "America/Buenos_Aires", "-180,1,s": "America/Montevideo", "-120,0": "America/Noronha", "-120,1": "America/Noronha", "-60,1": "Atlantic/Azores", "-60,0": "Atlantic/Cape_Verde", "0,0": "UTC", "0,1": "Europe/London", "0,1,weird": "Africa/Casablanca", "60,1": "Europe/Berlin", "60,0": "Africa/Lagos", "60,1,weird": "Africa/Casablanca", "120,1": "Asia/Beirut", "120,1,weird": "Africa/Cairo", "120,0": "Africa/Johannesburg", "180,0": "Asia/Baghdad", "180,1": "Europe/Moscow", "210,1": "Asia/Tehran", "240,0": "Asia/Dubai", "240,1": "Asia/Baku", "270,0": "Asia/Kabul", "300,1": "Asia/Yekaterinburg", "300,0": "Asia/Karachi", "330,0": "Asia/Calcutta", "345,0": "Asia/Katmandu", "360,0": "Asia/Dhaka", "360,1": "Asia/Omsk", "390,0": "Asia/Rangoon", "420,1": "Asia/Krasnoyarsk", "420,0": "Asia/Jakarta", "480,0": "Asia/Shanghai", "480,1": "Asia/Irkutsk", "525,0": "Australia/Eucla", "525,1,s": "Australia/Eucla", "540,1": "Asia/Yakutsk", "540,0": "Asia/Tokyo", "570,0": "Australia/Darwin", "570,1,s": "Australia/Adelaide", "600,0": "Australia/Brisbane", "600,1": "Asia/Vladivostok", "600,1,s": "Australia/Sydney", "630,1,s": "Australia/Lord_Howe", "660,1": "Asia/Kamchatka", "660,0": "Pacific/Noumea", "690,0": "Pacific/Norfolk", "720,1,s": "Pacific/Auckland", "720,0": "Pacific/Majuro", "765,1,s": "Pacific/Chatham", "780,0": "Pacific/Tongatapu", "780,1,s": "Pacific/Apia", "840,0": "Pacific/Kiritimati" }, a4.olson.dst_rules = { years: [2008, 2009, 2010, 2011, 2012, 2013, 2014], zones: [{ name: "Africa/Cairo", rules: [{ e: 12199572e5, s: 12090744e5 }, { e: 1250802e6, s: 1240524e6 }, { e: 12858804e5, s: 12840696e5 }, false, false, false, { e: 14116788e5, s: 1406844e6 }] }, { name: "America/Asuncion", rules: [{ e: 12050316e5, s: 12243888e5 }, { e: 12364812e5, s: 12558384e5 }, { e: 12709548e5, s: 12860784e5 }, { e: 13024044e5, s: 1317528e6 }, { e: 1333854e6, s: 13495824e5 }, { e: 1364094e6, s: 1381032e6 }, { e: 13955436e5, s: 14124816e5 }] }, { name: "America/Campo_Grande", rules: [{ e: 12032172e5, s: 12243888e5 }, { e: 12346668e5, s: 12558384e5 }, { e: 12667212e5, s: 1287288e6 }, { e: 12981708e5, s: 13187376e5 }, { e: 13302252e5, s: 1350792e6 }, { e: 136107e7, s: 13822416e5 }, { e: 13925196e5, s: 14136912e5 }] }, { name: "America/Goose_Bay", rules: [{ e: 122559486e4, s: 120503526e4 }, { e: 125704446e4, s: 123648486e4 }, { e: 128909886e4, s: 126853926e4 }, { e: 13205556e5, s: 129998886e4 }, { e: 13520052e5, s: 13314456e5 }, { e: 13834548e5, s: 13628952e5 }, { e: 14149044e5, s: 13943448e5 }] }, { name: "America/Havana", rules: [{ e: 12249972e5, s: 12056436e5 }, { e: 12564468e5, s: 12364884e5 }, { e: 12885012e5, s: 12685428e5 }, { e: 13211604e5, s: 13005972e5 }, { e: 13520052e5, s: 13332564e5 }, { e: 13834548e5, s: 13628916e5 }, { e: 14149044e5, s: 13943412e5 }] }, { name: "America/Mazatlan", rules: [{ e: 1225008e6, s: 12074724e5 }, { e: 12564576e5, s: 1238922e6 }, { e: 1288512e6, s: 12703716e5 }, { e: 13199616e5, s: 13018212e5 }, { e: 13514112e5, s: 13332708e5 }, { e: 13828608e5, s: 13653252e5 }, { e: 14143104e5, s: 13967748e5 }] }, { name: "America/Mexico_City", rules: [{ e: 12250044e5, s: 12074688e5 }, { e: 1256454e6, s: 12389184e5 }, { e: 12885084e5, s: 1270368e6 }, { e: 1319958e6, s: 13018176e5 }, { e: 13514076e5, s: 13332672e5 }, { e: 13828572e5, s: 13653216e5 }, { e: 14143068e5, s: 13967712e5 }] }, { name: "America/Miquelon", rules: [{ e: 12255984e5, s: 12050388e5 }, { e: 1257048e6, s: 12364884e5 }, { e: 12891024e5, s: 12685428e5 }, { e: 1320552e6, s: 12999924e5 }, { e: 13520016e5, s: 1331442e6 }, { e: 13834512e5, s: 13628916e5 }, { e: 14149008e5, s: 13943412e5 }] }, { name: "America/Santa_Isabel", rules: [{ e: 12250116e5, s: 1207476e6 }, { e: 12564612e5, s: 12389256e5 }, { e: 12891204e5, s: 12685608e5 }, { e: 132057e7, s: 13000104e5 }, { e: 13520196e5, s: 133146e7 }, { e: 13834692e5, s: 13629096e5 }, { e: 14149188e5, s: 13943592e5 }] }, { name: "America/Santiago", rules: [{ e: 1206846e6, s: 1223784e6 }, { e: 1237086e6, s: 12552336e5 }, { e: 127035e7, s: 12866832e5 }, { e: 13048236e5, s: 13138992e5 }, { e: 13356684e5, s: 13465584e5 }, { e: 1367118e6, s: 13786128e5 }, { e: 13985676e5, s: 14100624e5 }] }, { name: "America/Sao_Paulo", rules: [{ e: 12032136e5, s: 12243852e5 }, { e: 12346632e5, s: 12558348e5 }, { e: 12667176e5, s: 12872844e5 }, { e: 12981672e5, s: 1318734e6 }, { e: 13302216e5, s: 13507884e5 }, { e: 13610664e5, s: 1382238e6 }, { e: 1392516e6, s: 14136876e5 }] }, { name: "Asia/Amman", rules: [{ e: 1225404e6, s: 12066552e5 }, { e: 12568536e5, s: 12381048e5 }, { e: 12883032e5, s: 12695544e5 }, { e: 13197528e5, s: 13016088e5 }, false, false, { e: 14147064e5, s: 13959576e5 }] }, { name: "Asia/Damascus", rules: [{ e: 12254868e5, s: 120726e7 }, { e: 125685e7, s: 12381048e5 }, { e: 12882996e5, s: 12701592e5 }, { e: 13197492e5, s: 13016088e5 }, { e: 13511988e5, s: 13330584e5 }, { e: 13826484e5, s: 1364508e6 }, { e: 14147028e5, s: 13959576e5 }] }, { name: "Asia/Dubai", rules: [false, false, false, false, false, false, false] }, { name: "Asia/Gaza", rules: [{ e: 12199572e5, s: 12066552e5 }, { e: 12520152e5, s: 12381048e5 }, { e: 1281474e6, s: 126964086e4 }, { e: 1312146e6, s: 130160886e4 }, { e: 13481784e5, s: 13330584e5 }, { e: 13802292e5, s: 1364508e6 }, { e: 1414098e6, s: 13959576e5 }] }, { name: "Asia/Irkutsk", rules: [{ e: 12249576e5, s: 12068136e5 }, { e: 12564072e5, s: 12382632e5 }, { e: 12884616e5, s: 12697128e5 }, false, false, false, false] }, { name: "Asia/Jerusalem", rules: [{ e: 12231612e5, s: 12066624e5 }, { e: 1254006e6, s: 1238112e6 }, { e: 1284246e6, s: 12695616e5 }, { e: 131751e7, s: 1301616e6 }, { e: 13483548e5, s: 13330656e5 }, { e: 13828284e5, s: 13645152e5 }, { e: 1414278e6, s: 13959648e5 }] }, { name: "Asia/Kamchatka", rules: [{ e: 12249432e5, s: 12067992e5 }, { e: 12563928e5, s: 12382488e5 }, { e: 12884508e5, s: 12696984e5 }, false, false, false, false] }, { name: "Asia/Krasnoyarsk", rules: [{ e: 12249612e5, s: 12068172e5 }, { e: 12564108e5, s: 12382668e5 }, { e: 12884652e5, s: 12697164e5 }, false, false, false, false] }, { name: "Asia/Omsk", rules: [{ e: 12249648e5, s: 12068208e5 }, { e: 12564144e5, s: 12382704e5 }, { e: 12884688e5, s: 126972e7 }, false, false, false, false] }, { name: "Asia/Vladivostok", rules: [{ e: 12249504e5, s: 12068064e5 }, { e: 12564e8, s: 1238256e6 }, { e: 12884544e5, s: 12697056e5 }, false, false, false, false] }, { name: "Asia/Yakutsk", rules: [{ e: 1224954e6, s: 120681e7 }, { e: 12564036e5, s: 12382596e5 }, { e: 1288458e6, s: 12697092e5 }, false, false, false, false] }, { name: "Asia/Yekaterinburg", rules: [{ e: 12249684e5, s: 12068244e5 }, { e: 1256418e6, s: 1238274e6 }, { e: 12884724e5, s: 12697236e5 }, false, false, false, false] }, { name: "Asia/Yerevan", rules: [{ e: 1224972e6, s: 1206828e6 }, { e: 12564216e5, s: 12382776e5 }, { e: 1288476e6, s: 12697272e5 }, { e: 13199256e5, s: 13011768e5 }, false, false, false] }, { name: "Australia/Lord_Howe", rules: [{ e: 12074076e5, s: 12231342e5 }, { e: 12388572e5, s: 12545838e5 }, { e: 12703068e5, s: 12860334e5 }, { e: 13017564e5, s: 1317483e6 }, { e: 1333206e6, s: 13495374e5 }, { e: 13652604e5, s: 1380987e6 }, { e: 139671e7, s: 14124366e5 }] }, { name: "Australia/Perth", rules: [{ e: 12068136e5, s: 12249576e5 }, false, false, false, false, false, false] }, { name: "Europe/Helsinki", rules: [{ e: 12249828e5, s: 12068388e5 }, { e: 12564324e5, s: 12382884e5 }, { e: 12884868e5, s: 1269738e6 }, { e: 13199364e5, s: 13011876e5 }, { e: 1351386e6, s: 13326372e5 }, { e: 13828356e5, s: 13646916e5 }, { e: 14142852e5, s: 13961412e5 }] }, { name: "Europe/Minsk", rules: [{ e: 12249792e5, s: 12068352e5 }, { e: 12564288e5, s: 12382848e5 }, { e: 12884832e5, s: 12697344e5 }, false, false, false, false] }, { name: "Europe/Moscow", rules: [{ e: 12249756e5, s: 12068316e5 }, { e: 12564252e5, s: 12382812e5 }, { e: 12884796e5, s: 12697308e5 }, false, false, false, false] }, { name: "Pacific/Apia", rules: [false, false, false, { e: 13017528e5, s: 13168728e5 }, { e: 13332024e5, s: 13489272e5 }, { e: 13652568e5, s: 13803768e5 }, { e: 13967064e5, s: 14118264e5 }] }, { name: "Pacific/Fiji", rules: [false, false, { e: 12696984e5, s: 12878424e5 }, { e: 13271544e5, s: 1319292e6 }, { e: 1358604e6, s: 13507416e5 }, { e: 139005e7, s: 1382796e6 }, { e: 14215032e5, s: 14148504e5 }] }, { name: "Europe/London", rules: [{ e: 12249828e5, s: 12068388e5 }, { e: 12564324e5, s: 12382884e5 }, { e: 12884868e5, s: 1269738e6 }, { e: 13199364e5, s: 13011876e5 }, { e: 1351386e6, s: 13326372e5 }, { e: 13828356e5, s: 13646916e5 }, { e: 14142852e5, s: 13961412e5 }] }, { name: "Africa/Windhoek", rules: [{ e: 12207492e5, s: 120744e7 }, { e: 12521988e5, s: 12388896e5 }, { e: 12836484e5, s: 12703392e5 }, { e: 1315098e6, s: 13017888e5 }, { e: 13465476e5, s: 13332384e5 }, { e: 13779972e5, s: 13652928e5 }, { e: 14100516e5, s: 13967424e5 }] }] }, "undefined" != typeof module && "undefined" != typeof module.exports ? module.exports = a4 : "undefined" != typeof define && null !== define && null != define.amd ? define([], function() {
          return a4;
        }) : "undefined" == typeof e4 ? window.jstz = a4 : e4.jstz = a4;
      }();
    }
  });

  // ../../node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "../../node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "../../node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "../../node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordMessage() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // ../../node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "../../node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "../../node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          this.monitor.recordMessage();
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return null;
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // ../../node_modules/@rails/actioncable/src/subscription.js
  var extend3, Subscription;
  var init_subscription = __esm({
    "../../node_modules/@rails/actioncable/src/subscription.js"() {
      extend3 = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend3(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "../../node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s4) => s4 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // ../../node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "../../node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s4) => s4 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s4) => s4.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a4 = document.createElement("a");
      a4.href = url;
      a4.href = a4.href;
      a4.protocol = a4.protocol.replace("http", "ws");
      return a4.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "../../node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // ../../node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "../../node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // ../../node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left3, right3) => {
        const leftIndex = left3.index, rightIndex = right3.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName,
      eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
      identifier: matches[5],
      methodName: matches[6],
      keyFilter: matches[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_4, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_4, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match2 = name.match(pattern);
        const key = match2 && match2[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e4) => e4.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match2 = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match2.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match2 = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(selector)).filter((match3) => this.matchElement(match3));
        return match2.concat(matches);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left3, right3) {
    const length = Math.max(left3.length, right3.length);
    return Array.from({ length }, (_4, index) => [left3[index], right3[index]]);
  }
  function tokensAreEqual(left3, right3) {
    return left3 && right3 && left3.index == right3.index && left3.content == right3.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a4 = function() {
        this.a.call(this);
      };
      const b4 = extendWithReflect(a4);
      b4.prototype.a = function() {
      };
      return new b4();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger2) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger2;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger2) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger2);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c4) => [c4, c4]))), objectFromEntries("0123456789".split("").map((n4) => [n4, n4])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k4, v4]) => Object.assign(Object.assign({}, memo), { [k4]: v4 }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read3, writer: write3 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read3(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write3(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // controllers/copy_controller.js
  var copy_controller_exports = {};
  __export(copy_controller_exports, {
    default: () => copy_controller_default
  });

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x4 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y4,
      right: x4 + width,
      bottom: y4 + height,
      left: x4,
      x: x4,
      y: y4
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/within.js
  function within(min3, value, max3) {
    return max(min3, min(value, max3));
  }
  function withinMaxClamp(min3, value, max3) {
    var v4 = within(min3, value, max3);
    return v4 > max3 ? max3 : v4;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets3 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets3) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets3[axis] - state.rects.popper[len];
    var startDiff = popperOffsets3[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min3 = paddingObject[minProp];
    var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset3 = within(min3, center, max3);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x4 = _ref.x, y4 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x4 * dpr) / dpr || 0,
      y: round(y4 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper3 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x4 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x4,
      y: y4
    }) : {
      x: x4,
      y: y4
    };
    x4 = _ref3.x;
    y4 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper3);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper3)) {
        offsetParent = getDocumentElement(popper3);
        if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y4 -= offsetY - popperRect.height;
        y4 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x4 -= offsetX - popperRect.width;
        x4 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x4,
      y: y4
    }) : {
      x: x4,
      y: y4
    };
    x4 = _ref4.x;
    y4 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x4 + "px, " + y4 + "px)" : "translate3d(" + x4 + "px, " + y4 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x4 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x4 = 0;
    var y4 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x4 = visualViewport.offsetLeft;
        y4 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x4 + getWindowScrollBarX(element),
      y: y4
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x4 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y4 = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
      x4 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x4,
      y: y4
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents3 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents3.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents3 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents3[0];
    var clippingRect = clippingParents3.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference3 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference3.x + reference3.width / 2 - element.width / 2;
    var commonY = reference3.y + reference3.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference3.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference3.y + reference3.height
        };
        break;
      case right:
        offsets = {
          x: reference3.x + reference3.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference3.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference3.x,
          y: reference3.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference3[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference3[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets3 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets3));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset3 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset3[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements3.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements3;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a4, b4) {
      return overflows[a4] - overflows[b4];
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements3[0];
    for (var i4 = 0; i4 < placements3.length; i4++) {
      var placement = placements3[i4];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i3) {
        var fittingPlacement = placements3.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i3).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
        var _ret = _loop(_i2);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset3) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
      placement
    })) : offset3, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x4 = _data$state$placement.x, y4 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x4;
      state.modifiersData.popperOffsets.y += y4;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets3 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets3) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset3 = popperOffsets3[mainAxis];
      var min3 = offset3 + overflow[mainSide];
      var max3 = offset3 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset3 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min3, tetherMin) : min3, offset3, tether ? max(max3, tetherMax) : max3);
      popperOffsets3[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset3;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets3[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets3[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn4) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn4());
          });
        });
      }
      return pending;
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p4, c4) {
      return p4.replace(/%s/, c4);
    }, str);
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
        return self2.indexOf(value) === index;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s4) {
              return '"' + s4 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn4) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn4(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers4 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions4 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper5(reference3, popper3, options) {
      if (options === void 0) {
        options = defaultOptions4;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions4),
        modifiersData: {},
        elements: {
          reference: reference3,
          popper: popper3
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions4, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference3) ? listScrollParents(reference3) : reference3.contextElement ? listScrollParents(reference3.contextElement) : [],
            popper: listScrollParents(popper3)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers4, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m4) {
            return m4.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle(popper3), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference4 = _state$elements.reference, popper4 = _state$elements.popper;
          if (!areValidElements(reference4, popper4)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference4, getOffsetParent(popper4), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper4)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn4 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn4 === "function") {
              state = fn4({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference3, popper3)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect8 = _ref3.effect;
          if (typeof effect8 === "function") {
            var cleanupFn = effect8({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn4) {
          return fn4();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // ../../node_modules/tippy.js/node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // ../../node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
    return document.body;
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v4 = value[index];
      return v4 == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v4;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn4, ms) {
    if (ms === 0) {
      return fn4;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn4(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone = Object.assign({}, obj);
    keys.forEach(function(key) {
      delete clone[key];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now2 = performance.now();
    if (now2 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now2;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var isIE11 = isBrowser ? (
    // @ts-ignore
    !!window.msCrypto
  ) : false;
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference3, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference3.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e4) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference3, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference3])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference3, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow3 = div();
    if (value === true) {
      arrow3.className = ARROW_CLASS;
    } else {
      arrow3.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow3.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow3, value);
      }
    }
    return arrow3;
  }
  function setContent(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper3) {
    var box = popper3.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper3 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper3.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper3), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow3) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow3);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow3) {
        box2.removeChild(arrow3);
      }
    }
    return {
      popper: popper3,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference3, passedProps) {
    var props = evaluateProps(reference3, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id14 = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id: id14,
      reference: reference3,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      // methods
      clearDelayTimeouts,
      setProps,
      setContent: setContent2,
      show,
      hide: hide3,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper3 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper3.setAttribute("data-tippy-root", "");
    popper3.id = "tippy-" + instance.id;
    instance.popper = popper3;
    reference3._tippy = instance;
    popper3._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference3.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper3.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper3.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference3;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper3);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper3.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper3.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id15 = popper3.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id15 : id15);
        } else {
          var nextValue = currentValue && currentValue.replace(id15, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper3, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference3).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener("mousedown", onDocumentPress, true);
      doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener("mousedown", onDocumentPress, true);
      doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper3.parentNode && popper3.parentNode.contains(popper3)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on2(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on2("touchstart", onTrigger2, {
          passive: true
        });
        on2("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on2(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on2("mouseleave", onMouseLeave);
            break;
          case "focus":
            on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on2("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper3.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper3).map(function(popper4) {
        var _instance$popperInsta;
        var instance2 = popper4._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper4.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper3.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow3 = getIsDefaultRenderFn() ? getChildren(popper3).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference3;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn4(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: "offset",
        options: {
          offset: offset3
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow3) {
        modifiers.push({
          name: "arrow",
          options: {
            element: arrow3,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper3, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode.contains(popper3)) {
        parentNode.appendChild(popper3);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper3, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper3.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference3, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference3.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent2(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper3.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper3.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper3.offsetHeight;
        popper3.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide3() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper3.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper3.parentNode) {
        popper3.parentNode.removeChild(popper3);
      }
      mountedInstances = mountedInstances.filter(function(i4) {
        return i4 !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference3._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy2(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference3) {
      var instance = reference3 && createTippy(reference3, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances[0] : instances;
  }
  tippy2.defaultProps = defaultProps;
  tippy2.setDefaultProps = setDefaultProps;
  tippy2.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy2.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy2;

  // controllers/copy_controller.js
  var copy_controller_default = class extends Controller {
    static values = {
      successMessage: { type: String, default: "Copied!" },
      errorMessage: { type: String, default: "Failed!" },
      copyable: String,
      tippyOffset: { type: Array, default: [0, 10] }
    };
    tooltip(message) {
      tippy_esm_default(this.element, {
        content: message,
        showOnCreate: true,
        offset: this.tippyOffsetValue,
        onHidden(instance) {
          instance.destroy();
        }
      });
    }
    toClipboard(event) {
      let controller = this;
      if (this.copyableValue) {
        navigator.clipboard.writeText(this.copyableValue).then(
          function() {
            controller.tooltip(controller.successMessageValue);
          },
          function() {
            controller.tooltip(controller.errorMessageValue);
          }
        );
      } else {
        navigator.clipboard.writeText(event.currentTarget.innerText).then(
          function() {
            controller.tooltip(controller.successMessageValue);
          },
          function() {
            controller.tooltip(controller.errorMessageValue);
          }
        );
      }
    }
  };

  // controllers/datepicker_controller.js
  var datepicker_controller_exports = {};
  __export(datepicker_controller_exports, {
    default: () => datepicker_controller_default
  });

  // ../../node_modules/@eonasdan/tempus-dominus/dist/js/tempus-dominus.esm.js
  var TdError = class extends Error {
  };
  var ErrorMessages = class {
    constructor() {
      this.base = "TD:";
      this.failedToSetInvalidDate = "Failed to set invalid date";
      this.failedToParseInput = "Failed parse input field";
    }
    //#region out to console
    /**
     * Throws an error indicating that a key in the options object is invalid.
     * @param optionName
     */
    unexpectedOption(optionName) {
      const error2 = new TdError(`${this.base} Unexpected option: ${optionName} does not match a known option.`);
      error2.code = 1;
      throw error2;
    }
    /**
     * Throws an error indicating that one more keys in the options object is invalid.
     * @param optionName
     */
    unexpectedOptions(optionName) {
      const error2 = new TdError(`${this.base}: ${optionName.join(", ")}`);
      error2.code = 1;
      throw error2;
    }
    /**
     * Throws an error when an option is provide an unsupported value.
     * For example a value of 'cheese' for toolbarPlacement which only supports
     * 'top', 'bottom', 'default'.
     * @param optionName
     * @param badValue
     * @param validOptions
     */
    unexpectedOptionValue(optionName, badValue, validOptions) {
      const error2 = new TdError(`${this.base} Unexpected option value: ${optionName} does not accept a value of "${badValue}". Valid values are: ${validOptions.join(", ")}`);
      error2.code = 2;
      throw error2;
    }
    /**
     * Throws an error when an option value is the wrong type.
     * For example a string value was provided to multipleDates which only
     * supports true or false.
     * @param optionName
     * @param badType
     * @param expectedType
     */
    typeMismatch(optionName, badType, expectedType) {
      const error2 = new TdError(`${this.base} Mismatch types: ${optionName} has a type of ${badType} instead of the required ${expectedType}`);
      error2.code = 3;
      throw error2;
    }
    /**
     * Throws an error when an option value is  outside of the expected range.
     * For example restrictions.daysOfWeekDisabled excepts a value between 0 and 6.
     * @param optionName
     * @param lower
     * @param upper
     */
    numbersOutOfRange(optionName, lower, upper) {
      const error2 = new TdError(`${this.base} ${optionName} expected an array of number between ${lower} and ${upper}.`);
      error2.code = 4;
      throw error2;
    }
    /**
     * Throws an error when a value for a date options couldn't be parsed. Either
     * the option was an invalid string or an invalid Date object.
     * @param optionName
     * @param date
     * @param soft If true, logs a warning instead of an error.
     */
    //eslint-disable-next-line @typescript-eslint/no-explicit-any
    failedToParseDate(optionName, date, soft = false) {
      const error2 = new TdError(`${this.base} Could not correctly parse "${date}" to a date for ${optionName}.`);
      error2.code = 5;
      if (!soft)
        throw error2;
      console.warn(error2);
    }
    /**
     * Throws when an element to attach to was not provided in the constructor.
     */
    mustProvideElement() {
      const error2 = new TdError(`${this.base} No element was provided.`);
      error2.code = 6;
      throw error2;
    }
    /**
     * Throws if providing an array for the events to subscribe method doesn't have
     * the same number of callbacks. E.g., subscribe([1,2], [1])
     */
    subscribeMismatch() {
      const error2 = new TdError(`${this.base} The subscribed events does not match the number of callbacks`);
      error2.code = 7;
      throw error2;
    }
    /**
     * Throws if the configuration has conflicting rules e.g. minDate is after maxDate
     */
    conflictingConfiguration(message) {
      const error2 = new TdError(`${this.base} A configuration value conflicts with another rule. ${message}`);
      error2.code = 8;
      throw error2;
    }
    /**
     * customDateFormat errors
     */
    customDateFormatError(message) {
      const error2 = new TdError(`${this.base} Custom Date Format: ${message}`);
      error2.code = 9;
      throw error2;
    }
    /**
     * Logs a warning if a date option value is provided as a string, instead of
     * a date/datetime object.
     */
    dateString() {
      console.warn(`${this.base} Using a string for date options is not recommended unless you specify an ISO string or use the customDateFormat plugin.`);
    }
    deprecatedWarning(message, remediation) {
      console.warn(`${this.base} Warning ${message} is deprecated and will be removed in a future version. ${remediation}`);
    }
    throwError(message) {
      const error2 = new TdError(`${this.base} ${message}`);
      error2.code = 9;
      throw error2;
    }
  };
  var NAME = "tempus-dominus";
  var dataKey = "td";
  var Events = class {
    constructor() {
      this.key = `.${dataKey}`;
      this.change = `change${this.key}`;
      this.update = `update${this.key}`;
      this.error = `error${this.key}`;
      this.show = `show${this.key}`;
      this.hide = `hide${this.key}`;
      this.blur = `blur${this.key}`;
      this.focus = `focus${this.key}`;
      this.keyup = `keyup${this.key}`;
      this.keydown = `keydown${this.key}`;
    }
  };
  var Css = class {
    constructor() {
      this.widget = `${NAME}-widget`;
      this.calendarHeader = "calendar-header";
      this.switch = "picker-switch";
      this.toolbar = "toolbar";
      this.noHighlight = "no-highlight";
      this.sideBySide = "timepicker-sbs";
      this.previous = "previous";
      this.next = "next";
      this.disabled = "disabled";
      this.old = "old";
      this.new = "new";
      this.active = "active";
      this.dateContainer = "date-container";
      this.decadesContainer = `${this.dateContainer}-decades`;
      this.decade = "decade";
      this.yearsContainer = `${this.dateContainer}-years`;
      this.year = "year";
      this.monthsContainer = `${this.dateContainer}-months`;
      this.month = "month";
      this.daysContainer = `${this.dateContainer}-days`;
      this.day = "day";
      this.calendarWeeks = "cw";
      this.dayOfTheWeek = "dow";
      this.today = "today";
      this.weekend = "weekend";
      this.rangeIn = "range-in";
      this.rangeStart = "range-start";
      this.rangeEnd = "range-end";
      this.timeContainer = "time-container";
      this.separator = "separator";
      this.clockContainer = `${this.timeContainer}-clock`;
      this.hourContainer = `${this.timeContainer}-hour`;
      this.minuteContainer = `${this.timeContainer}-minute`;
      this.secondContainer = `${this.timeContainer}-second`;
      this.hour = "hour";
      this.minute = "minute";
      this.second = "second";
      this.toggleMeridiem = "toggleMeridiem";
      this.show = "show";
      this.collapsing = "td-collapsing";
      this.collapse = "td-collapse";
      this.inline = "inline";
      this.lightTheme = "light";
      this.darkTheme = "dark";
      this.isDarkPreferredQuery = "(prefers-color-scheme: dark)";
    }
  };
  var Namespace = class {
  };
  Namespace.NAME = NAME;
  Namespace.dataKey = dataKey;
  Namespace.events = new Events();
  Namespace.css = new Css();
  Namespace.errorMessages = new ErrorMessages();
  var DefaultFormatLocalization = {
    dateFormats: {
      LTS: "h:mm:ss T",
      LT: "h:mm T",
      L: "MM/dd/yyyy",
      LL: "MMMM d, yyyy",
      LLL: "MMMM d, yyyy h:mm T",
      LLLL: "dddd, MMMM d, yyyy h:mm T"
    },
    format: "L LT",
    locale: "default",
    hourCycle: void 0,
    ordinal: (n4) => {
      const s4 = ["th", "st", "nd", "rd"];
      const v4 = n4 % 100;
      return `[${n4}${s4[(v4 - 20) % 10] || s4[v4] || s4[0]}]`;
    }
  };
  var DefaultFormatLocalization$1 = { ...DefaultFormatLocalization };
  var Unit;
  (function(Unit2) {
    Unit2["seconds"] = "seconds";
    Unit2["minutes"] = "minutes";
    Unit2["hours"] = "hours";
    Unit2["date"] = "date";
    Unit2["month"] = "month";
    Unit2["year"] = "year";
  })(Unit || (Unit = {}));
  var twoDigitTemplate = {
    month: "2-digit",
    day: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  };
  var getFormatByUnit = (unit) => {
    switch (unit) {
      case "date":
        return { dateStyle: "short" };
      case "month":
        return {
          month: "numeric",
          year: "numeric"
        };
      case "year":
        return { year: "numeric" };
    }
  };
  var guessHourCycle = (locale2) => {
    if (!locale2)
      return "h12";
    const template = {
      hour: "2-digit",
      minute: "2-digit",
      numberingSystem: "latn"
    };
    const dt2 = new DateTime().setLocalization({ locale: locale2 });
    dt2.hours = 0;
    const start4 = dt2.parts(void 0, template).hour;
    if (start4 === "12")
      return "h12";
    if (start4 === "24")
      return "h24";
    dt2.hours = 23;
    const end3 = dt2.parts(void 0, template).hour;
    if (start4 === "00" && end3 === "11")
      return "h11";
    if (start4 === "00" && end3 === "23")
      return "h23";
    console.warn(`couldn't determine hour cycle for ${locale2}. start: ${start4}. end: ${end3}`);
    return void 0;
  };
  var DateTime = class _DateTime extends Date {
    constructor() {
      super(...arguments);
      this.localization = DefaultFormatLocalization$1;
      this.nonLeapLadder = [
        0,
        31,
        59,
        90,
        120,
        151,
        181,
        212,
        243,
        273,
        304,
        334
      ];
      this.leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      this.dateTimeRegex = //is regex cannot be simplified beyond what it already is
      /(\[[^[\]]*])|y{1,4}|M{1,4}|d{1,4}|H{1,2}|h{1,2}|t|T|m{1,2}|s{1,2}|f{3}/g;
      this.formattingTokens = /(\[[^[\]]*])|([-_:/.,()\s]+)|(T|t|yyyy|yy?|MM?M?M?|Do|dd?d?d?|hh?|HH?|mm?|ss?)/g;
      this.match2 = /\d\d/;
      this.match3 = /\d{3}/;
      this.match4 = /\d{4}/;
      this.match1to2 = /\d\d?/;
      this.matchSigned = /[+-]?\d+/;
      this.matchOffset = /[+-]\d\d:?(\d\d)?|Z/;
      this.matchWord = /[^\d_:/,\-()\s]+/;
      this.zoneExpressions = [
        this.matchOffset,
        (obj, input) => {
          obj.offset = this.offsetFromString(input);
        }
      ];
      this.expressions = {
        t: {
          pattern: void 0,
          parser: (obj, input) => {
            obj.afternoon = this.meridiemMatch(input);
          }
        },
        T: {
          pattern: void 0,
          parser: (obj, input) => {
            obj.afternoon = this.meridiemMatch(input);
          }
        },
        fff: {
          pattern: this.match3,
          parser: (obj, input) => {
            obj.milliseconds = +input;
          }
        },
        s: {
          pattern: this.match1to2,
          parser: this.addInput("seconds")
        },
        ss: {
          pattern: this.match1to2,
          parser: this.addInput("seconds")
        },
        m: {
          pattern: this.match1to2,
          parser: this.addInput("minutes")
        },
        mm: {
          pattern: this.match1to2,
          parser: this.addInput("minutes")
        },
        H: {
          pattern: this.match1to2,
          parser: this.addInput("hours")
        },
        h: {
          pattern: this.match1to2,
          parser: this.addInput("hours")
        },
        HH: {
          pattern: this.match1to2,
          parser: this.addInput("hours")
        },
        hh: {
          pattern: this.match1to2,
          parser: this.addInput("hours")
        },
        d: {
          pattern: this.match1to2,
          parser: this.addInput("day")
        },
        dd: {
          pattern: this.match2,
          parser: this.addInput("day")
        },
        Do: {
          pattern: this.matchWord,
          parser: (obj, input) => {
            obj.day = +(input.match(/\d+/)[0] || 1);
            if (!this.localization.ordinal)
              return;
            for (let i4 = 1; i4 <= 31; i4 += 1) {
              if (this.localization.ordinal(i4).replace(/[[\]]/g, "") === input) {
                obj.day = i4;
              }
            }
          }
        },
        M: {
          pattern: this.match1to2,
          parser: this.addInput("month")
        },
        MM: {
          pattern: this.match2,
          parser: this.addInput("month")
        },
        MMM: {
          pattern: this.matchWord,
          parser: (obj, input) => {
            const months = this.getAllMonths();
            const monthsShort = this.getAllMonths("short");
            const matchIndex = (monthsShort || months.map((_4) => _4.slice(0, 3))).indexOf(input) + 1;
            if (matchIndex < 1) {
              throw new Error();
            }
            obj.month = matchIndex % 12 || matchIndex;
          }
        },
        MMMM: {
          pattern: this.matchWord,
          parser: (obj, input) => {
            const months = this.getAllMonths();
            const matchIndex = months.indexOf(input) + 1;
            if (matchIndex < 1) {
              throw new Error();
            }
            obj.month = matchIndex % 12 || matchIndex;
          }
        },
        y: {
          pattern: this.matchSigned,
          parser: this.addInput("year")
        },
        yy: {
          pattern: this.match2,
          parser: (obj, input) => {
            obj.year = this.parseTwoDigitYear(+input);
          }
        },
        yyyy: {
          pattern: this.match4,
          parser: this.addInput("year")
        }
        // z: this.zoneExpressions,
        // zz: this.zoneExpressions,
        // zzz: this.zoneExpressions
      };
    }
    /**
     * Chainable way to set the {@link locale}
     * @param value
     * @deprecated use setLocalization with a FormatLocalization object instead
     */
    setLocale(value) {
      if (!this.localization) {
        this.localization = DefaultFormatLocalization$1;
        this.localization.locale = value;
      }
      return this;
    }
    /**
     * Chainable way to set the {@link localization}
     * @param value
     */
    setLocalization(value) {
      this.localization = value;
      return this;
    }
    /**
     * Converts a plain JS date object to a DateTime object.
     * Doing this allows access to format, etc.
     * @param  date
     * @param locale this parameter is deprecated. Use formatLocalization instead.
     * @param formatLocalization
     */
    static convert(date, locale2 = "default", formatLocalization = void 0) {
      if (!date)
        throw new Error(`A date is required`);
      if (!formatLocalization) {
        formatLocalization = DefaultFormatLocalization$1;
        formatLocalization.locale = locale2;
      }
      return new _DateTime(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()).setLocalization(formatLocalization);
    }
    /**
     * Native date manipulations are not pure functions. This function creates a duplicate of the DateTime object.
     */
    get clone() {
      return new _DateTime(this.year, this.month, this.date, this.hours, this.minutes, this.seconds, this.getMilliseconds()).setLocalization(this.localization);
    }
    static isValid(d4) {
      if (d4 === void 0 || JSON.stringify(d4) === "null")
        return false;
      if (d4.constructor.name === _DateTime.name)
        return true;
      return false;
    }
    /**
     * Sets the current date to the start of the {@link unit} provided
     * Example: Consider a date of "April 30, 2021, 11:45:32.984 AM" => new DateTime(2021, 3, 30, 11, 45, 32, 984).startOf('month')
     * would return April 1, 2021, 12:00:00.000 AM (midnight)
     * @param unit
     * @param startOfTheWeek Allows for the changing the start of the week.
     */
    startOf(unit, startOfTheWeek = 0) {
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      switch (unit) {
        case "seconds":
          this.setMilliseconds(0);
          break;
        case "minutes":
          this.setSeconds(0, 0);
          break;
        case "hours":
          this.setMinutes(0, 0, 0);
          break;
        case "date":
          this.setHours(0, 0, 0, 0);
          break;
        case "weekDay": {
          this.startOf(Unit.date);
          if (this.weekDay === startOfTheWeek)
            break;
          const goBack = (this.weekDay - startOfTheWeek + 7) % 7;
          this.manipulate(goBack * -1, Unit.date);
          break;
        }
        case "month":
          this.startOf(Unit.date);
          this.setDate(1);
          break;
        case "year":
          this.startOf(Unit.date);
          this.setMonth(0, 1);
          break;
      }
      return this;
    }
    /**
     * Sets the current date to the end of the {@link unit} provided
     * Example: Consider a date of "April 30, 2021, 11:45:32.984 AM" => new DateTime(2021, 3, 30, 11, 45, 32, 984).endOf('month')
     * would return April 30, 2021, 11:59:59.999 PM
     * @param unit
     * @param startOfTheWeek
     */
    endOf(unit, startOfTheWeek = 0) {
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      switch (unit) {
        case "seconds":
          this.setMilliseconds(999);
          break;
        case "minutes":
          this.setSeconds(59, 999);
          break;
        case "hours":
          this.setMinutes(59, 59, 999);
          break;
        case "date":
          this.setHours(23, 59, 59, 999);
          break;
        case "weekDay": {
          this.endOf(Unit.date);
          const endOfWeek = 6 + startOfTheWeek;
          if (this.weekDay === endOfWeek)
            break;
          this.manipulate(endOfWeek - this.weekDay, Unit.date);
          break;
        }
        case "month":
          this.endOf(Unit.date);
          this.manipulate(1, Unit.month);
          this.setDate(0);
          break;
        case "year":
          this.endOf(Unit.date);
          this.setMonth(11, 31);
          break;
      }
      return this;
    }
    /**
     * Change a {@link unit} value. Value can be positive or negative
     * Example: Consider a date of "April 30, 2021, 11:45:32.984 AM" => new DateTime(2021, 3, 30, 11, 45, 32, 984).manipulate(1, 'month')
     * would return May 30, 2021, 11:45:32.984 AM
     * @param value A positive or negative number
     * @param unit
     */
    manipulate(value, unit) {
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      this[unit] += value;
      return this;
    }
    /**
     * Return true if {@link compare} is before this date
     * @param compare The Date/DateTime to compare
     * @param unit If provided, uses {@link startOf} for
     * comparison.
     */
    isBefore(compare, unit) {
      if (!_DateTime.isValid(compare))
        return false;
      if (!unit)
        return this.valueOf() < compare.valueOf();
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      return this.clone.startOf(unit).valueOf() < compare.clone.startOf(unit).valueOf();
    }
    /**
     * Return true if {@link compare} is after this date
     * @param compare The Date/DateTime to compare
     * @param unit If provided, uses {@link startOf} for
     * comparison.
     */
    isAfter(compare, unit) {
      if (!_DateTime.isValid(compare))
        return false;
      if (!unit)
        return this.valueOf() > compare.valueOf();
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      return this.clone.startOf(unit).valueOf() > compare.clone.startOf(unit).valueOf();
    }
    /**
     * Return true if {@link compare} is same this date
     * @param compare The Date/DateTime to compare
     * @param unit If provided, uses {@link startOf} for
     * comparison.
     */
    isSame(compare, unit) {
      if (!_DateTime.isValid(compare))
        return false;
      if (!unit)
        return this.valueOf() === compare.valueOf();
      if (this[unit] === void 0)
        throw new Error(`Unit '${unit}' is not valid`);
      compare = _DateTime.convert(compare);
      return this.clone.startOf(unit).valueOf() === compare.startOf(unit).valueOf();
    }
    /**
     * Check if this is between two other DateTimes, optionally looking at unit scale. The match is exclusive.
     * @param left
     * @param right
     * @param unit.
     * @param inclusivity. A [ indicates inclusion of a value. A ( indicates exclusion.
     * If the inclusivity parameter is used, both indicators must be passed.
     */
    isBetween(left3, right3, unit, inclusivity = "()") {
      if (!_DateTime.isValid(left3) || !_DateTime.isValid(right3))
        return false;
      if (unit && this[unit] === void 0) {
        throw new Error(`Unit '${unit}' is not valid`);
      }
      const leftInclusivity = inclusivity[0] === "(";
      const rightInclusivity = inclusivity[1] === ")";
      const isLeftInRange = leftInclusivity ? this.isAfter(left3, unit) : !this.isBefore(left3, unit);
      const isRightInRange = rightInclusivity ? this.isBefore(right3, unit) : !this.isAfter(right3, unit);
      return isLeftInRange && isRightInRange;
    }
    /**
     * Returns flattened object of the date. Does not include literals
     * @param locale
     * @param template
     */
    parts(locale2 = this.localization.locale, template = { dateStyle: "full", timeStyle: "long" }) {
      const parts = {};
      new Intl.DateTimeFormat(locale2, template).formatToParts(this).filter((x4) => x4.type !== "literal").forEach((x4) => parts[x4.type] = x4.value);
      return parts;
    }
    /**
     * Shortcut to Date.getSeconds()
     */
    get seconds() {
      return this.getSeconds();
    }
    /**
     * Shortcut to Date.setSeconds()
     */
    set seconds(value) {
      this.setSeconds(value);
    }
    /**
     * Returns two digit hours
     */
    get secondsFormatted() {
      return this.parts(void 0, twoDigitTemplate).second;
    }
    /**
     * Shortcut to Date.getMinutes()
     */
    get minutes() {
      return this.getMinutes();
    }
    /**
     * Shortcut to Date.setMinutes()
     */
    set minutes(value) {
      this.setMinutes(value);
    }
    /**
     * Returns two digit minutes
     */
    get minutesFormatted() {
      return this.parts(void 0, twoDigitTemplate).minute;
    }
    /**
     * Shortcut to Date.getHours()
     */
    get hours() {
      return this.getHours();
    }
    /**
     * Shortcut to Date.setHours()
     */
    set hours(value) {
      this.setHours(value);
    }
    /**
     * Returns two digit hour, e.g. 01...10
     * @param hourCycle Providing an hour cycle will change 00 to 24 depending on the given value.
     */
    getHoursFormatted(hourCycle = "h12") {
      return this.parts(void 0, { ...twoDigitTemplate, hourCycle }).hour;
    }
    /**
     * Get the meridiem of the date. E.g. AM or PM.
     * If the {@link locale} provides a "dayPeriod" then this will be returned,
     * otherwise it will return AM or PM.
     * @param locale
     */
    meridiem(locale2 = this.localization.locale) {
      return new Intl.DateTimeFormat(locale2, {
        hour: "numeric",
        hour12: true
      }).formatToParts(this).find((p4) => p4.type === "dayPeriod")?.value;
    }
    /**
     * Shortcut to Date.getDate()
     */
    get date() {
      return this.getDate();
    }
    /**
     * Shortcut to Date.setDate()
     */
    set date(value) {
      this.setDate(value);
    }
    /**
     * Return two digit date
     */
    get dateFormatted() {
      return this.parts(void 0, twoDigitTemplate).day;
    }
    /**
     * Shortcut to Date.getDay()
     */
    get weekDay() {
      return this.getDay();
    }
    /**
     * Shortcut to Date.getMonth()
     */
    get month() {
      return this.getMonth();
    }
    /**
     * Shortcut to Date.setMonth()
     */
    set month(value) {
      const targetMonth = new Date(this.year, value + 1);
      targetMonth.setDate(0);
      const endOfMonth = targetMonth.getDate();
      if (this.date > endOfMonth) {
        this.date = endOfMonth;
      }
      this.setMonth(value);
    }
    /**
     * Return two digit, human expected month. E.g. January = 1, December = 12
     */
    get monthFormatted() {
      return this.parts(void 0, twoDigitTemplate).month;
    }
    /**
     * Shortcut to Date.getFullYear()
     */
    get year() {
      return this.getFullYear();
    }
    /**
     * Shortcut to Date.setFullYear()
     */
    set year(value) {
      this.setFullYear(value);
    }
    // borrowed a bunch of stuff from Luxon
    /**
     * Gets the week of the year
     */
    get week() {
      const ordinal = this.computeOrdinal(), weekday = this.getUTCDay();
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7);
      if (weekNumber < 1) {
        weekNumber = this.weeksInWeekYear();
      } else if (weekNumber > this.weeksInWeekYear()) {
        weekNumber = 1;
      }
      return weekNumber;
    }
    /**
     * Returns the number of weeks in the year
     */
    weeksInWeekYear() {
      const p1 = (this.year + Math.floor(this.year / 4) - Math.floor(this.year / 100) + Math.floor(this.year / 400)) % 7, last = this.year - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p22 === 3 ? 53 : 52;
    }
    dateToDataValue() {
      if (!_DateTime.isValid(this))
        return "";
      return `${this.year}-${this.month.toString().padStart(2, "0")}-${this.date.toString().padStart(2, "0")}`;
    }
    /**
     * Returns true or false depending on if the year is a leap year or not.
     */
    get isLeapYear() {
      return this.year % 4 === 0 && (this.year % 100 !== 0 || this.year % 400 === 0);
    }
    computeOrdinal() {
      return this.date + (this.isLeapYear ? this.leapLadder : this.nonLeapLadder)[this.month];
    }
    /**
     * Returns a list of month values based on the current locale
     */
    getAllMonths(format2 = "long") {
      const applyFormat = new Intl.DateTimeFormat(this.localization.locale, {
        month: format2
      }).format;
      return [...Array(12).keys()].map((m4) => applyFormat(new Date(2021, m4)));
    }
    /**
     * Replaces an expanded token set (e.g. LT/LTS)
     */
    replaceTokens(formatStr, formats) {
      return formatStr.replace(/(\[[^[\]]*])|(LTS?|l{1,4}|L{1,4})/g, (_4, a4, b4) => {
        const B4 = b4 && b4.toUpperCase();
        return a4 || formats[B4] || DefaultFormatLocalization$1.dateFormats[B4];
      });
    }
    parseTwoDigitYear(input) {
      return input + (input > 68 ? 1900 : 2e3);
    }
    offsetFromString(input) {
      if (!input)
        return 0;
      if (input === "Z")
        return 0;
      const [first, second, third] = input.match(/([+-]|\d\d)/g);
      const minutes = +second * 60 + (+third || 0);
      const signed = first === "+" ? -minutes : minutes;
      return minutes === 0 ? 0 : signed;
    }
    /**
     * z = -4, zz = -04, zzz = -0400
     * @param date
     * @param style
     * @private
     */
    zoneInformation(date, style) {
      let name = date.parts(this.localization.locale, { timeZoneName: "longOffset" }).timeZoneName.replace("GMT", "").replace(":", "");
      const negative = name.includes("-");
      name = name.replace("-", "");
      if (style === "z")
        name = name.substring(1, 2);
      else if (style === "zz")
        name = name.substring(0, 2);
      return `${negative ? "-" : ""}${name}`;
    }
    addInput(property) {
      return (obj, input) => {
        obj[property] = +input;
      };
    }
    getLocaleAfternoon() {
      return new Intl.DateTimeFormat(this.localization.locale, {
        hour: "numeric",
        hour12: true
      }).formatToParts(new Date(2022, 3, 4, 13)).find((p4) => p4.type === "dayPeriod")?.value?.replace(/\s+/g, " ");
    }
    meridiemMatch(input) {
      return input.toLowerCase() === this.getLocaleAfternoon().toLowerCase();
    }
    correctHours(time) {
      const { afternoon } = time;
      if (afternoon !== void 0) {
        const { hours } = time;
        if (afternoon) {
          if (hours < 12) {
            time.hours += 12;
          }
        } else if (hours === 12) {
          time.hours = 0;
        }
        delete time.afternoon;
      }
    }
    makeParser(format2) {
      format2 = this.replaceTokens(format2, this.localization.dateFormats);
      const matchArray = format2.match(this.formattingTokens);
      const { length } = matchArray;
      const expressionArray = [];
      for (let i4 = 0; i4 < length; i4 += 1) {
        const token = matchArray[i4];
        const expression = this.expressions[token];
        if (expression?.parser) {
          expressionArray[i4] = expression;
        } else {
          expressionArray[i4] = token.replace(/^\[[^[\]]*]$/g, "");
        }
      }
      return (input) => {
        const time = {
          hours: 0,
          minutes: 0,
          seconds: 0,
          milliseconds: 0
        };
        for (let i4 = 0, start4 = 0; i4 < length; i4 += 1) {
          const token = expressionArray[i4];
          if (typeof token === "string") {
            start4 += token.length;
          } else {
            const part = input.slice(start4);
            let value = part;
            if (token.pattern) {
              const match2 = token.pattern.exec(part);
              value = match2[0];
            }
            token.parser.call(this, time, value);
            input = input.replace(value, "");
          }
        }
        this.correctHours(time);
        return time;
      };
    }
    /**
     * Attempts to create a DateTime from a string.
     * @param input date as string
     * @param localization provides the date template the string is in via the format property
     */
    //eslint-disable-next-line @typescript-eslint/no-unused-vars
    static fromString(input, localization) {
      if (!localization?.format) {
        Namespace.errorMessages.customDateFormatError("No format was provided");
      }
      try {
        const dt2 = new _DateTime();
        dt2.setLocalization(localization);
        if (["x", "X"].indexOf(localization.format) > -1)
          return new _DateTime((localization.format === "X" ? 1e3 : 1) * +input);
        input = input.replace(/\s+/g, " ");
        const parser = dt2.makeParser(localization.format);
        const { year, month, day, hours, minutes, seconds, milliseconds, zone } = parser(input);
        const d4 = day || (!year && !month ? dt2.getDate() : 1);
        const y4 = year || dt2.getFullYear();
        let M4 = 0;
        if (!(year && !month)) {
          M4 = month > 0 ? month - 1 : dt2.getMonth();
        }
        if (zone) {
          return new _DateTime(Date.UTC(y4, M4, d4, hours, minutes, seconds, milliseconds + zone.offset * 60 * 1e3));
        }
        return new _DateTime(y4, M4, d4, hours, minutes, seconds, milliseconds);
      } catch (e4) {
        Namespace.errorMessages.customDateFormatError(`Unable to parse provided input: ${input}, format: ${localization.format}`);
      }
    }
    /**
     * Returns a string format.
     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat
     * for valid templates and locale objects
     * @param template An optional object. If provided, method will use Intl., otherwise the localizations format properties
     * @param locale Can be a string or an array of strings. Uses browser defaults otherwise.
     */
    format(template, locale2 = this.localization.locale) {
      if (template && typeof template === "object")
        return new Intl.DateTimeFormat(locale2, template).format(this);
      const formatString = this.replaceTokens(
        //try template first
        template || //otherwise try localization format
        this.localization.format || //otherwise try date + time
        `${DefaultFormatLocalization$1.dateFormats.L}, ${DefaultFormatLocalization$1.dateFormats.LT}`,
        this.localization.dateFormats
      );
      const formatter = (template2) => new Intl.DateTimeFormat(this.localization.locale, template2).format(this);
      if (!this.localization.hourCycle)
        this.localization.hourCycle = guessHourCycle(this.localization.locale);
      const HHCycle = this.localization.hourCycle.startsWith("h1") ? "h24" : this.localization.hourCycle;
      const hhCycle = this.localization.hourCycle.startsWith("h2") ? "h12" : this.localization.hourCycle;
      const matches = {
        y: this.year,
        yy: formatter({ year: "2-digit" }),
        yyyy: this.year,
        M: formatter({ month: "numeric" }),
        MM: this.monthFormatted,
        MMM: this.getAllMonths("short")[this.getMonth()],
        MMMM: this.getAllMonths()[this.getMonth()],
        d: this.date,
        dd: this.dateFormatted,
        ddd: formatter({ weekday: "short" }),
        dddd: formatter({ weekday: "long" }),
        H: this.getHours(),
        HH: this.getHoursFormatted(HHCycle),
        h: this.hours > 12 ? this.hours - 12 : this.hours,
        hh: this.getHoursFormatted(hhCycle),
        t: this.meridiem(),
        T: this.meridiem().toUpperCase(),
        m: this.minutes,
        mm: this.minutesFormatted,
        s: this.seconds,
        ss: this.secondsFormatted,
        fff: this.getMilliseconds()
        // z: this.zoneInformation(dateTime, 'z'), //-4
        // zz: this.zoneInformation(dateTime, 'zz'), //-04
        // zzz: this.zoneInformation(dateTime, 'zzz') //-0400
      };
      return formatString.replace(this.dateTimeRegex, (match2, $1) => {
        return $1 || matches[match2];
      }).replace(/\[/g, "").replace(/]/g, "");
    }
  };
  var ServiceLocator = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    locate(identifier) {
      const service = this.cache.get(identifier);
      if (service)
        return service;
      const value = new identifier();
      this.cache.set(identifier, value);
      return value;
    }
  };
  var setupServiceLocator = () => {
    serviceLocator = new ServiceLocator();
  };
  var serviceLocator;
  var CalendarModes = [
    {
      name: "calendar",
      className: Namespace.css.daysContainer,
      unit: Unit.month,
      step: 1
    },
    {
      name: "months",
      className: Namespace.css.monthsContainer,
      unit: Unit.year,
      step: 1
    },
    {
      name: "years",
      className: Namespace.css.yearsContainer,
      unit: Unit.year,
      step: 10
    },
    {
      name: "decades",
      className: Namespace.css.decadesContainer,
      unit: Unit.year,
      step: 100
    }
  ];
  var OptionsStore = class {
    constructor() {
      this._currentCalendarViewMode = 0;
      this._viewDate = new DateTime();
      this.minimumCalendarViewMode = 0;
      this.currentView = "calendar";
    }
    get currentCalendarViewMode() {
      return this._currentCalendarViewMode;
    }
    set currentCalendarViewMode(value) {
      this._currentCalendarViewMode = value;
      this.currentView = CalendarModes[value].name;
    }
    get viewDate() {
      return this._viewDate;
    }
    set viewDate(v4) {
      this._viewDate = v4;
      if (this.options)
        this.options.viewDate = v4;
    }
    /**
     * When switching back to the calendar from the clock,
     * this sets currentView to the correct calendar view.
     */
    refreshCurrentView() {
      this.currentView = CalendarModes[this.currentCalendarViewMode].name;
    }
    get isTwelveHour() {
      return ["h12", "h11"].includes(this.options.localization.hourCycle);
    }
  };
  var Validation = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
    }
    /**
     * Checks to see if the target date is valid based on the rules provided in the options.
     * Granularity can be provided to check portions of the date instead of the whole.
     * @param targetDate
     * @param granularity
     */
    isValid(targetDate, granularity) {
      if (!this._enabledDisabledDatesIsValid(granularity, targetDate))
        return false;
      if (granularity !== Unit.month && granularity !== Unit.year && this.optionsStore.options.restrictions.daysOfWeekDisabled?.length > 0 && this.optionsStore.options.restrictions.daysOfWeekDisabled.indexOf(targetDate.weekDay) !== -1)
        return false;
      if (!this._minMaxIsValid(granularity, targetDate))
        return false;
      if (granularity === Unit.hours || granularity === Unit.minutes || granularity === Unit.seconds) {
        if (!this._enabledDisabledHoursIsValid(targetDate))
          return false;
        if (this.optionsStore.options.restrictions.disabledTimeIntervals?.filter((internal) => targetDate.isBetween(internal.from, internal.to)).length !== 0)
          return false;
      }
      return true;
    }
    _enabledDisabledDatesIsValid(granularity, targetDate) {
      if (granularity !== Unit.date)
        return true;
      if (this.optionsStore.options.restrictions.disabledDates.length > 0 && this._isInDisabledDates(targetDate)) {
        return false;
      }
      if (this.optionsStore.options.restrictions.enabledDates.length > 0 && !this._isInEnabledDates(targetDate)) {
        return false;
      }
      return true;
    }
    /**
     * Checks to see if the disabledDates option is in use and returns true (meaning invalid)
     * if the `testDate` is with in the array. Granularity is by date.
     * @param testDate
     * @private
     */
    _isInDisabledDates(testDate) {
      if (!this.optionsStore.options.restrictions.disabledDates || this.optionsStore.options.restrictions.disabledDates.length === 0)
        return false;
      return !!this.optionsStore.options.restrictions.disabledDates.find((x4) => x4.isSame(testDate, Unit.date));
    }
    /**
     * Checks to see if the enabledDates option is in use and returns true (meaning valid)
     * if the `testDate` is with in the array. Granularity is by date.
     * @param testDate
     * @private
     */
    _isInEnabledDates(testDate) {
      if (!this.optionsStore.options.restrictions.enabledDates || this.optionsStore.options.restrictions.enabledDates.length === 0)
        return true;
      return !!this.optionsStore.options.restrictions.enabledDates.find((x4) => x4.isSame(testDate, Unit.date));
    }
    _minMaxIsValid(granularity, targetDate) {
      if (this.optionsStore.options.restrictions.minDate && targetDate.isBefore(this.optionsStore.options.restrictions.minDate, granularity)) {
        return false;
      }
      if (this.optionsStore.options.restrictions.maxDate && targetDate.isAfter(this.optionsStore.options.restrictions.maxDate, granularity)) {
        return false;
      }
      return true;
    }
    _enabledDisabledHoursIsValid(targetDate) {
      if (this.optionsStore.options.restrictions.disabledHours.length > 0 && this._isInDisabledHours(targetDate)) {
        return false;
      }
      if (this.optionsStore.options.restrictions.enabledHours.length > 0 && !this._isInEnabledHours(targetDate)) {
        return false;
      }
      return true;
    }
    /**
     * Checks to see if the disabledHours option is in use and returns true (meaning invalid)
     * if the `testDate` is with in the array. Granularity is by hours.
     * @param testDate
     * @private
     */
    _isInDisabledHours(testDate) {
      if (!this.optionsStore.options.restrictions.disabledHours || this.optionsStore.options.restrictions.disabledHours.length === 0)
        return false;
      const formattedDate = testDate.hours;
      return this.optionsStore.options.restrictions.disabledHours.includes(formattedDate);
    }
    /**
     * Checks to see if the enabledHours option is in use and returns true (meaning valid)
     * if the `testDate` is with in the array. Granularity is by hours.
     * @param testDate
     * @private
     */
    _isInEnabledHours(testDate) {
      if (!this.optionsStore.options.restrictions.enabledHours || this.optionsStore.options.restrictions.enabledHours.length === 0)
        return true;
      const formattedDate = testDate.hours;
      return this.optionsStore.options.restrictions.enabledHours.includes(formattedDate);
    }
    dateRangeIsValid(dates, index, target) {
      if (!this.optionsStore.options.dateRange)
        return true;
      if (dates.length !== 2 && index !== 1)
        return true;
      const start4 = dates[0].clone;
      if (start4.isSame(target, Unit.date))
        return true;
      start4.manipulate(1, Unit.date);
      while (!start4.isSame(target, Unit.date)) {
        const valid = this.isValid(start4, Unit.date);
        if (!valid)
          return false;
        start4.manipulate(1, Unit.date);
      }
      return true;
    }
  };
  var EventEmitter = class {
    constructor() {
      this.subscribers = [];
    }
    subscribe(callback) {
      this.subscribers.push(callback);
      return this.unsubscribe.bind(this, this.subscribers.length - 1);
    }
    unsubscribe(index) {
      this.subscribers.splice(index, 1);
    }
    emit(value) {
      this.subscribers.forEach((callback) => {
        callback(value);
      });
    }
    destroy() {
      this.subscribers = null;
      this.subscribers = [];
    }
  };
  var EventEmitters = class {
    constructor() {
      this.triggerEvent = new EventEmitter();
      this.viewUpdate = new EventEmitter();
      this.updateDisplay = new EventEmitter();
      this.action = new EventEmitter();
      this.updateViewDate = new EventEmitter();
    }
    destroy() {
      this.triggerEvent.destroy();
      this.viewUpdate.destroy();
      this.updateDisplay.destroy();
      this.action.destroy();
      this.updateViewDate.destroy();
    }
  };
  var defaultEnLocalization = {
    clear: "Clear selection",
    close: "Close the picker",
    dateFormats: DefaultFormatLocalization$1.dateFormats,
    dayViewHeaderFormat: { month: "long", year: "2-digit" },
    decrementHour: "Decrement Hour",
    decrementMinute: "Decrement Minute",
    decrementSecond: "Decrement Second",
    format: DefaultFormatLocalization$1.format,
    hourCycle: DefaultFormatLocalization$1.hourCycle,
    incrementHour: "Increment Hour",
    incrementMinute: "Increment Minute",
    incrementSecond: "Increment Second",
    locale: DefaultFormatLocalization$1.locale,
    maxWeekdayLength: 0,
    nextCentury: "Next Century",
    nextDecade: "Next Decade",
    nextMonth: "Next Month",
    nextYear: "Next Year",
    ordinal: DefaultFormatLocalization$1.ordinal,
    pickHour: "Pick Hour",
    pickMinute: "Pick Minute",
    pickSecond: "Pick Second",
    previousCentury: "Previous Century",
    previousDecade: "Previous Decade",
    previousMonth: "Previous Month",
    previousYear: "Previous Year",
    selectDate: "Select Date",
    selectDecade: "Select Decade",
    selectMonth: "Select Month",
    selectTime: "Select Time",
    selectYear: "Select Year",
    startOfTheWeek: 0,
    today: "Go to today",
    toggleMeridiem: "Toggle Meridiem",
    toggleAriaLabel: "Change date"
  };
  var DefaultOptions = {
    allowInputToggle: false,
    container: void 0,
    dateRange: false,
    debug: false,
    defaultDate: void 0,
    display: {
      icons: {
        type: "icons",
        time: "fa-solid fa-clock",
        date: "fa-solid fa-calendar",
        up: "fa-solid fa-arrow-up",
        down: "fa-solid fa-arrow-down",
        previous: "fa-solid fa-chevron-left",
        next: "fa-solid fa-chevron-right",
        today: "fa-solid fa-calendar-check",
        clear: "fa-solid fa-trash",
        close: "fa-solid fa-xmark"
      },
      sideBySide: false,
      calendarWeeks: false,
      viewMode: "calendar",
      toolbarPlacement: "bottom",
      keepOpen: false,
      buttons: {
        today: false,
        clear: false,
        close: false
      },
      components: {
        calendar: true,
        date: true,
        month: true,
        year: true,
        decades: true,
        clock: true,
        hours: true,
        minutes: true,
        seconds: false,
        useTwentyfourHour: void 0
      },
      inline: false,
      theme: "auto",
      placement: "bottom",
      keyboardNavigation: true
    },
    keepInvalid: false,
    localization: defaultEnLocalization,
    meta: {},
    multipleDates: false,
    multipleDatesSeparator: "; ",
    promptTimeOnDateChange: false,
    promptTimeOnDateChangeTransitionDelay: 200,
    restrictions: {
      minDate: void 0,
      maxDate: void 0,
      disabledDates: [],
      enabledDates: [],
      daysOfWeekDisabled: [],
      disabledTimeIntervals: [],
      disabledHours: [],
      enabledHours: []
    },
    stepping: 1,
    useCurrent: true,
    viewDate: new DateTime()
  };
  var DefaultEnLocalization = { ...defaultEnLocalization };
  function tryConvertToDateTime(d4, localization) {
    if (!d4)
      return null;
    if (d4.constructor.name === DateTime.name)
      return d4;
    if (d4.constructor.name === Date.name) {
      return DateTime.convert(d4);
    }
    if (typeof d4 === "string") {
      const dateTime = DateTime.fromString(d4, localization);
      if (JSON.stringify(dateTime) === "null") {
        return null;
      }
      return dateTime;
    }
    return null;
  }
  function convertToDateTime(d4, optionName, localization) {
    if (typeof d4 === "string" && optionName !== "input") {
      Namespace.errorMessages.dateString();
    }
    const converted = tryConvertToDateTime(d4, localization);
    if (!converted) {
      Namespace.errorMessages.failedToParseDate(optionName, d4, optionName === "input");
    }
    return converted;
  }
  function typeCheckDateArray(optionName, value, providedType, localization = DefaultFormatLocalization$1) {
    if (!Array.isArray(value)) {
      Namespace.errorMessages.typeMismatch(optionName, providedType, "array of DateTime or Date");
    }
    for (let i4 = 0; i4 < value.length; i4++) {
      const d4 = value[i4];
      const dateTime = convertToDateTime(d4, optionName, localization);
      dateTime.setLocalization(localization);
      value[i4] = dateTime;
    }
  }
  function typeCheckNumberArray(optionName, value, providedType) {
    if (!Array.isArray(value) || value.some((x4) => typeof x4 !== "number")) {
      Namespace.errorMessages.typeMismatch(optionName, providedType, "array of numbers");
    }
  }
  function mandatoryDate(key) {
    return ({ value, localization }) => {
      const dateTime = convertToDateTime(value, key, localization);
      if (dateTime !== void 0) {
        dateTime.setLocalization(localization);
        return dateTime;
      }
    };
  }
  function optionalDate(key) {
    const mandatory = mandatoryDate(key);
    return (args) => {
      if (args.value === void 0) {
        return args.value;
      }
      return mandatory(args);
    };
  }
  function numbersInRange(key, lower, upper) {
    return ({ value, providedType }) => {
      if (value === void 0) {
        return [];
      }
      typeCheckNumberArray(key, value, providedType);
      if (value.some((x4) => x4 < lower || x4 > upper))
        Namespace.errorMessages.numbersOutOfRange(key, lower, upper);
      return value;
    };
  }
  function validHourRange(key) {
    return numbersInRange(key, 0, 23);
  }
  function validDateArray(key) {
    return ({ value, providedType, localization }) => {
      if (value === void 0) {
        return [];
      }
      typeCheckDateArray(key, value, providedType, localization);
      return value;
    };
  }
  function validKeyOption(keyOptions) {
    return ({ value, path }) => {
      if (!keyOptions.includes(value))
        Namespace.errorMessages.unexpectedOptionValue(path.substring(1), value, keyOptions);
      return value;
    };
  }
  var optionProcessors = Object.freeze({
    defaultDate: mandatoryDate("defaultDate"),
    viewDate: mandatoryDate("viewDate"),
    minDate: optionalDate("restrictions.minDate"),
    maxDate: optionalDate("restrictions.maxDate"),
    disabledHours: validHourRange("restrictions.disabledHours"),
    enabledHours: validHourRange("restrictions.enabledHours"),
    disabledDates: validDateArray("restrictions.disabledDates"),
    enabledDates: validDateArray("restrictions.enabledDates"),
    daysOfWeekDisabled: numbersInRange("restrictions.daysOfWeekDisabled", 0, 6),
    disabledTimeIntervals: ({ key, value, providedType, localization }) => {
      if (value === void 0) {
        return [];
      }
      if (!Array.isArray(value)) {
        Namespace.errorMessages.typeMismatch(key, providedType, "array of { from: DateTime|Date, to: DateTime|Date }");
      }
      const valueObject = value;
      for (let i4 = 0; i4 < valueObject.length; i4++) {
        Object.keys(valueObject[i4]).forEach((vk) => {
          const subOptionName = `${key}[${i4}].${vk}`;
          const d4 = valueObject[i4][vk];
          const dateTime = convertToDateTime(d4, subOptionName, localization);
          dateTime.setLocalization(localization);
          valueObject[i4][vk] = dateTime;
        });
      }
      return valueObject;
    },
    toolbarPlacement: validKeyOption(["top", "bottom", "default"]),
    type: validKeyOption(["icons", "sprites"]),
    viewMode: validKeyOption([
      "clock",
      "calendar",
      "months",
      "years",
      "decades"
    ]),
    theme: validKeyOption(["light", "dark", "auto"]),
    placement: validKeyOption(["top", "bottom"]),
    meta: ({ value }) => value,
    dayViewHeaderFormat: ({ value }) => value,
    container: ({ value, path }) => {
      if (value && !(value instanceof HTMLElement || value instanceof Element || value?.appendChild)) {
        Namespace.errorMessages.typeMismatch(path.substring(1), typeof value, "HTMLElement");
      }
      return value;
    },
    useTwentyfourHour: ({ value, path, providedType, defaultType }) => {
      Namespace.errorMessages.deprecatedWarning("useTwentyfourHour", 'Please use "options.localization.hourCycle" instead');
      if (value === void 0 || providedType === "boolean")
        return value;
      Namespace.errorMessages.typeMismatch(path, providedType, defaultType);
    },
    hourCycle: validKeyOption(["h11", "h12", "h23", "h24"])
  });
  var defaultProcessor = ({ value, defaultType, providedType, path }) => {
    switch (defaultType) {
      case "boolean":
        return value === "true" || value === true;
      case "number":
        return +value;
      case "string":
        return value.toString();
      case "object":
        return {};
      case "function":
        return value;
      default:
        Namespace.errorMessages.typeMismatch(path, providedType, defaultType);
    }
  };
  function processKey(args) {
    return (optionProcessors[args.key] || defaultProcessor)(args);
  }
  var OptionConverter = class _OptionConverter {
    static deepCopy(input) {
      const o4 = {};
      Object.keys(input).forEach((key) => {
        const inputElement = input[key];
        if (inputElement instanceof DateTime) {
          o4[key] = inputElement.clone;
          return;
        } else if (inputElement instanceof Date) {
          o4[key] = new Date(inputElement.valueOf());
          return;
        }
        o4[key] = inputElement;
        if (typeof inputElement !== "object" || inputElement instanceof HTMLElement || inputElement instanceof Element)
          return;
        if (!Array.isArray(inputElement)) {
          o4[key] = _OptionConverter.deepCopy(inputElement);
        }
      });
      return o4;
    }
    /**
     * Finds value out of an object based on a string, period delimited, path
     * @param paths
     * @param obj
     */
    static objectPath(paths, obj) {
      if (paths.charAt(0) === ".")
        paths = paths.slice(1);
      if (!paths)
        return obj;
      return paths.split(".").reduce((value, key) => _OptionConverter.isValue(value) || _OptionConverter.isValue(value[key]) ? value[key] : void 0, obj);
    }
    /**
     * The spread operator caused sub keys to be missing after merging.
     * This is to fix that issue by using spread on the child objects first.
     * Also handles complex options like disabledDates
     * @param provided An option from new providedOptions
     * @param copyTo Destination object. This was added to prevent reference copies
     * @param localization
     * @param path
     */
    static spread(provided, copyTo, localization, path = "") {
      const defaultOptions4 = _OptionConverter.objectPath(path, DefaultOptions);
      const unsupportedOptions = Object.keys(provided).filter((x4) => !Object.keys(defaultOptions4).includes(x4));
      if (unsupportedOptions.length > 0) {
        const flattenedOptions = _OptionConverter.getFlattenDefaultOptions();
        const errors = unsupportedOptions.map((x4) => {
          const d4 = path ? "." : "";
          let error2 = `"${path}${d4}${x4}" is not a known option.`;
          const didYouMean = flattenedOptions.find((y4) => y4.includes(x4));
          if (didYouMean)
            error2 += ` Did you mean "${didYouMean}"?`;
          return error2;
        });
        Namespace.errorMessages.unexpectedOptions(errors);
      }
      Object.keys(provided).filter((key) => key !== "__proto__" && key !== "constructor").forEach((key) => {
        path += `.${key}`;
        if (path.charAt(0) === ".")
          path = path.slice(1);
        const defaultOptionValue = defaultOptions4[key];
        const providedType = typeof provided[key];
        const defaultType = typeof defaultOptionValue;
        const value = provided[key];
        if (value === void 0 || value === null) {
          copyTo[key] = value;
          path = path.substring(0, path.lastIndexOf(`.${key}`));
          return;
        }
        if (typeof defaultOptionValue === "object" && !Array.isArray(provided[key]) && !(defaultOptionValue instanceof Date || _OptionConverter.ignoreProperties.includes(key))) {
          _OptionConverter.spread(provided[key], copyTo[key], localization, path);
        } else {
          copyTo[key] = _OptionConverter.processKey(key, value, providedType, defaultType, path, localization);
        }
        path = path.substring(0, path.lastIndexOf(`.${key}`));
      });
    }
    static processKey(key, value, providedType, defaultType, path, localization) {
      return processKey({
        key,
        value,
        providedType,
        defaultType,
        path,
        localization
      });
    }
    static _mergeOptions(providedOptions, mergeTo) {
      const newConfig = _OptionConverter.deepCopy(mergeTo);
      const localization = mergeTo.localization?.locale !== "default" ? mergeTo.localization : providedOptions?.localization || DefaultOptions.localization;
      _OptionConverter.spread(providedOptions, newConfig, localization, "");
      return newConfig;
    }
    static _dataToOptions(element, options) {
      const eData = JSON.parse(JSON.stringify(element.dataset));
      if (eData?.tdTargetInput)
        delete eData.tdTargetInput;
      if (eData?.tdTargetToggle)
        delete eData.tdTargetToggle;
      if (!eData || Object.keys(eData).length === 0)
        return options;
      const dataOptions = {};
      const objectToNormalized = (object) => {
        const lowered = {};
        Object.keys(object).forEach((x4) => {
          lowered[x4.toLowerCase()] = x4;
        });
        return lowered;
      };
      const normalizeObject = this.normalizeObject(objectToNormalized);
      const optionsLower = objectToNormalized(options);
      Object.keys(eData).filter((x4) => x4.startsWith(Namespace.dataKey)).map((x4) => x4.substring(2)).forEach((key) => {
        let keyOption = optionsLower[key.toLowerCase()];
        if (key.includes("_")) {
          const split = key.split("_");
          keyOption = optionsLower[split[0].toLowerCase()];
          if (keyOption !== void 0 && options[keyOption].constructor === Object) {
            dataOptions[keyOption] = normalizeObject(split, 1, options[keyOption], eData[`td${key}`]);
          }
        } else if (keyOption !== void 0) {
          dataOptions[keyOption] = eData[`td${key}`];
        }
      });
      return this._mergeOptions(dataOptions, options);
    }
    //todo clean this up
    static normalizeObject(objectToNormalized) {
      const normalizeObject = (split, index, optionSubgroup, value) => {
        const normalizedOptions = objectToNormalized(optionSubgroup);
        const keyOption = normalizedOptions[split[index].toLowerCase()];
        const internalObject = {};
        if (keyOption === void 0)
          return internalObject;
        if (optionSubgroup[keyOption]?.constructor === Object) {
          index++;
          internalObject[keyOption] = normalizeObject(split, index, optionSubgroup[keyOption], value);
        } else {
          internalObject[keyOption] = value;
        }
        return internalObject;
      };
      return normalizeObject;
    }
    /**
     * Attempts to prove `d` is a DateTime or Date or can be converted into one.
     * @param d If a string will attempt creating a date from it.
     * @param localization object containing locale and format settings. Only used with the custom formats
     * @private
     */
    static _dateTypeCheck(d4, localization) {
      return tryConvertToDateTime(d4, localization);
    }
    /**
     * Type checks that `value` is an array of Date or DateTime
     * @param optionName Provides text to error messages e.g. disabledDates
     * @param value Option value
     * @param providedType Used to provide text to error messages
     * @param localization
     */
    static _typeCheckDateArray(optionName, value, providedType, localization) {
      return typeCheckDateArray(optionName, value, providedType, localization);
    }
    /**
     * Type checks that `value` is an array of numbers
     * @param optionName Provides text to error messages e.g. disabledDates
     * @param value Option value
     * @param providedType Used to provide text to error messages
     */
    static _typeCheckNumberArray(optionName, value, providedType) {
      return typeCheckNumberArray(optionName, value, providedType);
    }
    /**
     * Attempts to convert `d` to a DateTime object
     * @param d value to convert
     * @param optionName Provides text to error messages e.g. disabledDates
     * @param localization object containing locale and format settings. Only used with the custom formats
     */
    static dateConversion(d4, optionName, localization) {
      return convertToDateTime(d4, optionName, localization);
    }
    static getFlattenDefaultOptions() {
      if (this._flattenDefaults)
        return this._flattenDefaults;
      const deepKeys = (t5, pre = []) => {
        if (Array.isArray(t5))
          return [];
        if (Object(t5) === t5) {
          return Object.entries(t5).flatMap(([k4, v4]) => deepKeys(v4, [...pre, k4]));
        } else {
          return pre.join(".");
        }
      };
      this._flattenDefaults = deepKeys(DefaultOptions);
      return this._flattenDefaults;
    }
    /**
     * Some options conflict like min/max date. Verify that these kinds of options
     * are set correctly.
     * @param config
     */
    static _validateConflicts(config2) {
      if (config2.display.sideBySide && (!config2.display.components.clock || !(config2.display.components.hours || config2.display.components.minutes || config2.display.components.seconds))) {
        Namespace.errorMessages.conflictingConfiguration("Cannot use side by side mode without the clock components");
      }
      if (config2.restrictions.minDate && config2.restrictions.maxDate) {
        if (config2.restrictions.minDate.isAfter(config2.restrictions.maxDate)) {
          Namespace.errorMessages.conflictingConfiguration("minDate is after maxDate");
        }
        if (config2.restrictions.maxDate.isBefore(config2.restrictions.minDate)) {
          Namespace.errorMessages.conflictingConfiguration("maxDate is before minDate");
        }
      }
      if (config2.multipleDates && config2.dateRange) {
        Namespace.errorMessages.conflictingConfiguration('Cannot uss option "multipleDates" with "dateRange"');
      }
    }
  };
  OptionConverter.ignoreProperties = [
    "meta",
    "dayViewHeaderFormat",
    "container",
    "dateForms",
    "ordinal"
  ];
  OptionConverter.isValue = (a4) => a4 != null;
  var Dates = class {
    constructor() {
      this._dates = [];
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.validation = serviceLocator.locate(Validation);
      this._eventEmitters = serviceLocator.locate(EventEmitters);
    }
    /**
     * Returns the array of selected dates
     */
    get picked() {
      return [...this._dates];
    }
    /**
     * Returns the last picked value.
     */
    get lastPicked() {
      return this._dates[this.lastPickedIndex]?.clone;
    }
    /**
     * Returns the length of picked dates -1 or 0 if none are selected.
     */
    get lastPickedIndex() {
      if (this._dates.length === 0)
        return 0;
      return this._dates.length - 1;
    }
    /**
     * Formats a DateTime object to a string. Used when setting the input value.
     * @param date
     */
    formatInput(date) {
      if (!date)
        return "";
      date.localization = this.optionsStore.options.localization;
      return date.format();
    }
    /**
     * parse the value into a DateTime object.
     * this can be overwritten to supply your own parsing.
     */
    //eslint-disable-next-line @typescript-eslint/no-explicit-any
    parseInput(value) {
      try {
        return OptionConverter.dateConversion(value, "input", this.optionsStore.options.localization);
      } catch (e4) {
        this._eventEmitters.triggerEvent.emit({
          type: Namespace.events.error,
          reason: Namespace.errorMessages.failedToParseInput,
          format: this.optionsStore.options.localization.format,
          value
        });
        return void 0;
      }
    }
    /**
     * Tries to convert the provided value to a DateTime object.
     * If value is null|undefined then clear the value of the provided index (or 0).
     * @param value Value to convert or null|undefined
     * @param index When using multidates this is the index in the array
     */
    //eslint-disable-next-line @typescript-eslint/no-explicit-any
    setFromInput(value, index) {
      if (!value) {
        this.setValue(void 0, index);
        return;
      }
      const converted = this.parseInput(value);
      if (converted) {
        converted.setLocalization(this.optionsStore.options.localization);
        this.setValue(converted, index);
      }
    }
    /**
     * Adds a new DateTime to selected dates array
     * @param date
     */
    add(date) {
      this._dates.push(date);
    }
    /**
     * Returns true if the `targetDate` is part of the selected dates array.
     * If `unit` is provided then a granularity to that unit will be used.
     * @param targetDate
     * @param unit
     */
    isPicked(targetDate, unit) {
      if (!DateTime.isValid(targetDate))
        return false;
      if (!unit)
        return this._dates.find((x4) => x4.isSame(targetDate)) !== void 0;
      const format2 = getFormatByUnit(unit);
      const innerDateFormatted = targetDate.format(format2);
      return this._dates.map((x4) => x4.format(format2)).find((x4) => x4 === innerDateFormatted) !== void 0;
    }
    /**
     * Returns the index at which `targetDate` is in the array.
     * This is used for updating or removing a date when multi-date is used
     * If `unit` is provided then a granularity to that unit will be used.
     * @param targetDate
     * @param unit
     */
    pickedIndex(targetDate, unit) {
      if (!DateTime.isValid(targetDate))
        return -1;
      if (!unit)
        return this._dates.map((x4) => x4.valueOf()).indexOf(targetDate.valueOf());
      const format2 = getFormatByUnit(unit);
      const innerDateFormatted = targetDate.format(format2);
      return this._dates.map((x4) => x4.format(format2)).indexOf(innerDateFormatted);
    }
    /**
     * Clears all selected dates.
     */
    clear() {
      this.optionsStore.unset = true;
      this._eventEmitters.triggerEvent.emit({
        type: Namespace.events.change,
        date: void 0,
        oldDate: this.lastPicked,
        isClear: true,
        isValid: true
      });
      this._dates = [];
      if (this.optionsStore.input)
        this.optionsStore.input.value = "";
      this._eventEmitters.updateDisplay.emit("all");
    }
    /**
     * Find the "book end" years given a `year` and a `factor`
     * @param factor e.g. 100 for decades
     * @param year e.g. 2021
     */
    static getStartEndYear(factor, year) {
      const step = factor / 10, startYear = Math.floor(year / factor) * factor, endYear = startYear + step * 9, focusValue = Math.floor(year / step) * step;
      return [startYear, endYear, focusValue];
    }
    updateInput(target) {
      if (!this.optionsStore.input)
        return;
      let newValue = this.formatInput(target);
      if (this.optionsStore.options.multipleDates || this.optionsStore.options.dateRange) {
        newValue = this._dates.map((d4) => this.formatInput(d4)).join(this.optionsStore.options.multipleDatesSeparator);
      }
      if (this.optionsStore.input.value != newValue)
        this.optionsStore.input.value = newValue;
    }
    /**
     * Attempts to either clear or set the `target` date at `index`.
     * If the `target` is null then the date will be cleared.
     * If multi-date is being used then it will be removed from the array.
     * If `target` is valid and multi-date is used then if `index` is
     * provided the date at that index will be replaced, otherwise it is appended.
     * @param target
     * @param index
     */
    setValue(target, index) {
      const noIndex = typeof index === "undefined", isClear = !target && noIndex;
      let oldDate = this.optionsStore.unset ? null : this._dates[index]?.clone;
      if (!oldDate && !this.optionsStore.unset && noIndex && isClear) {
        oldDate = this.lastPicked;
      }
      if (target && oldDate?.isSame(target)) {
        this.updateInput(target);
        return;
      }
      if (!target) {
        this._setValueNull(isClear, index, oldDate);
        return;
      }
      index = index || 0;
      target = target.clone;
      if (this.optionsStore.options.stepping !== 1) {
        target.minutes = Math.round(target.minutes / this.optionsStore.options.stepping) * this.optionsStore.options.stepping;
        target.startOf(Unit.minutes);
      }
      const onUpdate = (isValid) => {
        this._dates[index] = target;
        this._eventEmitters.updateViewDate.emit(target.clone);
        this.updateInput(target);
        this.optionsStore.unset = false;
        this._eventEmitters.updateDisplay.emit("all");
        this._eventEmitters.triggerEvent.emit({
          type: Namespace.events.change,
          date: target,
          oldDate,
          isClear,
          isValid
        });
      };
      if (this.validation.isValid(target) && this.validation.dateRangeIsValid(this.picked, index, target)) {
        onUpdate(true);
        return;
      }
      if (this.optionsStore.options.keepInvalid) {
        onUpdate(false);
      }
      this._eventEmitters.triggerEvent.emit({
        type: Namespace.events.error,
        reason: Namespace.errorMessages.failedToSetInvalidDate,
        date: target,
        oldDate
      });
    }
    _setValueNull(isClear, index, oldDate) {
      if (!this.optionsStore.options.multipleDates || this._dates.length === 1 || isClear) {
        this.optionsStore.unset = true;
        this._dates = [];
      } else {
        this._dates.splice(index, 1);
      }
      this.updateInput();
      this._eventEmitters.triggerEvent.emit({
        type: Namespace.events.change,
        date: void 0,
        oldDate,
        isClear,
        isValid: true
      });
      this._eventEmitters.updateDisplay.emit("all");
    }
  };
  var ActionTypes;
  (function(ActionTypes2) {
    ActionTypes2["next"] = "next";
    ActionTypes2["previous"] = "previous";
    ActionTypes2["changeCalendarView"] = "changeCalendarView";
    ActionTypes2["selectMonth"] = "selectMonth";
    ActionTypes2["selectYear"] = "selectYear";
    ActionTypes2["selectDecade"] = "selectDecade";
    ActionTypes2["selectDay"] = "selectDay";
    ActionTypes2["selectHour"] = "selectHour";
    ActionTypes2["selectMinute"] = "selectMinute";
    ActionTypes2["selectSecond"] = "selectSecond";
    ActionTypes2["incrementHours"] = "incrementHours";
    ActionTypes2["incrementMinutes"] = "incrementMinutes";
    ActionTypes2["incrementSeconds"] = "incrementSeconds";
    ActionTypes2["decrementHours"] = "decrementHours";
    ActionTypes2["decrementMinutes"] = "decrementMinutes";
    ActionTypes2["decrementSeconds"] = "decrementSeconds";
    ActionTypes2["toggleMeridiem"] = "toggleMeridiem";
    ActionTypes2["togglePicker"] = "togglePicker";
    ActionTypes2["showClock"] = "showClock";
    ActionTypes2["showHours"] = "showHours";
    ActionTypes2["showMinutes"] = "showMinutes";
    ActionTypes2["showSeconds"] = "showSeconds";
    ActionTypes2["clear"] = "clear";
    ActionTypes2["close"] = "close";
    ActionTypes2["today"] = "today";
  })(ActionTypes || (ActionTypes = {}));
  var ActionTypes$1 = ActionTypes;
  var DateDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.daysContainer);
      container.role = "grid";
      container.append(...this._daysOfTheWeek());
      if (this.optionsStore.options.display.calendarWeeks) {
        const div2 = document.createElement("div");
        div2.classList.add(Namespace.css.calendarWeeks, Namespace.css.noHighlight);
        container.appendChild(div2);
      }
      const { rangeHoverEvent, rangeHoverOutEvent } = this.handleMouseEvents(container);
      for (let i4 = 0; i4 < 42; i4++) {
        if (i4 !== 0 && i4 % 7 === 0) {
          if (this.optionsStore.options.display.calendarWeeks) {
            const div3 = document.createElement("div");
            div3.classList.add(Namespace.css.calendarWeeks, Namespace.css.noHighlight);
            div3.tabIndex = -1;
            container.appendChild(div3);
          }
        }
        const div2 = document.createElement("div");
        div2.setAttribute("data-action", ActionTypes$1.selectDay);
        div2.role = "gridcell";
        div2.tabIndex = -1;
        container.appendChild(div2);
        if (matchMedia("(hover: hover)").matches && this.optionsStore.options.dateRange) {
          div2.addEventListener("mouseover", rangeHoverEvent);
          div2.addEventListener("mouseout", rangeHoverOutEvent);
        }
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const container = widget.getElementsByClassName(Namespace.css.daysContainer)[0];
      this._updateCalendarView(container);
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.month).startOf("weekDay", this.optionsStore.options.localization.startOfTheWeek).manipulate(12, Unit.hours);
      this._handleCalendarWeeks(container, innerDate.clone);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectDay}"]`).forEach((element) => {
        const classes = [];
        classes.push(Namespace.css.day);
        if (innerDate.isBefore(this.optionsStore.viewDate, Unit.month)) {
          classes.push(Namespace.css.old);
        }
        if (innerDate.isAfter(this.optionsStore.viewDate, Unit.month)) {
          classes.push(Namespace.css.new);
        }
        if (!this.optionsStore.unset && !this.optionsStore.options.dateRange && this.dates.isPicked(innerDate, Unit.date)) {
          classes.push(Namespace.css.active);
        }
        if (!this.validation.isValid(innerDate, Unit.date)) {
          classes.push(Namespace.css.disabled);
        }
        if (innerDate.isSame(new DateTime(), Unit.date)) {
          classes.push(Namespace.css.today);
        }
        if (innerDate.weekDay === 0 || innerDate.weekDay === 6) {
          classes.push(Namespace.css.weekend);
        }
        this._handleDateRange(innerDate, classes);
        paint(Unit.date, innerDate, classes, element);
        element.classList.remove(...element.classList);
        element.classList.add(...classes);
        element.setAttribute("data-value", innerDate.dateToDataValue());
        element.setAttribute("data-day", `${innerDate.date}`);
        element.innerText = innerDate.parts(void 0, {
          day: "numeric"
        }).day;
        element.ariaLabel = innerDate.format("MMMM dd, yyyy");
        innerDate.manipulate(1, Unit.date);
      });
    }
    _handleDateRange(innerDate, classes) {
      const rangeStart = this.dates.picked[0];
      const rangeEnd = this.dates.picked[1];
      if (this.optionsStore.options.dateRange) {
        if (innerDate.isBetween(rangeStart, rangeEnd, Unit.date)) {
          classes.push(Namespace.css.rangeIn);
        }
        if (innerDate.isSame(rangeStart, Unit.date)) {
          classes.push(Namespace.css.rangeStart);
        }
        if (innerDate.isSame(rangeEnd, Unit.date)) {
          classes.push(Namespace.css.rangeEnd);
        }
      }
    }
    handleMouseEvents(container) {
      const rangeHoverEvent = (e4) => {
        const currentTarget = e4?.currentTarget;
        if (this.dates.picked.length !== 1 || currentTarget.classList.contains(Namespace.css.disabled))
          return;
        const allDays = [...container.querySelectorAll(".day")];
        const attributeValue = currentTarget.getAttribute("data-value");
        const innerDate = DateTime.fromString(attributeValue, {
          format: "yyyy-MM-dd"
        });
        const dayIndex = allDays.findIndex((e5) => e5.getAttribute("data-value") === attributeValue);
        const rangeStart = this.dates.picked[0];
        const rangeEnd = this.dates.picked[1];
        const rangeStartFormatted = rangeStart.dateToDataValue();
        const rangeStartIndex = allDays.findIndex((e5) => e5.getAttribute("data-value") === rangeStartFormatted);
        const rangeStartElement = allDays[rangeStartIndex];
        if (!innerDate.isSame(rangeStart, Unit.date)) {
          currentTarget.classList.remove(Namespace.css.rangeStart);
        }
        if (!innerDate.isSame(rangeEnd, Unit.date)) {
          currentTarget.classList.remove(Namespace.css.rangeEnd);
        }
        let lambda;
        if (innerDate.isBefore(rangeStart)) {
          currentTarget.classList.add(Namespace.css.rangeStart);
          rangeStartElement?.classList.remove(Namespace.css.rangeStart);
          rangeStartElement?.classList.add(Namespace.css.rangeEnd);
          lambda = (_4, index) => index > dayIndex && index < rangeStartIndex;
        } else {
          currentTarget.classList.add(Namespace.css.rangeEnd);
          rangeStartElement?.classList.remove(Namespace.css.rangeEnd);
          rangeStartElement?.classList.add(Namespace.css.rangeStart);
          lambda = (_4, index) => index < dayIndex && index > rangeStartIndex;
        }
        allDays.filter(lambda).forEach((e5) => {
          e5.classList.add(Namespace.css.rangeIn);
        });
      };
      const rangeHoverOutEvent = (e4) => {
        const allDays = [...container.querySelectorAll(".day")];
        if (this.dates.picked.length === 1)
          allDays.forEach((e5) => e5.classList.remove(Namespace.css.rangeIn));
        if (this.dates.picked.length !== 1)
          return;
        const currentTarget = e4?.currentTarget;
        const innerDate = new DateTime(currentTarget.getAttribute("data-value"));
        if (!innerDate.isSame(this.dates.picked[0], Unit.date)) {
          currentTarget.classList.remove(Namespace.css.rangeStart);
        }
        if (!innerDate.isSame(this.dates.picked[1], Unit.date)) {
          currentTarget.classList.remove(Namespace.css.rangeEnd);
        }
      };
      return { rangeHoverEvent, rangeHoverOutEvent };
    }
    _updateCalendarView(container) {
      if (this.optionsStore.currentView !== "calendar")
        return;
      const [previous, switcher, next] = container.parentElement.getElementsByClassName(Namespace.css.calendarHeader)[0].getElementsByTagName("div");
      switcher.setAttribute(Namespace.css.daysContainer, this.optionsStore.viewDate.format(this.optionsStore.options.localization.dayViewHeaderFormat));
      this.optionsStore.options.display.components.month ? switcher.classList.remove(Namespace.css.disabled) : switcher.classList.add(Namespace.css.disabled);
      this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, Unit.month), Unit.month) ? previous.classList.remove(Namespace.css.disabled) : previous.classList.add(Namespace.css.disabled);
      this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, Unit.month), Unit.month) ? next.classList.remove(Namespace.css.disabled) : next.classList.add(Namespace.css.disabled);
    }
    /***
     * Generates a html row that contains the days of the week.
     * @private
     */
    _daysOfTheWeek() {
      const innerDate = this.optionsStore.viewDate.clone.startOf("weekDay", this.optionsStore.options.localization.startOfTheWeek).startOf(Unit.date);
      const row = [];
      document.createElement("div");
      if (this.optionsStore.options.display.calendarWeeks) {
        const htmlDivElement = document.createElement("div");
        htmlDivElement.classList.add(Namespace.css.calendarWeeks, Namespace.css.noHighlight);
        htmlDivElement.innerText = "#";
        row.push(htmlDivElement);
      }
      for (let i4 = 0; i4 < 7; i4++) {
        const htmlDivElement = document.createElement("div");
        htmlDivElement.classList.add(Namespace.css.dayOfTheWeek, Namespace.css.noHighlight);
        let weekDay = innerDate.format({ weekday: "short" });
        if (this.optionsStore.options.localization.maxWeekdayLength > 0)
          weekDay = weekDay.substring(0, this.optionsStore.options.localization.maxWeekdayLength);
        htmlDivElement.innerText = weekDay;
        htmlDivElement.ariaLabel = innerDate.format({ weekday: "long" });
        innerDate.manipulate(1, Unit.date);
        row.push(htmlDivElement);
      }
      return row;
    }
    _handleCalendarWeeks(container, innerDate) {
      [...container.querySelectorAll(`.${Namespace.css.calendarWeeks}`)].filter((e4) => e4.innerText !== "#").forEach((element) => {
        element.innerText = `${innerDate.week}`;
        innerDate.manipulate(7, Unit.date);
      });
    }
  };
  var MonthDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.monthsContainer);
      for (let i4 = 0; i4 < 12; i4++) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.selectMonth);
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const container = widget.getElementsByClassName(Namespace.css.monthsContainer)[0];
      if (this.optionsStore.currentView === "months") {
        const [previous, switcher, next] = container.parentElement.getElementsByClassName(Namespace.css.calendarHeader)[0].getElementsByTagName("div");
        switcher.setAttribute(Namespace.css.monthsContainer, this.optionsStore.viewDate.format({ year: "numeric" }));
        this.optionsStore.options.display.components.year ? switcher.classList.remove(Namespace.css.disabled) : switcher.classList.add(Namespace.css.disabled);
        this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, Unit.year), Unit.year) ? previous.classList.remove(Namespace.css.disabled) : previous.classList.add(Namespace.css.disabled);
        this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, Unit.year), Unit.year) ? next.classList.remove(Namespace.css.disabled) : next.classList.add(Namespace.css.disabled);
      }
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.year);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectMonth}"]`).forEach((containerClone, index) => {
        const classes = [];
        classes.push(Namespace.css.month);
        if (!this.optionsStore.unset && this.dates.isPicked(innerDate, Unit.month)) {
          classes.push(Namespace.css.active);
        }
        if (!this.validation.isValid(innerDate, Unit.month)) {
          classes.push(Namespace.css.disabled);
        }
        paint(Unit.month, innerDate, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${index}`);
        containerClone.innerText = `${innerDate.format({ month: "short" })}`;
        innerDate.manipulate(1, Unit.month);
      });
    }
  };
  var YearDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.yearsContainer);
      for (let i4 = 0; i4 < 12; i4++) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.selectYear);
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      this._startYear = this.optionsStore.viewDate.clone.manipulate(-1, Unit.year);
      this._endYear = this.optionsStore.viewDate.clone.manipulate(10, Unit.year);
      const container = widget.getElementsByClassName(Namespace.css.yearsContainer)[0];
      if (this.optionsStore.currentView === "years") {
        const [previous, switcher, next] = container.parentElement.getElementsByClassName(Namespace.css.calendarHeader)[0].getElementsByTagName("div");
        switcher.setAttribute(Namespace.css.yearsContainer, `${this._startYear.format({ year: "numeric" })}-${this._endYear.format({
          year: "numeric"
        })}`);
        this.optionsStore.options.display.components.decades ? switcher.classList.remove(Namespace.css.disabled) : switcher.classList.add(Namespace.css.disabled);
        this.validation.isValid(this._startYear, Unit.year) ? previous.classList.remove(Namespace.css.disabled) : previous.classList.add(Namespace.css.disabled);
        this.validation.isValid(this._endYear, Unit.year) ? next.classList.remove(Namespace.css.disabled) : next.classList.add(Namespace.css.disabled);
      }
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.year).manipulate(-1, Unit.year);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectYear}"]`).forEach((containerClone) => {
        const classes = [];
        classes.push(Namespace.css.year);
        if (!this.optionsStore.unset && this.dates.isPicked(innerDate, Unit.year)) {
          classes.push(Namespace.css.active);
        }
        if (!this.validation.isValid(innerDate, Unit.year)) {
          classes.push(Namespace.css.disabled);
        }
        paint(Unit.year, innerDate, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${innerDate.year}`);
        containerClone.innerText = innerDate.format({ year: "numeric" });
        innerDate.manipulate(1, Unit.year);
      });
    }
  };
  var DecadeDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.decadesContainer);
      for (let i4 = 0; i4 < 12; i4++) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.selectDecade);
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const [start4, end3] = Dates.getStartEndYear(100, this.optionsStore.viewDate.year);
      this._startDecade = this.optionsStore.viewDate.clone.startOf(Unit.year);
      this._startDecade.year = start4;
      this._endDecade = this.optionsStore.viewDate.clone.startOf(Unit.year);
      this._endDecade.year = end3;
      const container = widget.getElementsByClassName(Namespace.css.decadesContainer)[0];
      const [previous, switcher, next] = container.parentElement.getElementsByClassName(Namespace.css.calendarHeader)[0].getElementsByTagName("div");
      const isPreviousEnabled = this.validation.isValid(this._startDecade, Unit.year);
      if (this.optionsStore.currentView === "decades") {
        switcher.setAttribute(Namespace.css.decadesContainer, `${this._startDecade.format({
          year: "numeric"
        })}-${this._endDecade.format({ year: "numeric" })}`);
        isPreviousEnabled ? previous.classList.remove(Namespace.css.disabled) : previous.classList.add(Namespace.css.disabled);
        this.validation.isValid(this._endDecade, Unit.year) ? next.classList.remove(Namespace.css.disabled) : next.classList.add(Namespace.css.disabled);
      }
      const pickedYears = this.dates.picked.map((x4) => x4.year);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectDecade}"]`).forEach((containerClone, index) => {
        if (index === 0) {
          containerClone.classList.add(Namespace.css.old);
          if (this._startDecade.year - 10 < 0) {
            containerClone.textContent = " ";
            previous.classList.add(Namespace.css.disabled);
            containerClone.classList.add(Namespace.css.disabled);
            containerClone.setAttribute("data-value", "");
          }
          return;
        }
        const classes = [];
        classes.push(Namespace.css.decade);
        const startDecadeYear = this._startDecade.year;
        const endDecadeYear = this._startDecade.year + 9;
        if (!this.optionsStore.unset && pickedYears.filter((x4) => x4 >= startDecadeYear && x4 <= endDecadeYear).length > 0) {
          classes.push(Namespace.css.active);
        }
        if (!isPreviousEnabled && !this.validation.isValid(this._startDecade.clone.manipulate(10, Unit.year), Unit.year)) {
          classes.push(Namespace.css.disabled);
        }
        paint("decade", this._startDecade, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${this._startDecade.year}`);
        containerClone.innerText = `${this._startDecade.format({
          year: "numeric"
        })}`;
        this._startDecade.manipulate(10, Unit.year);
      });
    }
  };
  var TimeDisplay = class {
    constructor() {
      this._gridColumns = "";
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the clock display
     * @private
     */
    getPicker(iconTag) {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.clockContainer);
      container.append(...this._grid(iconTag));
      return container;
    }
    /**
     * Populates the various elements with in the clock display
     * like the current hour and if the manipulation icons are enabled.
     * @private
     */
    _update(widget) {
      const timesDiv = widget.getElementsByClassName(Namespace.css.clockContainer)[0];
      let lastPicked = this.dates.lastPicked?.clone;
      if (!lastPicked && this.optionsStore.options.useCurrent)
        lastPicked = this.optionsStore.viewDate.clone;
      timesDiv.querySelectorAll(".disabled").forEach((element) => element.classList.remove(Namespace.css.disabled));
      if (this.optionsStore.options.display.components.hours) {
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, Unit.hours), Unit.hours)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.incrementHours}]`).classList.add(Namespace.css.disabled);
        }
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, Unit.hours), Unit.hours)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.decrementHours}]`).classList.add(Namespace.css.disabled);
        }
        timesDiv.querySelector(`[data-time-component=${Unit.hours}]`).innerText = lastPicked ? lastPicked.getHoursFormatted(this.optionsStore.options.localization.hourCycle) : "--";
      }
      if (this.optionsStore.options.display.components.minutes) {
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, Unit.minutes), Unit.minutes)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.incrementMinutes}]`).classList.add(Namespace.css.disabled);
        }
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, Unit.minutes), Unit.minutes)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.decrementMinutes}]`).classList.add(Namespace.css.disabled);
        }
        timesDiv.querySelector(`[data-time-component=${Unit.minutes}]`).innerText = lastPicked ? lastPicked.minutesFormatted : "--";
      }
      if (this.optionsStore.options.display.components.seconds) {
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, Unit.seconds), Unit.seconds)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.incrementSeconds}]`).classList.add(Namespace.css.disabled);
        }
        if (!this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, Unit.seconds), Unit.seconds)) {
          timesDiv.querySelector(`[data-action=${ActionTypes$1.decrementSeconds}]`).classList.add(Namespace.css.disabled);
        }
        timesDiv.querySelector(`[data-time-component=${Unit.seconds}]`).innerText = lastPicked ? lastPicked.secondsFormatted : "--";
      }
      if (this.optionsStore.isTwelveHour) {
        const toggle = timesDiv.querySelector(`[data-action=${ActionTypes$1.toggleMeridiem}]`);
        const meridiemDate = (lastPicked || this.optionsStore.viewDate).clone;
        toggle.innerText = meridiemDate.meridiem();
        if (!this.validation.isValid(meridiemDate.manipulate(meridiemDate.hours >= 12 ? -12 : 12, Unit.hours))) {
          toggle.classList.add(Namespace.css.disabled);
        } else {
          toggle.classList.remove(Namespace.css.disabled);
        }
      }
      timesDiv.style.gridTemplateAreas = `"${this._gridColumns}"`;
    }
    /**
     * Creates the table for the clock display depending on what options are selected.
     * @private
     */
    _grid(iconTag) {
      this._gridColumns = "";
      const top3 = [], middle = [], bottom3 = [], separator = document.createElement("div"), upIcon = iconTag(this.optionsStore.options.display.icons.up), downIcon = iconTag(this.optionsStore.options.display.icons.down);
      separator.classList.add(Namespace.css.separator, Namespace.css.noHighlight);
      const separatorColon = separator.cloneNode(true);
      separatorColon.innerHTML = ":";
      const getSeparator = (colon = false) => {
        return colon ? separatorColon.cloneNode(true) : separator.cloneNode(true);
      };
      if (this.optionsStore.options.display.components.hours) {
        let divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.incrementHour);
        divElement.setAttribute("data-action", ActionTypes$1.incrementHours);
        divElement.appendChild(upIcon.cloneNode(true));
        top3.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.pickHour);
        divElement.setAttribute("data-action", ActionTypes$1.showHours);
        divElement.setAttribute("data-time-component", Unit.hours);
        middle.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.decrementHour);
        divElement.setAttribute("data-action", ActionTypes$1.decrementHours);
        divElement.appendChild(downIcon.cloneNode(true));
        bottom3.push(divElement);
        this._gridColumns += "a";
      }
      if (this.optionsStore.options.display.components.minutes) {
        this._gridColumns += " a";
        if (this.optionsStore.options.display.components.hours) {
          top3.push(getSeparator());
          middle.push(getSeparator(true));
          bottom3.push(getSeparator());
          this._gridColumns += " a";
        }
        let divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.incrementMinute);
        divElement.setAttribute("data-action", ActionTypes$1.incrementMinutes);
        divElement.appendChild(upIcon.cloneNode(true));
        top3.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.pickMinute);
        divElement.setAttribute("data-action", ActionTypes$1.showMinutes);
        divElement.setAttribute("data-time-component", Unit.minutes);
        middle.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.decrementMinute);
        divElement.setAttribute("data-action", ActionTypes$1.decrementMinutes);
        divElement.appendChild(downIcon.cloneNode(true));
        bottom3.push(divElement);
      }
      if (this.optionsStore.options.display.components.seconds) {
        this._gridColumns += " a";
        if (this.optionsStore.options.display.components.minutes) {
          top3.push(getSeparator());
          middle.push(getSeparator(true));
          bottom3.push(getSeparator());
          this._gridColumns += " a";
        }
        let divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.incrementSecond);
        divElement.setAttribute("data-action", ActionTypes$1.incrementSeconds);
        divElement.appendChild(upIcon.cloneNode(true));
        top3.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.pickSecond);
        divElement.setAttribute("data-action", ActionTypes$1.showSeconds);
        divElement.setAttribute("data-time-component", Unit.seconds);
        middle.push(divElement);
        divElement = document.createElement("div");
        divElement.tabIndex = -1;
        divElement.setAttribute("title", this.optionsStore.options.localization.decrementSecond);
        divElement.setAttribute("data-action", ActionTypes$1.decrementSeconds);
        divElement.appendChild(downIcon.cloneNode(true));
        bottom3.push(divElement);
      }
      if (this.optionsStore.isTwelveHour) {
        this._gridColumns += " a";
        let divElement = getSeparator();
        top3.push(divElement);
        const button = document.createElement("button");
        button.tabIndex = -1;
        button.setAttribute("type", "button");
        button.setAttribute("title", this.optionsStore.options.localization.toggleMeridiem);
        button.setAttribute("data-action", ActionTypes$1.toggleMeridiem);
        button.setAttribute("tabindex", "-1");
        if (Namespace.css.toggleMeridiem.includes(",")) {
          button.classList.add(...Namespace.css.toggleMeridiem.split(","));
        } else
          button.classList.add(Namespace.css.toggleMeridiem);
        divElement = document.createElement("div");
        divElement.classList.add(Namespace.css.noHighlight);
        divElement.appendChild(button);
        middle.push(divElement);
        divElement = getSeparator();
        bottom3.push(divElement);
      }
      this._gridColumns = this._gridColumns.trim();
      return [...top3, ...middle, ...bottom3];
    }
  };
  var HourDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.validation = serviceLocator.locate(Validation);
      this.dates = serviceLocator.locate(Dates);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.hourContainer);
      for (let i4 = 0; i4 < (this.optionsStore.isTwelveHour ? 12 : 24); i4++) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.selectHour);
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const container = widget.getElementsByClassName(Namespace.css.hourContainer)[0];
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.date);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectHour}"]`).forEach((containerClone) => {
        const classes = [];
        classes.push(Namespace.css.hour);
        if (!this.validation.isValid(innerDate, Unit.hours)) {
          classes.push(Namespace.css.disabled);
        }
        paint(Unit.hours, innerDate, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${innerDate.hours}`);
        containerClone.innerText = innerDate.getHoursFormatted(this.optionsStore.options.localization.hourCycle);
        innerDate.manipulate(1, Unit.hours);
      });
    }
  };
  var MinuteDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.minuteContainer);
      const step = this.optionsStore.options.stepping === 1 ? 5 : this.optionsStore.options.stepping;
      for (let i4 = 0; i4 < 60 / step; i4++) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.selectMinute);
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const container = widget.getElementsByClassName(Namespace.css.minuteContainer)[0];
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.hours);
      const step = this.optionsStore.options.stepping === 1 ? 5 : this.optionsStore.options.stepping;
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectMinute}"]`).forEach((containerClone) => {
        const classes = [];
        classes.push(Namespace.css.minute);
        if (!this.validation.isValid(innerDate, Unit.minutes)) {
          classes.push(Namespace.css.disabled);
        }
        paint(Unit.minutes, innerDate, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${innerDate.minutes}`);
        containerClone.innerText = innerDate.minutesFormatted;
        innerDate.manipulate(step, Unit.minutes);
      });
    }
  };
  var secondDisplay = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.validation = serviceLocator.locate(Validation);
    }
    /**
     * Build the container html for the display
     * @private
     */
    getPicker() {
      const container = document.createElement("div");
      container.classList.add(Namespace.css.secondContainer);
      for (let i4 = 0; i4 < 12; i4++) {
        const div2 = document.createElement("div");
        div2.setAttribute("data-action", ActionTypes$1.selectSecond);
        div2.tabIndex = -1;
        container.appendChild(div2);
      }
      return container;
    }
    /**
     * Populates the grid and updates enabled states
     * @private
     */
    _update(widget, paint) {
      const container = widget.getElementsByClassName(Namespace.css.secondContainer)[0];
      const innerDate = this.optionsStore.viewDate.clone.startOf(Unit.minutes);
      container.querySelectorAll(`[data-action="${ActionTypes$1.selectSecond}"]`).forEach((containerClone) => {
        const classes = [];
        classes.push(Namespace.css.second);
        if (!this.validation.isValid(innerDate, Unit.seconds)) {
          classes.push(Namespace.css.disabled);
        }
        paint(Unit.seconds, innerDate, classes, containerClone);
        containerClone.classList.remove(...containerClone.classList);
        containerClone.classList.add(...classes);
        containerClone.setAttribute("data-value", `${innerDate.seconds}`);
        containerClone.innerText = innerDate.secondsFormatted;
        innerDate.manipulate(5, Unit.seconds);
      });
    }
  };
  var Collapse = class _Collapse {
    /**
     * Flips the show/hide state of `target`
     * @param target html element to affect.
     */
    static toggle(target) {
      if (target.classList.contains(Namespace.css.show)) {
        this.hide(target);
      } else {
        this.show(target);
      }
    }
    /**
     * Skips any animation or timeouts and immediately set the element to show.
     * @param target
     */
    static showImmediately(target) {
      target.classList.remove(Namespace.css.collapsing);
      target.classList.add(Namespace.css.collapse, Namespace.css.show);
      target.style.height = "";
    }
    /**
     * If `target` is not already showing, then show after the animation.
     * @param target
     */
    static show(target) {
      if (target.classList.contains(Namespace.css.collapsing) || target.classList.contains(Namespace.css.show))
        return;
      const complete = () => {
        _Collapse.showImmediately(target);
      };
      target.style.height = "0";
      target.classList.remove(Namespace.css.collapse);
      target.classList.add(Namespace.css.collapsing);
      setTimeout(complete, this.getTransitionDurationFromElement(target));
      target.style.height = `${target.scrollHeight}px`;
    }
    /**
     * Skips any animation or timeouts and immediately set the element to hide.
     * @param target
     */
    static hideImmediately(target) {
      if (!target)
        return;
      target.classList.remove(Namespace.css.collapsing, Namespace.css.show);
      target.classList.add(Namespace.css.collapse);
    }
    /**
     * If `target` is not already hidden, then hide after the animation.
     * @param target HTML Element
     */
    static hide(target) {
      if (target.classList.contains(Namespace.css.collapsing) || !target.classList.contains(Namespace.css.show))
        return;
      const complete = () => {
        _Collapse.hideImmediately(target);
      };
      target.style.height = `${target.getBoundingClientRect()["height"]}px`;
      const reflow = (element) => element.offsetHeight;
      reflow(target);
      target.classList.remove(Namespace.css.collapse, Namespace.css.show);
      target.classList.add(Namespace.css.collapsing);
      target.style.height = "";
      setTimeout(complete, this.getTransitionDurationFromElement(target));
    }
  };
  Collapse.getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1e3;
  };
  var Display = class {
    constructor() {
      this._isVisible = false;
      this._keyboardEventBound = this._keyboardEvent.bind(this);
      this._documentClickEvent = (e4) => {
        if (this.optionsStore.options.debug || window.debug)
          return;
        if (this._isVisible && !e4.composedPath().includes(this.widget) && // click inside the widget
        !e4.composedPath()?.includes(this.optionsStore.element)) {
          this.hide();
        }
      };
      this._actionsClickEvent = (e4) => {
        this._eventEmitters.action.emit({ e: e4 });
      };
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.validation = serviceLocator.locate(Validation);
      this.dates = serviceLocator.locate(Dates);
      this.dateDisplay = serviceLocator.locate(DateDisplay);
      this.monthDisplay = serviceLocator.locate(MonthDisplay);
      this.yearDisplay = serviceLocator.locate(YearDisplay);
      this.decadeDisplay = serviceLocator.locate(DecadeDisplay);
      this.timeDisplay = serviceLocator.locate(TimeDisplay);
      this.hourDisplay = serviceLocator.locate(HourDisplay);
      this.minuteDisplay = serviceLocator.locate(MinuteDisplay);
      this.secondDisplay = serviceLocator.locate(secondDisplay);
      this._eventEmitters = serviceLocator.locate(EventEmitters);
      this._widget = void 0;
      this._eventEmitters.updateDisplay.subscribe((result) => {
        this._update(result);
      });
    }
    /**
     * Returns the widget body or undefined
     * @private
     */
    get widget() {
      return this._widget;
    }
    get dateContainer() {
      return this.widget?.querySelector(`div.${Namespace.css.dateContainer}`);
    }
    get timeContainer() {
      return this.widget?.querySelector(`div.${Namespace.css.timeContainer}`);
    }
    /**
     * Returns this visible state of the picker (shown)
     */
    get isVisible() {
      return this._isVisible;
    }
    /**
     * Updates the table for a particular unit. Used when an option as changed or
     * whenever the class list might need to be refreshed.
     * @param unit
     * @private
     */
    _update(unit) {
      if (!this.widget)
        return;
      switch (unit) {
        case Unit.seconds:
          this.secondDisplay._update(this.widget, this.paint);
          break;
        case Unit.minutes:
          this.minuteDisplay._update(this.widget, this.paint);
          break;
        case Unit.hours:
          this.hourDisplay._update(this.widget, this.paint);
          break;
        case Unit.date:
          this.dateDisplay._update(this.widget, this.paint);
          break;
        case Unit.month:
          this.monthDisplay._update(this.widget, this.paint);
          break;
        case Unit.year:
          this.yearDisplay._update(this.widget, this.paint);
          break;
        case "decade":
          this.decadeDisplay._update(this.widget, this.paint);
          break;
        case "clock":
          if (!this._hasTime)
            break;
          this.timeDisplay._update(this.widget);
          this._update(Unit.hours);
          this._update(Unit.minutes);
          this._update(Unit.seconds);
          break;
        case "calendar":
          this._update(Unit.date);
          this._update(Unit.year);
          this._update(Unit.month);
          this.decadeDisplay._update(this.widget, this.paint);
          this._updateCalendarHeader();
          break;
        case "all":
          if (this._hasTime) {
            this._update("clock");
          }
          if (this._hasDate) {
            this._update("calendar");
          }
      }
    }
    // noinspection JSUnusedLocalSymbols
    /**
     * Allows developers to add/remove classes from an element.
     * @param _unit
     * @param _date
     * @param _classes
     * @param _element
     */
    /* eslint-disable @typescript-eslint/no-unused-vars */
    paint(_unit, _date, _classes, _element) {
    }
    /**
     * Shows the picker and creates a Popper instance if needed.
     * Add document click event to hide when clicking outside the picker.
     * fires Events#show
     */
    show() {
      if (this.widget == void 0) {
        this._showSetDefaultIfNeeded();
        this._buildWidget();
        this._updateTheme();
        this._showSetupViewMode();
        if (!this.optionsStore.options.display.inline) {
          const container = this.optionsStore.options?.container || document.body;
          const placement = this.optionsStore.options?.display?.placement || "bottom";
          container.appendChild(this.widget);
          const handleFocus = this._handleFocus.bind(this);
          this.createPopup(this.optionsStore.element, this.widget, {
            modifiers: [
              { name: "eventListeners", enabled: true },
              {
                name: "focusDate",
                enabled: true,
                phase: "afterWrite",
                fn() {
                  handleFocus();
                }
              }
            ],
            //#2400
            placement: document.documentElement.dir === "rtl" ? `${placement}-end` : `${placement}-start`
          }).then(() => {
            this._handleFocus();
          });
        } else {
          this.optionsStore.element.appendChild(this.widget);
        }
        if (this.optionsStore.options.display.viewMode == "clock") {
          this._eventEmitters.action.emit({
            e: null,
            action: ActionTypes$1.showClock
          });
        }
        this.widget.querySelectorAll("[data-action]").forEach((element) => element.addEventListener("click", this._actionsClickEvent));
        if (this._hasTime && this.optionsStore.options.display.sideBySide) {
          this.timeDisplay._update(this.widget);
          this.widget.getElementsByClassName(Namespace.css.clockContainer)[0].style.display = "grid";
        }
      }
      this.widget.classList.add(Namespace.css.show);
      if (!this.optionsStore.options.display.inline) {
        this.updatePopup();
        document.addEventListener("click", this._documentClickEvent);
      }
      this._eventEmitters.triggerEvent.emit({ type: Namespace.events.show });
      this._isVisible = true;
      if (this.optionsStore.options.display.keyboardNavigation) {
        this.widget.addEventListener("keydown", this._keyboardEventBound);
      }
    }
    _showSetupViewMode() {
      const onlyClock = this._hasTime && !this._hasDate;
      if (onlyClock) {
        this.optionsStore.currentView = "clock";
        this._eventEmitters.action.emit({
          e: null,
          action: ActionTypes$1.showClock
        });
      } else if (!this.optionsStore.currentCalendarViewMode) {
        this.optionsStore.currentCalendarViewMode = this.optionsStore.minimumCalendarViewMode;
      }
      if (!onlyClock && this.optionsStore.options.display.viewMode !== "clock") {
        if (this._hasTime) {
          if (!this.optionsStore.options.display.sideBySide) {
            Collapse.hideImmediately(this.timeContainer);
          } else {
            Collapse.show(this.timeContainer);
          }
        }
        Collapse.show(this.dateContainer);
      }
      if (this._hasDate) {
        this._showMode();
      }
    }
    _showSetDefaultIfNeeded() {
      if (this.dates.picked.length != 0)
        return;
      if (this.optionsStore.options.useCurrent && !this.optionsStore.options.defaultDate) {
        const date = new DateTime().setLocalization(this.optionsStore.options.localization);
        if (!this.optionsStore.options.keepInvalid) {
          let tries = 0;
          let direction = 1;
          if (this.optionsStore.options.restrictions.maxDate?.isBefore(date)) {
            direction = -1;
          }
          while (!this.validation.isValid(date) && tries > 31) {
            date.manipulate(direction, Unit.date);
            tries++;
          }
        }
        this.dates.setValue(date);
      }
      if (this.optionsStore.options.defaultDate) {
        this.dates.setValue(this.optionsStore.options.defaultDate);
      }
    }
    async createPopup(element, widget, options) {
      let createPopperFunction;
      if (window?.Popper) {
        createPopperFunction = window?.Popper?.createPopper;
      } else {
        const { createPopper: createPopper5 } = await Promise.resolve().then(() => (init_lib(), lib_exports));
        createPopperFunction = createPopper5;
      }
      if (createPopperFunction) {
        this._popperInstance = createPopperFunction(element, widget, options);
      }
    }
    updatePopup() {
      if (!this._popperInstance)
        return;
      this._popperInstance.update();
    }
    /**
     * Changes the calendar view mode. E.g. month <-> year
     * @param direction -/+ number to move currentViewMode
     * @private
     */
    _showMode(direction) {
      if (!this.widget) {
        return;
      }
      if (direction) {
        const max3 = Math.max(this.optionsStore.minimumCalendarViewMode, Math.min(3, this.optionsStore.currentCalendarViewMode + direction));
        if (this.optionsStore.currentCalendarViewMode == max3)
          return;
        this.optionsStore.currentCalendarViewMode = max3;
      }
      this.widget.querySelectorAll(`.${Namespace.css.dateContainer} > div:not(.${Namespace.css.calendarHeader}), .${Namespace.css.timeContainer} > div:not(.${Namespace.css.clockContainer})`).forEach((e4) => e4.style.display = "none");
      const datePickerMode = CalendarModes[this.optionsStore.currentCalendarViewMode];
      const picker = this.widget.querySelector(`.${datePickerMode.className}`);
      switch (datePickerMode.className) {
        case Namespace.css.decadesContainer:
          this.decadeDisplay._update(this.widget, this.paint);
          break;
        case Namespace.css.yearsContainer:
          this.yearDisplay._update(this.widget, this.paint);
          break;
        case Namespace.css.monthsContainer:
          this.monthDisplay._update(this.widget, this.paint);
          break;
        case Namespace.css.daysContainer:
          this.dateDisplay._update(this.widget, this.paint);
          break;
      }
      picker.style.display = "grid";
      if (this.optionsStore.options.display.sideBySide)
        this.widget.querySelectorAll(`.${Namespace.css.clockContainer}`)[0].style.display = "grid";
      this._updateCalendarHeader();
      this._eventEmitters.viewUpdate.emit();
      this.findViewDateElement()?.focus();
    }
    /**
     * Changes the theme. E.g. light, dark or auto
     * @param theme the theme name
     * @private
     */
    _updateTheme(theme) {
      if (!this.widget) {
        return;
      }
      if (theme) {
        if (this.optionsStore.options.display.theme === theme)
          return;
        this.optionsStore.options.display.theme = theme;
      }
      this.widget.classList.remove("light", "dark");
      this.widget.classList.add(this._getThemeClass());
      if (this.optionsStore.options.display.theme === "auto") {
        window.matchMedia(Namespace.css.isDarkPreferredQuery).addEventListener("change", () => this._updateTheme());
      } else {
        window.matchMedia(Namespace.css.isDarkPreferredQuery).removeEventListener("change", () => this._updateTheme());
      }
    }
    _getThemeClass() {
      const currentTheme = this.optionsStore.options.display.theme || "auto";
      const isDarkMode = window.matchMedia && window.matchMedia(Namespace.css.isDarkPreferredQuery).matches;
      switch (currentTheme) {
        case "light":
          return Namespace.css.lightTheme;
        case "dark":
          return Namespace.css.darkTheme;
        case "auto":
          return isDarkMode ? Namespace.css.darkTheme : Namespace.css.lightTheme;
      }
    }
    _updateCalendarHeader() {
      if (!this._hasDate)
        return;
      const showing = [
        ...this.widget.querySelector(`.${Namespace.css.dateContainer} div[style*="display: grid"]`).classList
      ].find((x4) => x4.startsWith(Namespace.css.dateContainer));
      const [previous, switcher, next] = this.widget.getElementsByClassName(Namespace.css.calendarHeader)[0].getElementsByTagName("div");
      switch (showing) {
        case Namespace.css.decadesContainer:
          previous.setAttribute("title", this.optionsStore.options.localization.previousCentury);
          switcher.setAttribute("title", "");
          next.setAttribute("title", this.optionsStore.options.localization.nextCentury);
          break;
        case Namespace.css.yearsContainer:
          previous.setAttribute("title", this.optionsStore.options.localization.previousDecade);
          switcher.setAttribute("title", this.optionsStore.options.localization.selectDecade);
          next.setAttribute("title", this.optionsStore.options.localization.nextDecade);
          break;
        case Namespace.css.monthsContainer:
          previous.setAttribute("title", this.optionsStore.options.localization.previousYear);
          switcher.setAttribute("title", this.optionsStore.options.localization.selectYear);
          next.setAttribute("title", this.optionsStore.options.localization.nextYear);
          break;
        case Namespace.css.daysContainer:
          previous.setAttribute("title", this.optionsStore.options.localization.previousMonth);
          switcher.setAttribute("title", this.optionsStore.options.localization.selectMonth);
          next.setAttribute("title", this.optionsStore.options.localization.nextMonth);
          switcher.setAttribute(showing, this.optionsStore.viewDate.format(this.optionsStore.options.localization.dayViewHeaderFormat));
          break;
      }
      switcher.innerText = switcher.getAttribute(showing);
    }
    /**
     * Hides the picker if needed.
     * Remove document click event to hide when clicking outside the picker.
     * fires Events#hide
     */
    hide() {
      if (!this.widget || !this._isVisible)
        return;
      this.widget.classList.remove(Namespace.css.show);
      if (this._isVisible) {
        this._eventEmitters.triggerEvent.emit({
          type: Namespace.events.hide,
          date: this.optionsStore.unset ? null : this.dates.lastPicked?.clone
        });
        this._isVisible = false;
      }
      document.removeEventListener("click", this._documentClickEvent);
      if (this.optionsStore.options.display.keyboardNavigation) {
        this.widget.removeEventListener("keydown", this._keyboardEventBound);
      }
      if (this.optionsStore.toggle)
        this.optionsStore.toggle.focus();
      else if (this.optionsStore.input)
        this.optionsStore.input.focus();
    }
    /**
     * Toggles the picker's open state. Fires a show/hide event depending.
     */
    toggle() {
      return this._isVisible ? this.hide() : this.show();
    }
    /**
     * Removes document and data-action click listener and reset the widget
     * @private
     */
    _dispose() {
      document.removeEventListener("click", this._documentClickEvent);
      if (this._popperInstance)
        this._popperInstance.destroy();
      if (!this.widget)
        return;
      this.widget.querySelectorAll("[data-action]").forEach((element) => element.removeEventListener("click", this._actionsClickEvent));
      this.widget.parentNode.removeChild(this.widget);
      this._widget = void 0;
    }
    /**
     * Builds the widgets html template.
     * @private
     */
    _buildWidget() {
      const template = document.createElement("div");
      template.tabIndex = -1;
      template.classList.add(Namespace.css.widget);
      template.setAttribute("role", "widget");
      const dateView = document.createElement("div");
      dateView.tabIndex = -1;
      dateView.classList.add(Namespace.css.dateContainer);
      dateView.append(this.getHeadTemplate(), this.decadeDisplay.getPicker(), this.yearDisplay.getPicker(), this.monthDisplay.getPicker(), this.dateDisplay.getPicker());
      const timeView = document.createElement("div");
      timeView.tabIndex = -1;
      timeView.classList.add(Namespace.css.timeContainer);
      timeView.appendChild(this.timeDisplay.getPicker(this._iconTag.bind(this)));
      timeView.appendChild(this.hourDisplay.getPicker());
      timeView.appendChild(this.minuteDisplay.getPicker());
      timeView.appendChild(this.secondDisplay.getPicker());
      const toolbar = document.createElement("div");
      toolbar.tabIndex = -1;
      toolbar.classList.add(Namespace.css.toolbar);
      toolbar.append(...this.getToolbarElements());
      if (this.optionsStore.options.display.inline) {
        template.classList.add(Namespace.css.inline);
      }
      if (this.optionsStore.options.display.calendarWeeks) {
        template.classList.add("calendarWeeks");
      }
      if (this.optionsStore.options.display.sideBySide && this._hasDateAndTime) {
        this._buildWidgetSideBySide(template, dateView, timeView, toolbar);
        return;
      }
      if (this.optionsStore.options.display.toolbarPlacement === "top") {
        template.appendChild(toolbar);
      }
      const setupComponentView = (hasFirst, hasSecond, element, shouldShow) => {
        if (!hasFirst)
          return;
        if (hasSecond) {
          element.classList.add(Namespace.css.collapse);
          if (shouldShow)
            element.classList.add(Namespace.css.show);
        }
        template.appendChild(element);
      };
      setupComponentView(this._hasDate, this._hasTime, dateView, this.optionsStore.options.display.viewMode !== "clock");
      setupComponentView(this._hasTime, this._hasDate, timeView, this.optionsStore.options.display.viewMode === "clock");
      if (this.optionsStore.options.display.toolbarPlacement === "bottom") {
        template.appendChild(toolbar);
      }
      const arrow3 = document.createElement("div");
      arrow3.classList.add("arrow");
      arrow3.setAttribute("data-popper-arrow", "");
      template.appendChild(arrow3);
      this._widget = template;
    }
    _buildWidgetSideBySide(template, dateView, timeView, toolbar) {
      template.classList.add(Namespace.css.sideBySide);
      if (this.optionsStore.options.display.toolbarPlacement === "top") {
        template.appendChild(toolbar);
      }
      const row = document.createElement("div");
      row.classList.add("td-row");
      dateView.classList.add("td-half");
      timeView.classList.add("td-half");
      row.appendChild(dateView);
      row.appendChild(timeView);
      template.appendChild(row);
      if (this.optionsStore.options.display.toolbarPlacement === "bottom") {
        template.appendChild(toolbar);
      }
      this._widget = template;
    }
    /**
     * Returns true if the hours, minutes, or seconds component is turned on
     */
    get _hasTime() {
      return this.optionsStore.options.display.components.clock && (this.optionsStore.options.display.components.hours || this.optionsStore.options.display.components.minutes || this.optionsStore.options.display.components.seconds);
    }
    /**
     * Returns true if the year, month, or date component is turned on
     */
    get _hasDate() {
      return this.optionsStore.options.display.components.calendar && (this.optionsStore.options.display.components.year || this.optionsStore.options.display.components.month || this.optionsStore.options.display.components.date);
    }
    get _hasDateAndTime() {
      return this._hasDate && this._hasTime;
    }
    /**
     * Get the toolbar html based on options like buttons => today
     * @private
     */
    getToolbarElements() {
      const toolbar = [];
      if (this.optionsStore.options.display.buttons.today) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.today);
        div2.setAttribute("title", this.optionsStore.options.localization.today);
        div2.appendChild(this._iconTag(this.optionsStore.options.display.icons.today));
        toolbar.push(div2);
      }
      if (!this.optionsStore.options.display.sideBySide && this._hasDate && this._hasTime) {
        let title, icon;
        if (this.optionsStore.options.display.viewMode === "clock") {
          title = this.optionsStore.options.localization.selectDate;
          icon = this.optionsStore.options.display.icons.date;
        } else {
          title = this.optionsStore.options.localization.selectTime;
          icon = this.optionsStore.options.display.icons.time;
        }
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.togglePicker);
        div2.setAttribute("title", title);
        div2.appendChild(this._iconTag(icon));
        toolbar.push(div2);
      }
      if (this.optionsStore.options.display.buttons.clear) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.clear);
        div2.setAttribute("title", this.optionsStore.options.localization.clear);
        div2.appendChild(this._iconTag(this.optionsStore.options.display.icons.clear));
        toolbar.push(div2);
      }
      if (this.optionsStore.options.display.buttons.close) {
        const div2 = document.createElement("div");
        div2.tabIndex = -1;
        div2.setAttribute("data-action", ActionTypes$1.close);
        div2.setAttribute("title", this.optionsStore.options.localization.close);
        div2.appendChild(this._iconTag(this.optionsStore.options.display.icons.close));
        toolbar.push(div2);
      }
      return toolbar;
    }
    /***
     * Builds the base header template with next and previous icons
     * @private
     */
    getHeadTemplate() {
      const calendarHeader = document.createElement("div");
      calendarHeader.classList.add(Namespace.css.calendarHeader);
      const previous = document.createElement("div");
      previous.classList.add(Namespace.css.previous);
      previous.setAttribute("data-action", ActionTypes$1.previous);
      previous.appendChild(this._iconTag(this.optionsStore.options.display.icons.previous));
      previous.tabIndex = -1;
      const switcher = document.createElement("div");
      switcher.classList.add(Namespace.css.switch);
      switcher.setAttribute("data-action", ActionTypes$1.changeCalendarView);
      switcher.tabIndex = -1;
      const next = document.createElement("div");
      next.classList.add(Namespace.css.next);
      next.setAttribute("data-action", ActionTypes$1.next);
      next.appendChild(this._iconTag(this.optionsStore.options.display.icons.next));
      next.tabIndex = -1;
      calendarHeader.append(previous, switcher, next);
      return calendarHeader;
    }
    /**
     * Builds an icon tag as either an `<i>`
     * or with icons => type is `sprites` then a svg tag instead
     * @param iconClass
     * @private
     */
    _iconTag(iconClass) {
      if (this.optionsStore.options.display.icons.type === "sprites") {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const icon2 = document.createElementNS("http://www.w3.org/2000/svg", "use");
        icon2.setAttribute("xlink:href", iconClass);
        icon2.setAttribute("href", iconClass);
        svg.appendChild(icon2);
        return svg;
      }
      const icon = document.createElement("i");
      icon.classList.add(...iconClass.split(" "));
      return icon;
    }
    /**
     * Causes the widget to get rebuilt on next show. If the picker is already open
     * then hide and reshow it.
     * @private
     */
    _rebuild() {
      const wasVisible = this._isVisible;
      this._dispose();
      if (wasVisible)
        this.show();
    }
    refreshCurrentView() {
      if (!this._isVisible)
        this._dispose();
      switch (this.optionsStore.currentView) {
        case "clock":
          this._update("clock");
          break;
        case "calendar":
          this._update(Unit.date);
          break;
        case "months":
          this._update(Unit.month);
          break;
        case "years":
          this._update(Unit.year);
          break;
        case "decades":
          this._update("decade");
          break;
      }
    }
    _keyboardEvent(event) {
      if (this.optionsStore.currentView === "clock") {
        this._handleKeyDownClock(event);
        return;
      }
      this._handleKeyDownDate(event);
      return false;
    }
    findViewDateElement() {
      let selector = "";
      let dataValue = "";
      switch (this.optionsStore.currentView) {
        case "clock":
          break;
        case "calendar":
          selector = Namespace.css.daysContainer;
          dataValue = this.optionsStore.viewDate.dateToDataValue();
          break;
        case "months":
          selector = Namespace.css.monthsContainer;
          dataValue = this.optionsStore.viewDate.month.toString();
          break;
        case "years":
          selector = Namespace.css.yearsContainer;
          dataValue = this.optionsStore.viewDate.year.toString();
          break;
        case "decades":
          selector = Namespace.css.decadesContainer;
          dataValue = (Math.floor(this.optionsStore.viewDate.year / 10) * 10).toString();
          break;
      }
      return this.widget.querySelector(`.${selector} > div[data-value="${dataValue}"]`);
    }
    _handleKeyDownDate(event) {
      let flag = false;
      const activeElement = document.activeElement;
      let unit = null;
      let verticalChange = 7;
      let horizontalChange = 1;
      let change = 1;
      const currentView = this.optionsStore.currentView;
      switch (currentView) {
        case "calendar":
          unit = Unit.date;
          break;
        case "months":
          unit = Unit.month;
          verticalChange = 3;
          horizontalChange = 1;
          break;
        case "years":
          unit = Unit.year;
          verticalChange = 3;
          horizontalChange = 1;
          break;
        case "decades":
          unit = Unit.year;
          verticalChange = 30;
          horizontalChange = 10;
          break;
      }
      switch (event.key) {
        case "Esc":
        case "Escape":
          this._eventEmitters.action.emit({ e: null, action: ActionTypes$1.close });
          break;
        case " ":
        case "Enter":
          activeElement.click();
          event.stopPropagation();
          event.preventDefault();
          return;
        case "Tab":
          this._handleTab(activeElement, event);
          return;
        case "Right":
        case "ArrowRight":
          change = horizontalChange;
          flag = true;
          break;
        case "Left":
        case "ArrowLeft":
          flag = true;
          change = -horizontalChange;
          break;
        case "Down":
        case "ArrowDown":
          flag = true;
          change = verticalChange;
          break;
        case "Up":
        case "ArrowUp":
          flag = true;
          change = -verticalChange;
          break;
        case "PageDown":
          switch (currentView) {
            case "calendar":
              unit = event.shiftKey ? Unit.year : Unit.month;
              change = 1;
              break;
            case "months":
              unit = Unit.year;
              change = event.shiftKey ? 10 : 1;
              break;
            case "years":
            case "decades":
              unit = Unit.year;
              change = event.shiftKey ? 100 : 10;
              break;
          }
          flag = true;
          break;
        case "PageUp":
          switch (currentView) {
            case "calendar":
              unit = event.shiftKey ? Unit.year : Unit.month;
              change = -1;
              break;
            case "months":
              unit = Unit.year;
              change = -(event.shiftKey ? 10 : 1);
              break;
            case "years":
            case "decades":
              unit = Unit.year;
              change = -(event.shiftKey ? 100 : 10);
              break;
          }
          flag = true;
          break;
        case "Home":
          this.optionsStore.viewDate = this.optionsStore.viewDate.clone.startOf("weekDay", this.optionsStore.options.localization.startOfTheWeek);
          flag = true;
          unit = null;
          break;
        case "End":
          this.optionsStore.viewDate = this.optionsStore.viewDate.clone.endOf("weekDay", this.optionsStore.options.localization.startOfTheWeek);
          flag = true;
          unit = null;
          break;
      }
      if (!flag)
        return;
      let newViewDate = this.optionsStore.viewDate;
      if (unit) {
        newViewDate = newViewDate.clone.manipulate(change, unit);
      }
      this._eventEmitters.updateViewDate.emit(newViewDate);
      const divWithValue = this.findViewDateElement();
      if (divWithValue) {
        divWithValue.focus();
      }
      event.stopPropagation();
      event.preventDefault();
    }
    _handleKeyDownClock(event) {
      let flag = false;
      const activeElement = document.activeElement;
      const visibleElement = this.widget.querySelector(`.${Namespace.css.timeContainer} > div[style*="display: grid"]`);
      let subView = Namespace.css.clockContainer;
      if (visibleElement.classList.contains(Namespace.css.hourContainer)) {
        subView = Namespace.css.hourContainer;
      }
      if (visibleElement.classList.contains(Namespace.css.minuteContainer)) {
        subView = Namespace.css.minuteContainer;
      }
      if (visibleElement.classList.contains(Namespace.css.secondContainer)) {
        subView = Namespace.css.secondContainer;
      }
      switch (event.key) {
        case "Esc":
        case "Escape":
          this._eventEmitters.action.emit({ e: null, action: ActionTypes$1.close });
          break;
        case " ":
        case "Enter":
          activeElement.click();
          event.stopPropagation();
          event.preventDefault();
          return;
        case "Tab":
          this._handleTab(activeElement, event);
          return;
      }
      if (subView === Namespace.css.clockContainer)
        return;
      const cells = [...visibleElement.querySelectorAll("div")];
      const currentIndex = cells.indexOf(document.activeElement);
      const columnCount = 4;
      let targetIndex;
      switch (event.key) {
        case "Right":
        case "ArrowRight":
          targetIndex = currentIndex < cells.length - 1 ? currentIndex + 1 : null;
          flag = true;
          break;
        case "Left":
        case "ArrowLeft":
          flag = true;
          targetIndex = currentIndex > 0 ? currentIndex - 1 : null;
          break;
        case "Down":
        case "ArrowDown":
          targetIndex = currentIndex + columnCount < cells.length ? currentIndex + columnCount : null;
          flag = true;
          break;
        case "Up":
        case "ArrowUp":
          targetIndex = currentIndex - columnCount >= 0 ? currentIndex - columnCount : null;
          flag = true;
          break;
      }
      if (!flag)
        return;
      if (targetIndex !== void 0 && targetIndex !== null) {
        cells[targetIndex].focus();
      }
      event.stopPropagation();
      event.preventDefault();
    }
    _handleTab(activeElement, event) {
      const shiftKey = event.shiftKey;
      const addCalendarHeaderTargets = () => {
        const calendarHeaderItems = this.widget.querySelectorAll(`.${Namespace.css.calendarHeader} > div`);
        tabTargets.push(...calendarHeaderItems);
      };
      const tabTargets = [];
      console.log(this.optionsStore.currentView);
      switch (this.optionsStore.currentView) {
        case "clock":
          {
            tabTargets.push(...this.widget.querySelectorAll(`.${Namespace.css.timeContainer} > div[style*="display: grid"] > div[data-action]`));
            const clock = this.widget.querySelectorAll(`.${Namespace.css.clockContainer}`)[0];
            if (clock?.style.display === "grid") {
              tabTargets.push(...this.widget.querySelectorAll(`.${Namespace.css.toggleMeridiem}`));
            }
          }
          break;
        case "calendar":
        case "months":
        case "years":
        case "decades":
          addCalendarHeaderTargets();
          tabTargets.push(this.findViewDateElement());
          break;
      }
      const toolbarItems = this.widget.querySelectorAll(`.${Namespace.css.toolbar} > div`);
      tabTargets.push(...toolbarItems);
      const index = tabTargets.indexOf(activeElement);
      if (index === -1)
        return;
      if (shiftKey) {
        if (index === 0) {
          tabTargets[tabTargets.length - 1].focus();
        } else {
          tabTargets[index - 1].focus();
        }
      } else {
        if (index === tabTargets.length - 1) {
          tabTargets[0].focus();
        } else {
          tabTargets[index + 1].focus();
        }
      }
      event.stopPropagation();
      event.preventDefault();
    }
    _handleFocus() {
      if (this.optionsStore.currentView === "clock")
        this._handleFocusClock();
      else
        this.findViewDateElement().focus();
    }
    _handleFocusClock() {
      this.widget.querySelector(`.${Namespace.css.timeContainer} > div[style*="display: grid"]`).children[0].focus();
    }
  };
  var Actions = class {
    constructor() {
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.dates = serviceLocator.locate(Dates);
      this.validation = serviceLocator.locate(Validation);
      this.display = serviceLocator.locate(Display);
      this._eventEmitters = serviceLocator.locate(EventEmitters);
      this._eventEmitters.action.subscribe((result) => {
        this.do(result.e, result.action);
      });
    }
    /**
     * Performs the selected `action`. See ActionTypes
     * @param e This is normally a click event
     * @param action If not provided, then look for a [data-action]
     */
    //eslint-disable-next-line @typescript-eslint/no-explicit-any
    do(e4, action) {
      const currentTarget = e4?.currentTarget;
      if (currentTarget?.classList?.contains(Namespace.css.disabled))
        return;
      action = action || currentTarget?.dataset?.action;
      const lastPicked = (this.dates.lastPicked || this.optionsStore.viewDate).clone;
      switch (action) {
        case ActionTypes$1.next:
        case ActionTypes$1.previous:
          this.handleNextPrevious(action);
          break;
        case ActionTypes$1.changeCalendarView:
          this.display._showMode(1);
          this.display._updateCalendarHeader();
          break;
        case ActionTypes$1.selectMonth:
        case ActionTypes$1.selectYear:
        case ActionTypes$1.selectDecade:
          this.handleSelectCalendarMode(action, currentTarget);
          break;
        case ActionTypes$1.selectDay:
          this.handleSelectDay(currentTarget);
          break;
        case ActionTypes$1.selectHour: {
          let hour = +currentTarget.dataset.value;
          if (lastPicked.hours >= 12 && this.optionsStore.isTwelveHour)
            hour += 12;
          lastPicked.hours = hour;
          this.dates.setValue(lastPicked, this.dates.lastPickedIndex);
          this.hideOrClock(e4);
          break;
        }
        case ActionTypes$1.selectMinute: {
          lastPicked.minutes = +currentTarget.dataset.value;
          this.dates.setValue(lastPicked, this.dates.lastPickedIndex);
          this.hideOrClock(e4);
          break;
        }
        case ActionTypes$1.selectSecond: {
          lastPicked.seconds = +currentTarget.dataset.value;
          this.dates.setValue(lastPicked, this.dates.lastPickedIndex);
          this.hideOrClock(e4);
          break;
        }
        case ActionTypes$1.incrementHours:
          this.manipulateAndSet(lastPicked, Unit.hours);
          break;
        case ActionTypes$1.incrementMinutes:
          this.manipulateAndSet(lastPicked, Unit.minutes, this.optionsStore.options.stepping);
          break;
        case ActionTypes$1.incrementSeconds:
          this.manipulateAndSet(lastPicked, Unit.seconds);
          break;
        case ActionTypes$1.decrementHours:
          this.manipulateAndSet(lastPicked, Unit.hours, -1);
          break;
        case ActionTypes$1.decrementMinutes:
          this.manipulateAndSet(lastPicked, Unit.minutes, this.optionsStore.options.stepping * -1);
          break;
        case ActionTypes$1.decrementSeconds:
          this.manipulateAndSet(lastPicked, Unit.seconds, -1);
          break;
        case ActionTypes$1.toggleMeridiem:
          this.manipulateAndSet(lastPicked, Unit.hours, this.dates.lastPicked.hours >= 12 ? -12 : 12);
          break;
        case ActionTypes$1.togglePicker:
          this.handleToggle(currentTarget);
          break;
        case ActionTypes$1.showClock:
        case ActionTypes$1.showHours:
        case ActionTypes$1.showMinutes:
        case ActionTypes$1.showSeconds:
          if (!this.optionsStore.options.display.sideBySide && this.optionsStore.currentView !== "clock") {
            Collapse.hideImmediately(this.display.dateContainer);
            Collapse.showImmediately(this.display.timeContainer);
          }
          this.handleShowClockContainers(action);
          break;
        case ActionTypes$1.clear:
          this.dates.setValue(null);
          this.display._updateCalendarHeader();
          break;
        case ActionTypes$1.close:
          this.display.hide();
          break;
        case ActionTypes$1.today: {
          const day = new DateTime().setLocalization(this.optionsStore.options.localization);
          this._eventEmitters.updateViewDate.emit(day);
          if (!this.validation.isValid(day, Unit.date))
            break;
          if (this.optionsStore.options.dateRange)
            this.handleDateRange(day);
          else if (this.optionsStore.options.multipleDates) {
            this.handleMultiDate(day);
          } else {
            this.dates.setValue(day, this.dates.lastPickedIndex);
          }
          break;
        }
      }
    }
    handleShowClockContainers(action) {
      if (!this.display._hasTime) {
        Namespace.errorMessages.throwError("Cannot show clock containers when time is disabled.");
        return;
      }
      this.optionsStore.currentView = "clock";
      this.display.widget.querySelectorAll(`.${Namespace.css.timeContainer} > div`).forEach((htmlElement) => htmlElement.style.display = "none");
      let classToUse = "";
      switch (action) {
        case ActionTypes$1.showClock:
          classToUse = Namespace.css.clockContainer;
          this.display._update("clock");
          break;
        case ActionTypes$1.showHours:
          classToUse = Namespace.css.hourContainer;
          this.display._update(Unit.hours);
          break;
        case ActionTypes$1.showMinutes:
          classToUse = Namespace.css.minuteContainer;
          this.display._update(Unit.minutes);
          break;
        case ActionTypes$1.showSeconds:
          classToUse = Namespace.css.secondContainer;
          this.display._update(Unit.seconds);
          break;
      }
      const element = this.display.widget.getElementsByClassName(classToUse)[0];
      element.style.display = "grid";
      element.children[0]?.focus();
    }
    handleNextPrevious(action) {
      const { unit, step } = CalendarModes[this.optionsStore.currentCalendarViewMode];
      if (action === ActionTypes$1.next)
        this.optionsStore.viewDate.manipulate(step, unit);
      else
        this.optionsStore.viewDate.manipulate(step * -1, unit);
      this._eventEmitters.viewUpdate.emit();
      this.display._showMode();
    }
    /**
     * After setting the value it will either show the clock or hide the widget.
     * @param e
     */
    hideOrClock(e4) {
      if (!this.optionsStore.isTwelveHour && !this.optionsStore.options.display.components.minutes && !this.optionsStore.options.display.keepOpen && !this.optionsStore.options.display.inline) {
        this.display.hide();
      } else {
        this.do(e4, ActionTypes$1.showClock);
      }
    }
    /**
     * Common function to manipulate {@link lastPicked} by `unit`.
     * @param lastPicked
     * @param unit
     * @param value Value to change by
     */
    manipulateAndSet(lastPicked, unit, value = 1) {
      const newDate = lastPicked.manipulate(value, unit);
      if (this.validation.isValid(newDate, unit)) {
        this.dates.setValue(newDate, this.dates.lastPickedIndex);
      }
    }
    handleSelectCalendarMode(action, currentTarget) {
      const value = +currentTarget.dataset.value;
      switch (action) {
        case ActionTypes$1.selectMonth:
          this.optionsStore.viewDate.month = value;
          break;
        case ActionTypes$1.selectYear:
        case ActionTypes$1.selectDecade:
          this.optionsStore.viewDate.year = value;
          break;
      }
      if (this.optionsStore.currentCalendarViewMode === this.optionsStore.minimumCalendarViewMode) {
        this.dates.setValue(this.optionsStore.viewDate, this.dates.lastPickedIndex);
        if (!this.optionsStore.options.display.inline) {
          this.display.hide();
        }
      } else {
        this.display._showMode(-1);
      }
    }
    handleToggle(currentTarget) {
      if (currentTarget.getAttribute("title") === this.optionsStore.options.localization.selectDate) {
        currentTarget.setAttribute("title", this.optionsStore.options.localization.selectTime);
        currentTarget.innerHTML = this.display._iconTag(this.optionsStore.options.display.icons.time).outerHTML;
        this.display._updateCalendarHeader();
        this.optionsStore.refreshCurrentView();
      } else {
        currentTarget.setAttribute("title", this.optionsStore.options.localization.selectDate);
        currentTarget.innerHTML = this.display._iconTag(this.optionsStore.options.display.icons.date).outerHTML;
        if (this.display._hasTime) {
          this.handleShowClockContainers(ActionTypes$1.showClock);
          this.display._update("clock");
        }
      }
      this.display.widget.querySelectorAll(`.${Namespace.css.dateContainer}, .${Namespace.css.timeContainer}`).forEach((htmlElement) => Collapse.toggle(htmlElement));
      this._eventEmitters.viewUpdate.emit();
      const visible = this.display.widget.querySelector(`.${Namespace.css.collapsing} > div[style*="display: grid"]`);
      visible?.focus();
    }
    handleSelectDay(currentTarget) {
      const day = this.optionsStore.viewDate.clone;
      if (currentTarget.classList.contains(Namespace.css.old)) {
        day.manipulate(-1, Unit.month);
      }
      if (currentTarget.classList.contains(Namespace.css.new)) {
        day.manipulate(1, Unit.month);
      }
      day.date = +currentTarget.dataset.day;
      if (this.optionsStore.options.dateRange)
        this.handleDateRange(day);
      else if (this.optionsStore.options.multipleDates) {
        this.handleMultiDate(day);
      } else {
        this.dates.setValue(day, this.dates.lastPickedIndex);
      }
      if (!this.display._hasTime && !this.optionsStore.options.display.keepOpen && !this.optionsStore.options.display.inline && !this.optionsStore.options.multipleDates && !this.optionsStore.options.dateRange) {
        this.display.hide();
      }
    }
    handleMultiDate(day) {
      let index = this.dates.pickedIndex(day, Unit.date);
      if (index !== -1) {
        this.dates.setValue(null, index);
      } else {
        index = this.dates.lastPickedIndex + 1;
        if (this.dates.picked.length === 0)
          index = 0;
        this.dates.setValue(day, index);
      }
    }
    handleDateRange(day) {
      switch (this.dates.picked.length) {
        case 2: {
          this.dates.clear();
          break;
        }
        case 1: {
          const other = this.dates.picked[0];
          if (day.getTime() === other.getTime()) {
            this.dates.clear();
            break;
          }
          if (day.isBefore(other)) {
            this.dates.setValue(day, 0);
            this.dates.setValue(other, 1);
            return;
          } else {
            this.dates.setValue(day, 1);
            return;
          }
        }
      }
      this.dates.setValue(day, 0);
    }
  };
  var TempusDominus = class {
    constructor(element, options = {}) {
      this._subscribers = {};
      this._isDisabled = false;
      this._inputChangeEvent = (event) => {
        const internallyTriggered = event?.detail;
        if (internallyTriggered)
          return;
        const setViewDate = () => {
          if (this.dates.lastPicked)
            this.optionsStore.viewDate = this.dates.lastPicked.clone;
        };
        const value = this.optionsStore.input.value;
        if (this.optionsStore.options.multipleDates || this.optionsStore.options.dateRange) {
          try {
            const valueSplit = value.split(this.optionsStore.options.multipleDatesSeparator);
            for (let i4 = 0; i4 < valueSplit.length; i4++) {
              this.dates.setFromInput(valueSplit[i4], i4);
            }
            setViewDate();
          } catch {
            console.warn("TD: Something went wrong trying to set the multipleDates values from the input field.");
          }
        } else {
          this.dates.setFromInput(value, 0);
          setViewDate();
        }
      };
      this._toggleClickEvent = () => {
        if (this.optionsStore.element?.disabled || this.optionsStore.input?.disabled || //if we just have the input and allow input toggle is enabled, then don't cause a toggle
        this.optionsStore.toggle.nodeName === "INPUT" && this.optionsStore.toggle?.type === "text" && this.optionsStore.options.allowInputToggle)
          return;
        this.toggle();
      };
      this._openClickEvent = () => {
        if (this.optionsStore.element?.disabled || this.optionsStore.input?.disabled)
          return;
        if (!this.display.isVisible)
          this.show();
      };
      setupServiceLocator();
      this._eventEmitters = serviceLocator.locate(EventEmitters);
      this.optionsStore = serviceLocator.locate(OptionsStore);
      this.display = serviceLocator.locate(Display);
      this.dates = serviceLocator.locate(Dates);
      this.actions = serviceLocator.locate(Actions);
      if (!element) {
        Namespace.errorMessages.mustProvideElement();
      }
      this.optionsStore.element = element;
      this._initializeOptions(options, DefaultOptions, true);
      this.optionsStore.viewDate.setLocalization(this.optionsStore.options.localization);
      this.optionsStore.unset = true;
      this._initializeInput();
      this._initializeToggle();
      if (this.optionsStore.options.display.inline)
        this.display.show();
      this._eventEmitters.triggerEvent.subscribe((e4) => {
        this._triggerEvent(e4);
      });
      this._eventEmitters.viewUpdate.subscribe(() => {
        this._viewUpdate();
      });
      this._eventEmitters.updateViewDate.subscribe((dateTime) => {
        this.viewDate = dateTime;
      });
    }
    get viewDate() {
      return this.optionsStore.viewDate;
    }
    set viewDate(value) {
      this.optionsStore.viewDate = value;
      this.optionsStore.viewDate.setLocalization(this.optionsStore.options.localization);
      this.display._update(this.optionsStore.currentView === "clock" ? "clock" : "calendar");
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Update the picker options. If `reset` is provide `options` will be merged with DefaultOptions instead.
     * @param options
     * @param reset
     * @public
     */
    updateOptions(options, reset = false) {
      if (reset)
        this._initializeOptions(options, DefaultOptions);
      else
        this._initializeOptions(options, this.optionsStore.options);
      this.optionsStore.viewDate.setLocalization(this.optionsStore.options.localization);
      this.display.refreshCurrentView();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Toggles the picker open or closed. If the picker is disabled, nothing will happen.
     * @public
     */
    toggle() {
      if (this._isDisabled)
        return;
      this.display.toggle();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Shows the picker unless the picker is disabled.
     * @public
     */
    show() {
      if (this._isDisabled)
        return;
      this.display.show();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Hides the picker unless the picker is disabled.
     * @public
     */
    hide() {
      this.display.hide();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Disables the picker and the target input field.
     * @public
     */
    disable() {
      this._isDisabled = true;
      this.optionsStore.input?.setAttribute("disabled", "disabled");
      this.display.hide();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Enables the picker and the target input field.
     * @public
     */
    enable() {
      this._isDisabled = false;
      this.optionsStore.input?.removeAttribute("disabled");
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Clears all the selected dates
     * @public
     */
    clear() {
      this.optionsStore.input.value = "";
      this.dates.clear();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Allows for a direct subscription to picker events, without having to use addEventListener on the element.
     * @param eventTypes See Namespace.Events
     * @param callbacks Function to call when event is triggered
     * @public
     */
    subscribe(eventTypes, callbacks) {
      if (typeof eventTypes === "string") {
        eventTypes = [eventTypes];
      }
      let callBackArray;
      if (!Array.isArray(callbacks)) {
        callBackArray = [callbacks];
      } else {
        callBackArray = callbacks;
      }
      if (eventTypes.length !== callBackArray.length) {
        Namespace.errorMessages.subscribeMismatch();
      }
      const returnArray = [];
      for (let i4 = 0; i4 < eventTypes.length; i4++) {
        const eventType = eventTypes[i4];
        if (!Array.isArray(this._subscribers[eventType])) {
          this._subscribers[eventType] = [];
        }
        this._subscribers[eventType].push(callBackArray[i4]);
        returnArray.push({
          unsubscribe: this._unsubscribe.bind(this, eventType, this._subscribers[eventType].length - 1)
        });
        if (eventTypes.length === 1) {
          return returnArray[0];
        }
      }
      return returnArray;
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Hides the picker and removes event listeners
     */
    dispose() {
      this.display.hide();
      this.display._dispose();
      this._eventEmitters.destroy();
      this.optionsStore.input?.removeEventListener("change", this._inputChangeEvent);
      if (this.optionsStore.options.allowInputToggle) {
        this.optionsStore.input?.removeEventListener("click", this._openClickEvent);
        this.optionsStore.input?.removeEventListener("focus", this._openClickEvent);
      }
      this.optionsStore.toggle?.removeEventListener("click", this._toggleClickEvent);
      this.optionsStore.toggle?.removeEventListener("keydown", this._handleToggleKeydown);
      this._subscribers = {};
    }
    /**
     * Updates the options to use the provided language.
     * THe language file must be loaded first.
     * @param language
     */
    locale(language) {
      const asked = loadedLocales[language];
      if (!asked)
        return;
      this.updateOptions({
        localization: asked
      });
    }
    /**
     * Triggers an event like ChangeEvent when the picker has updated the value
     * of a selected date.
     * @param event Accepts a BaseEvent object.
     * @private
     */
    _triggerEvent(event) {
      event.viewMode = this.optionsStore.currentView;
      const isChangeEvent = event.type === Namespace.events.change;
      if (isChangeEvent) {
        const { date, oldDate, isClear } = event;
        if (date && oldDate && date.isSame(oldDate) || !isClear && !date && !oldDate) {
          return;
        }
        this._handleAfterChangeEvent(event);
        this.optionsStore.input?.dispatchEvent(
          //eslint-disable-next-line @typescript-eslint/no-explicit-any
          new CustomEvent("change", { detail: event })
        );
        if (this.optionsStore.toggle) {
          let label = this.optionsStore.options.localization.toggleAriaLabel;
          if (this.dates.picked.length > 0) {
            const picked = this.dates.picked.map((x4) => x4.format()).join(", ");
            label = `${label}, ${picked}`;
          }
          this.optionsStore.toggle.ariaLabel = label;
        }
      }
      this.optionsStore.element.dispatchEvent(
        //eslint-disable-next-line @typescript-eslint/no-explicit-any
        new CustomEvent(event.type, { detail: event })
      );
      if (window.jQuery) {
        const $5 = window.jQuery;
        if (isChangeEvent && this.optionsStore.input) {
          $5(this.optionsStore.input).trigger(event);
        } else {
          $5(this.optionsStore.element).trigger(event);
        }
      }
      this._publish(event);
    }
    _publish(event) {
      if (!Array.isArray(this._subscribers[event.type])) {
        return;
      }
      this._subscribers[event.type].forEach((callback) => {
        callback(event);
      });
    }
    /**
     * Fires a ViewUpdate event when, for example, the month view is changed.
     * @private
     */
    _viewUpdate() {
      this._triggerEvent({
        type: Namespace.events.update,
        viewDate: this.optionsStore.viewDate.clone
      });
    }
    _unsubscribe(eventName, index) {
      this._subscribers[eventName].splice(index, 1);
    }
    /**
     * Merges two Option objects together and validates options type
     * @param config new Options
     * @param mergeTo Options to merge into
     * @param includeDataset When true, the elements data-td attributes will be included in the
     * @private
     */
    _initializeOptions(config2, mergeTo, includeDataset = false) {
      let newConfig = OptionConverter.deepCopy(config2);
      newConfig = OptionConverter._mergeOptions(newConfig, mergeTo);
      if (includeDataset)
        newConfig = OptionConverter._dataToOptions(this.optionsStore.element, newConfig);
      OptionConverter._validateConflicts(newConfig);
      newConfig.viewDate = newConfig.viewDate.setLocalization(newConfig.localization);
      if (!this.optionsStore.viewDate.isSame(newConfig.viewDate)) {
        this.optionsStore.viewDate = newConfig.viewDate;
      }
      if (newConfig.display.components.year) {
        this.optionsStore.minimumCalendarViewMode = 2;
      }
      if (newConfig.display.components.month) {
        this.optionsStore.minimumCalendarViewMode = 1;
      }
      if (newConfig.display.components.date) {
        this.optionsStore.minimumCalendarViewMode = 0;
      }
      this.optionsStore.currentCalendarViewMode = Math.max(this.optionsStore.minimumCalendarViewMode, this.optionsStore.currentCalendarViewMode);
      if (CalendarModes[this.optionsStore.currentCalendarViewMode].name !== newConfig.display.viewMode) {
        this.optionsStore.currentCalendarViewMode = Math.max(CalendarModes.findIndex((x4) => x4.name === newConfig.display.viewMode), this.optionsStore.minimumCalendarViewMode);
      }
      if (this.display?.isVisible) {
        this.display._update("all");
      }
      if (newConfig.display.components.useTwentyfourHour && newConfig.localization.hourCycle === void 0)
        newConfig.localization.hourCycle = "h24";
      else if (newConfig.localization.hourCycle === void 0) {
        newConfig.localization.hourCycle = guessHourCycle(newConfig.localization.locale);
      }
      this.optionsStore.options = newConfig;
      if (newConfig.restrictions.maxDate && this.viewDate.isAfter(newConfig.restrictions.maxDate))
        this.viewDate = newConfig.restrictions.maxDate.clone;
      if (newConfig.restrictions.minDate && this.viewDate.isBefore(newConfig.restrictions.minDate))
        this.viewDate = newConfig.restrictions.minDate.clone;
    }
    /**
     * Checks if an input field is being used, attempts to locate one and sets an
     * event listener if found.
     * @private
     */
    _initializeInput() {
      if (this.optionsStore.element.tagName == "INPUT") {
        this.optionsStore.input = this.optionsStore.element;
      } else {
        const query = this.optionsStore.element.dataset.tdTargetInput;
        if (query == void 0 || query == "nearest") {
          this.optionsStore.input = this.optionsStore.element.querySelector("input");
        } else {
          this.optionsStore.input = this.optionsStore.element.querySelector(query);
        }
      }
      if (!this.optionsStore.input)
        return;
      if (!this.optionsStore.input.value && this.optionsStore.options.defaultDate)
        this.optionsStore.input.value = this.dates.formatInput(this.optionsStore.options.defaultDate);
      this.optionsStore.input.addEventListener("change", this._inputChangeEvent);
      if (this.optionsStore.options.allowInputToggle) {
        this.optionsStore.input.addEventListener("click", this._openClickEvent);
        this.optionsStore.input.addEventListener("focus", this._openClickEvent);
      }
      if (this.optionsStore.input.value) {
        this._inputChangeEvent();
      }
    }
    /**
     * Attempts to locate a toggle for the picker and sets an event listener
     * @private
     */
    _initializeToggle() {
      if (this.optionsStore.options.display.inline)
        return;
      let query = this.optionsStore.element.dataset.tdTargetToggle;
      if (query == "nearest") {
        query = '[data-td-toggle="datetimepicker"]';
      }
      this.optionsStore.toggle = query == void 0 ? this.optionsStore.element : this.optionsStore.element.querySelector(query);
      if (this.optionsStore.toggle == void 0)
        return;
      this.optionsStore.toggle.addEventListener("click", this._toggleClickEvent);
      if (this.optionsStore.toggle !== this.optionsStore.element) {
        this.optionsStore.toggle.addEventListener("keydown", this._handleToggleKeydown.bind(this));
      }
    }
    /**
     * If the option is enabled this will render the clock view after a date pick.
     * @param e change event
     * @private
     */
    _handleAfterChangeEvent(e4) {
      if (
        // options is disabled
        !this.optionsStore.options.promptTimeOnDateChange || this.optionsStore.options.multipleDates || this.optionsStore.options.display.inline || this.optionsStore.options.display.sideBySide || // time is disabled
        !this.display._hasTime || // clock component is already showing
        this.display.widget?.getElementsByClassName(Namespace.css.show)[0].classList.contains(Namespace.css.timeContainer)
      )
        return;
      if (!e4.oldDate && this.optionsStore.options.useCurrent || e4.oldDate && e4.date?.isSame(e4.oldDate)) {
        return;
      }
      clearTimeout(this._currentPromptTimeTimeout);
      this._currentPromptTimeTimeout = setTimeout(() => {
        if (this.display.widget) {
          this._eventEmitters.action.emit({
            e: {
              currentTarget: this.display.widget.querySelector('[data-action="togglePicker"]')
            },
            action: ActionTypes$1.togglePicker
          });
        }
      }, this.optionsStore.options.promptTimeOnDateChangeTransitionDelay);
    }
    _handleToggleKeydown(event) {
      if (event.key !== " " && event.key !== "Enter")
        return;
      this.optionsStore.toggle.click();
      event.stopPropagation();
      event.preventDefault();
    }
  };
  var loadedLocales = {};
  var loadLocale = (l4) => {
    if (loadedLocales[l4.name])
      return;
    loadedLocales[l4.name] = l4.localization;
  };
  var locale = (l4) => {
    const asked = loadedLocales[l4];
    if (!asked)
      return;
    DefaultOptions.localization = asked;
  };
  var extend2 = function(plugin, option = void 0) {
    if (!plugin)
      return tempusDominus;
    if (!plugin.installed) {
      plugin(option, { TempusDominus, Dates, Display, DateTime, Namespace }, tempusDominus);
      plugin.installed = true;
    }
    return tempusDominus;
  };
  var version = "v6.10.4";
  var tempusDominus = {
    TempusDominus,
    extend: extend2,
    loadLocale,
    locale,
    Namespace,
    DefaultOptions,
    DateTime,
    Unit,
    version,
    DefaultEnLocalization
  };

  // controllers/datepicker_controller.js
  var import_fa_five = __toESM(require_fa_five());
  var import_dayjs = __toESM(require_dayjs_min());
  var import_customParseFormat = __toESM(require_customParseFormat());
  var import_customDateFormat = __toESM(require_customDateFormat());
  extend2(import_customDateFormat.default);
  extend2(import_fa_five.load);
  var datepicker_controller_default = class extends Controller {
    static targets = ["date", "dateLinked1", "dateLinked2", "datetime", "datetimeLinked1", "datetimeLinked2", "linkedListener"];
    // Date Pickers
    dateTargetConnected(target) {
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      this.setDateInput(target, unsetDefaultDate);
    }
    dateLinked1TargetConnected(target) {
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      this.setDateInput(target, unsetDefaultDate);
    }
    dateLinked2TargetConnected(target) {
      import_dayjs.default.extend(import_customParseFormat.default);
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      let linked2 = this.setDateInput(target, unsetDefaultDate);
      this.dateLinked1Targets.forEach((linked1) => {
        this.linkDatepickers(linked2, target, linked1);
      });
    }
    // Date & Time Pickers
    datetimeTargetConnected(target) {
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      this.setDatetimeInput(target, unsetDefaultDate);
    }
    datetimeLinked1TargetConnected(target) {
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      this.setDatetimeInput(target, unsetDefaultDate);
    }
    datetimeLinked2TargetConnected(target) {
      import_dayjs.default.extend(import_customParseFormat.default);
      let unsetDefaultDate = target.hasAttribute("data-default") && target.dataset.default == "false";
      let linked2 = this.setDatetimeInput(target, unsetDefaultDate);
      this.datetimeLinked1Targets.forEach((linked1) => {
        this.linkDatepickers(linked2, target, linked1);
      });
    }
    setDateInput(target, unsetDefaultDate) {
      const hour = parseInt(target.dataset.hour ?? "0", 10);
      let options = {
        display: {
          components: {
            clock: false,
            hours: false,
            minutes: false,
            seconds: false
          }
        },
        localization: {
          locale: "en-GB",
          format: "dd/MM/yyyy",
          startOfTheWeek: 1
        },
        defaultDate: DateTime.convert((0, import_dayjs.default)().startOf("day").add(hour, "hours").toDate(), "en-GB")
      };
      if (unsetDefaultDate) {
        delete options.defaultDate;
      }
      return new TempusDominus(target, options);
    }
    setDatetimeInput(target, unsetDefaultDate) {
      const hour = parseInt(target.dataset.hour ?? "0", 10);
      const minute = parseInt(target.dataset.minute ?? "0", 10);
      let options = {
        display: {
          viewMode: this.defaultViewValue
        },
        localization: {
          locale: "en-GB",
          hourCycle: "h23",
          format: "dd/MM/yyyy HH:mm",
          startOfTheWeek: 1
        },
        defaultDate: DateTime.convert((0, import_dayjs.default)().startOf("day").add(hour, "hours").add(minute, "minutes").toDate(), "en-GB")
      };
      if (target.hasAttribute("data-default-view")) {
        options.display = {
          viewMode: target.dataset.defaultView
        };
      }
      if (unsetDefaultDate) {
        delete options.defaultDate;
      }
      return new TempusDominus(target, options);
    }
    linkDatepickers(linked2, target, linked1) {
      if (linked1.dataset.pair === target.dataset.pair) {
        if (linked1.value != "") {
          linked2.updateOptions({
            restrictions: {
              minDate: linked1.value
            }
          });
        }
        linked1.addEventListener("change.td", (e4) => {
          this.setDurationEndInputs(linked2, target, linked1, e4.detail.date);
        });
      }
    }
    setDurationEndInputs(linked2, target, datetime1, date) {
      linked2.updateOptions({
        restrictions: {
          minDate: date
        }
      });
      let duration_field = "duration";
      if (target.hasAttribute("data-duration-field")) {
        duration_field = target.dataset.durationField;
      }
      if (datetime1.hasAttribute(`data-${duration_field}`)) {
        date = (0, import_dayjs.default)(date).add(datetime1.getAttribute(`data-${duration_field}`), "hours").toDate();
        linked2.dates.setValue(DateTime.convert(date, "en-GB"));
      }
    }
  };

  // controllers/filter_controller.js
  var filter_controller_exports = {};
  __export(filter_controller_exports, {
    default: () => filter_controller_default
  });
  var filter_controller_default = class extends Controller {
    connect() {
      let controller = this;
      document.querySelectorAll(".filter").forEach(function(filter) {
        controller.checkFilterState(filter);
      });
    }
    toggleFilterMenu(event) {
      event.stopPropagation();
      document.querySelectorAll(".tempus-dominus-widget").forEach(function(datepicker) {
        datepicker.classList.remove("show");
      });
      let openFilter = this.element.querySelector(".filter__form.display--block");
      document.querySelectorAll(".filter__form").forEach(function(filter) {
        filter.classList.remove("display--block");
      });
      let clickedFilter = event.target.closest(".filter").querySelector(".filter__form");
      if (openFilter != clickedFilter) {
        clickedFilter.classList.toggle("display--block");
      }
    }
    closeOutside(event) {
      let openFilter = this.element.querySelector(".filter__form.display--block");
      let openDatepicker = document.getElementsByClassName("tempus-dominus-widget");
      if (openFilter != null && (openFilter === event.target || openFilter.contains(event.target))) return;
      if (openDatepicker != null) {
        for (const datepicker of openDatepicker) {
          if (datepicker === event.target || datepicker.contains(event.target)) {
            if (event.target.classList.contains("day")) {
              datepicker.classList.remove("show");
            }
            return;
          }
        }
      }
      document.querySelectorAll(".filter__form").forEach(function(filter) {
        filter.classList.remove("display--block");
      });
    }
    updateFilterState(event) {
      let filter = event.target.closest(".filter");
      this.checkFilterState(filter);
    }
    checkFilterState(filter) {
      let state = false;
      filter.querySelectorAll("input", "select", "textarea").forEach(function(input) {
        if (input.type == "checkbox") {
          if (input.checked) {
            state = true;
          }
        } else if (input.type == "select-multiple" || input.type == "number" || input.type == "text") {
          if (input.value.length > 0) {
            state = true;
          }
        }
      });
      if (state) {
        filter.querySelector(".filter__name").classList.add("filter__name--active");
      } else {
        filter.querySelector(".filter__name").classList.remove("filter__name--active");
      }
    }
  };

  // controllers/form_controller.js
  var form_controller_exports = {};
  __export(form_controller_exports, {
    default: () => form_controller_default
  });
  var form_controller_default = class extends Controller {
    static targets = ["parentSelect", "childSelect", "input"];
    initialize() {
      this.parentInitialValues = {};
      this.childrenOptions = {};
    }
    // FILTER SELECT OPTIONS LOGIC
    parentSelectTargetConnected(target) {
      this.parentInitialValues[target.dataset.parentId] = target.selectedOptions[0].value;
    }
    childSelectTargetConnected(target) {
      this.childrenOptions[target.dataset.childId] = Array.from(target.options);
      const parent = this.element.querySelector(`[data-parent-id="${target.dataset.childId}"]`);
      this.filterOptions(target.dataset.childId, parent.selectedOptions[0].value);
    }
    updateChildOptions(event) {
      this.filterOptions(event.currentTarget.dataset.parentId, event.currentTarget.value);
    }
    filterOptions(parentId, selectedOptionId) {
      const children = this.element.querySelectorAll(`[data-child-id="${parentId}"]`);
      const parent = this.element.querySelector(`[data-parent-id="${parentId}"]`);
      children.forEach((child) => {
        this.childrenOptions[parentId].forEach((option) => {
          if (option.dataset.selectedOptionId === selectedOptionId || option.dataset.selectedOptionId === void 0) {
            child.insertAdjacentElement("beforeend", option);
          } else {
            if (parent.selectedOptions[0].value !== this.parentInitialValues[parentId]) {
              child.value = "";
            }
            option.remove();
          }
        });
      });
    }
    // TRANSFER DATA TO INPUT LOGIC
    transferInfoToInput(event) {
      this.inputTarget.value = event.currentTarget.selectedOptions[0].dataset.info;
    }
  };

  // controllers/menu_controller.js
  var menu_controller_exports = {};
  __export(menu_controller_exports, {
    default: () => menu_controller_default
  });
  var menu_controller_default = class extends Controller {
    toggleHamburger(event) {
      event.target.closest(".hamburger").classList.toggle("is-active");
      document.querySelector("#primary-menu").classList.toggle("is-active");
    }
    toggleSubMenu(event) {
      event.stopPropagation();
      let openMenu = this.element.querySelector(".menu--sub.display--block");
      this.closeAllMenus();
      let clickedMenu = event.target.closest(".menu-item--sub").querySelector(".menu--sub");
      let clickedChevron = event.target.closest(".menu-item--sub").querySelector(".menu-item__chevron");
      if (openMenu != clickedMenu) {
        clickedMenu.classList.toggle("display--block");
        clickedChevron.classList.toggle("menu-item__chevron--open");
      }
    }
    toggleActionMenu(event) {
      let actionMenu = event.target.closest(".action-menu");
      this.closeAllMenus(actionMenu);
      actionMenu.classList.toggle("action-menu--show");
    }
    closeOutside(event) {
      let openMenu = this.element.querySelector(".menu--sub.display--block, .menu-item__chevron.menu-item__chevron--open, .action-menu.action-menu--show");
      if ((openMenu == null || openMenu === event.target || openMenu.contains(event.target)) && !this.isElementALinkOrButton(event.target)) {
        return;
      }
      this.closeAllMenus();
    }
    closeAllMenus(exceptFor) {
      document.querySelectorAll(".menu--sub, .menu-item__chevron, .action-menu").forEach((menu) => {
        if (menu !== exceptFor) {
          menu.classList.remove("display--block", "menu-item__chevron--open", "action-menu--show");
        }
      });
    }
    // checks if the element is a link or a form button or a child of a link or a form button
    isElementALinkOrButton(element) {
      return ["A", "BUTTON"].includes(element.tagName) || element.closest("A") || element.closest("BUTTON");
    }
  };

  // controllers/modal_controller.js
  var modal_controller_exports = {};
  __export(modal_controller_exports, {
    default: () => modal_controller_default
  });
  var modal_controller_default = class extends Controller {
    connect() {
      if (this.element.classList.contains("modal-screen") && !this.element.classList.contains("display--none")) {
        document.body.style.overflow = "hidden";
      }
    }
    disconnect() {
      document.body.style.overflow = "auto";
    }
    openModal(event) {
      document.getElementById(event.currentTarget.dataset.modalId).classList.remove("display--none");
    }
    toggleModal(event) {
      document.getElementById(event.currentTarget.dataset.modalId).classList.toggle("display--none");
    }
    remove() {
      this.element.remove();
    }
    removeFrame() {
      this.element.parentNode.remove();
    }
  };

  // controllers/multi_upload_controller.js
  var multi_upload_controller_exports = {};
  __export(multi_upload_controller_exports, {
    default: () => multi_upload_controller_default
  });

  // ../../node_modules/@uppy/utils/lib/hasProperty.js
  function has(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  }

  // ../../node_modules/@uppy/utils/lib/Translator.js
  function _classPrivateFieldLooseBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id = 0;
  function _classPrivateFieldLooseKey(name) {
    return "__private_" + id++ + "_" + name;
  }
  function insertReplacement(source, rx, replacement) {
    const newParts = [];
    source.forEach((chunk) => {
      if (typeof chunk !== "string") {
        return newParts.push(chunk);
      }
      return rx[Symbol.split](chunk).forEach((raw, i4, list) => {
        if (raw !== "") {
          newParts.push(raw);
        }
        if (i4 < list.length - 1) {
          newParts.push(replacement);
        }
      });
    });
    return newParts;
  }
  function interpolate(phrase, options) {
    const dollarRegex = /\$/g;
    const dollarBillsYall = "$$$$";
    let interpolated = [phrase];
    if (options == null) return interpolated;
    for (const arg of Object.keys(options)) {
      if (arg !== "_") {
        let replacement = options[arg];
        if (typeof replacement === "string") {
          replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
        }
        interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, "g"), replacement);
      }
    }
    return interpolated;
  }
  var _apply = /* @__PURE__ */ _classPrivateFieldLooseKey("apply");
  var Translator = class {
    /**
     * @param {object|Array<object>} locales - locale or list of locales.
     */
    constructor(locales) {
      Object.defineProperty(this, _apply, {
        value: _apply2
      });
      this.locale = {
        strings: {},
        pluralize(n4) {
          if (n4 === 1) {
            return 0;
          }
          return 1;
        }
      };
      if (Array.isArray(locales)) {
        locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);
      } else {
        _classPrivateFieldLooseBase(this, _apply)[_apply](locales);
      }
    }
    /**
     * Public translate method
     *
     * @param {string} key
     * @param {object} options with values that will be used later to replace placeholders in string
     * @returns {string} translated (and interpolated)
     */
    translate(key, options) {
      return this.translateArray(key, options).join("");
    }
    /**
     * Get a translation and return the translated and interpolated parts as an array.
     *
     * @param {string} key
     * @param {object} options with values that will be used to replace placeholders
     * @returns {Array} The translated and interpolated parts, in order.
     */
    translateArray(key, options) {
      if (!has(this.locale.strings, key)) {
        throw new Error(`missing string: ${key}`);
      }
      const string = this.locale.strings[key];
      const hasPluralForms = typeof string === "object";
      if (hasPluralForms) {
        if (options && typeof options.smart_count !== "undefined") {
          const plural = this.locale.pluralize(options.smart_count);
          return interpolate(string[plural], options);
        }
        throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
      }
      return interpolate(string, options);
    }
  };
  function _apply2(locale2) {
    if (!(locale2 != null && locale2.strings)) {
      return;
    }
    const prevLocale = this.locale;
    this.locale = {
      ...prevLocale,
      strings: {
        ...prevLocale.strings,
        ...locale2.strings
      }
    };
    this.locale.pluralize = locale2.pluralize || prevLocale.pluralize;
  }

  // ../../node_modules/@uppy/core/lib/Uppy.js
  var import_namespace_emitter = __toESM(require_namespace_emitter(), 1);

  // ../../node_modules/nanoid/non-secure/index.js
  var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  var nanoid = (size = 21) => {
    let id14 = "";
    let i4 = size;
    while (i4--) {
      id14 += urlAlphabet[Math.random() * 64 | 0];
    }
    return id14;
  };

  // ../../node_modules/@uppy/core/lib/Uppy.js
  var import_lodash = __toESM(require_lodash(), 1);

  // ../../node_modules/@uppy/store-default/lib/index.js
  function _classPrivateFieldLooseBase2(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id2 = 0;
  function _classPrivateFieldLooseKey2(name) {
    return "__private_" + id2++ + "_" + name;
  }
  var packageJson = {
    "version": "3.0.2"
  };
  var _callbacks = /* @__PURE__ */ _classPrivateFieldLooseKey2("callbacks");
  var _publish = /* @__PURE__ */ _classPrivateFieldLooseKey2("publish");
  var DefaultStore = class {
    constructor() {
      Object.defineProperty(this, _publish, {
        value: _publish2
      });
      Object.defineProperty(this, _callbacks, {
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      this.state = {};
    }
    getState() {
      return this.state;
    }
    setState(patch) {
      const prevState = {
        ...this.state
      };
      const nextState = {
        ...this.state,
        ...patch
      };
      this.state = nextState;
      _classPrivateFieldLooseBase2(this, _publish)[_publish](prevState, nextState, patch);
    }
    subscribe(listener) {
      _classPrivateFieldLooseBase2(this, _callbacks)[_callbacks].add(listener);
      return () => {
        _classPrivateFieldLooseBase2(this, _callbacks)[_callbacks].delete(listener);
      };
    }
  };
  function _publish2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _classPrivateFieldLooseBase2(this, _callbacks)[_callbacks].forEach((listener) => {
      listener(...args);
    });
  }
  DefaultStore.VERSION = packageJson.version;
  var lib_default = DefaultStore;

  // ../../node_modules/@uppy/utils/lib/getFileNameAndExtension.js
  function getFileNameAndExtension(fullFileName) {
    const lastDot = fullFileName.lastIndexOf(".");
    if (lastDot === -1 || lastDot === fullFileName.length - 1) {
      return {
        name: fullFileName,
        extension: void 0
      };
    }
    return {
      name: fullFileName.slice(0, lastDot),
      extension: fullFileName.slice(lastDot + 1)
    };
  }

  // ../../node_modules/@uppy/utils/lib/mimeTypes.js
  var mimeTypes_default = {
    md: "text/markdown",
    markdown: "text/markdown",
    mp4: "video/mp4",
    mp3: "audio/mp3",
    svg: "image/svg+xml",
    jpg: "image/jpeg",
    png: "image/png",
    webp: "image/webp",
    gif: "image/gif",
    heic: "image/heic",
    heif: "image/heif",
    yaml: "text/yaml",
    yml: "text/yaml",
    csv: "text/csv",
    tsv: "text/tab-separated-values",
    tab: "text/tab-separated-values",
    avi: "video/x-msvideo",
    mks: "video/x-matroska",
    mkv: "video/x-matroska",
    mov: "video/quicktime",
    dicom: "application/dicom",
    doc: "application/msword",
    docm: "application/vnd.ms-word.document.macroenabled.12",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    dot: "application/msword",
    dotm: "application/vnd.ms-word.template.macroenabled.12",
    dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    xla: "application/vnd.ms-excel",
    xlam: "application/vnd.ms-excel.addin.macroenabled.12",
    xlc: "application/vnd.ms-excel",
    xlf: "application/x-xliff+xml",
    xlm: "application/vnd.ms-excel",
    xls: "application/vnd.ms-excel",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
    xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    xlt: "application/vnd.ms-excel",
    xltm: "application/vnd.ms-excel.template.macroenabled.12",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    xlw: "application/vnd.ms-excel",
    txt: "text/plain",
    text: "text/plain",
    conf: "text/plain",
    log: "text/plain",
    pdf: "application/pdf",
    zip: "application/zip",
    "7z": "application/x-7z-compressed",
    rar: "application/x-rar-compressed",
    tar: "application/x-tar",
    gz: "application/gzip",
    dmg: "application/x-apple-diskimage"
  };

  // ../../node_modules/@uppy/utils/lib/getFileType.js
  function getFileType(file) {
    var _getFileNameAndExtens;
    if (file.type) return file.type;
    const fileExtension = file.name ? (_getFileNameAndExtens = getFileNameAndExtension(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;
    if (fileExtension && fileExtension in mimeTypes_default) {
      return mimeTypes_default[fileExtension];
    }
    return "application/octet-stream";
  }

  // ../../node_modules/@uppy/utils/lib/generateFileID.js
  function encodeCharacter(character) {
    return character.charCodeAt(0).toString(32);
  }
  function encodeFilename(name) {
    let suffix = "";
    return name.replace(/[^A-Z0-9]/ig, (character) => {
      suffix += `-${encodeCharacter(character)}`;
      return "/";
    }) + suffix;
  }
  function generateFileID(file) {
    let id14 = "uppy";
    if (typeof file.name === "string") {
      id14 += `-${encodeFilename(file.name.toLowerCase())}`;
    }
    if (file.type !== void 0) {
      id14 += `-${file.type}`;
    }
    if (file.meta && typeof file.meta.relativePath === "string") {
      id14 += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
    }
    if (file.data.size !== void 0) {
      id14 += `-${file.data.size}`;
    }
    if (file.data.lastModified !== void 0) {
      id14 += `-${file.data.lastModified}`;
    }
    return id14;
  }

  // ../../node_modules/@uppy/core/lib/supportsUploadProgress.js
  function supportsUploadProgress(userAgent) {
    if (userAgent == null && typeof navigator !== "undefined") {
      userAgent = navigator.userAgent;
    }
    if (!userAgent) return true;
    const m4 = /Edge\/(\d+\.\d+)/.exec(userAgent);
    if (!m4) return true;
    const edgeVersion = m4[1];
    let [major, minor] = edgeVersion.split(".");
    major = parseInt(major, 10);
    minor = parseInt(minor, 10);
    if (major < 15 || major === 15 && minor < 15063) {
      return true;
    }
    if (major > 18 || major === 18 && minor >= 18218) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@uppy/core/lib/getFileName.js
  function getFileName(fileType, fileDescriptor) {
    if (fileDescriptor.name) {
      return fileDescriptor.name;
    }
    if (fileType.split("/")[0] === "image") {
      return `${fileType.split("/")[0]}.${fileType.split("/")[1]}`;
    }
    return "noname";
  }

  // ../../node_modules/@uppy/utils/lib/getTimeStamp.js
  function pad(number) {
    return number < 10 ? `0${number}` : number.toString();
  }
  function getTimeStamp() {
    const date = /* @__PURE__ */ new Date();
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    const seconds = pad(date.getSeconds());
    return `${hours}:${minutes}:${seconds}`;
  }

  // ../../node_modules/@uppy/core/lib/loggers.js
  var justErrorsLogger = {
    debug: () => {
    },
    warn: () => {
    },
    error: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
    }
  };
  var debugLogger = {
    debug: function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return console.debug(`[Uppy] [${getTimeStamp()}]`, ...args);
    },
    warn: function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return console.warn(`[Uppy] [${getTimeStamp()}]`, ...args);
    },
    error: function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
    }
  };

  // ../../node_modules/@uppy/core/lib/Restricter.js
  var import_prettier_bytes = __toESM(require_prettierBytes(), 1);
  var import_mime_match = __toESM(require_mime_match(), 1);
  var defaultOptions = {
    maxFileSize: null,
    minFileSize: null,
    maxTotalFileSize: null,
    maxNumberOfFiles: null,
    minNumberOfFiles: null,
    allowedFileTypes: null,
    requiredMetaFields: []
  };
  var RestrictionError = class extends Error {
    constructor() {
      super(...arguments);
      this.isRestriction = true;
    }
  };
  var Restricter = class {
    constructor(getOpts, i18n) {
      this.i18n = i18n;
      this.getOpts = () => {
        const opts = getOpts();
        if (opts.restrictions.allowedFileTypes != null && !Array.isArray(opts.restrictions.allowedFileTypes)) {
          throw new TypeError("`restrictions.allowedFileTypes` must be an array");
        }
        return opts;
      };
    }
    validate(file, files) {
      const {
        maxFileSize,
        minFileSize,
        maxTotalFileSize,
        maxNumberOfFiles,
        allowedFileTypes
      } = this.getOpts().restrictions;
      if (maxNumberOfFiles) {
        const nonGhostFiles = files.filter((f4) => !f4.isGhost);
        if (nonGhostFiles.length + 1 > maxNumberOfFiles) {
          throw new RestrictionError(`${this.i18n("youCanOnlyUploadX", {
            smart_count: maxNumberOfFiles
          })}`);
        }
      }
      if (allowedFileTypes) {
        const isCorrectFileType = allowedFileTypes.some((type) => {
          if (type.includes("/")) {
            if (!file.type) return false;
            return (0, import_mime_match.default)(file.type.replace(/;.*?$/, ""), type);
          }
          if (type[0] === "." && file.extension) {
            return file.extension.toLowerCase() === type.slice(1).toLowerCase();
          }
          return false;
        });
        if (!isCorrectFileType) {
          const allowedFileTypesString = allowedFileTypes.join(", ");
          throw new RestrictionError(this.i18n("youCanOnlyUploadFileTypes", {
            types: allowedFileTypesString
          }));
        }
      }
      if (maxTotalFileSize && file.size != null) {
        const totalFilesSize = files.reduce((total, f4) => total + f4.size, file.size);
        if (totalFilesSize > maxTotalFileSize) {
          throw new RestrictionError(this.i18n("exceedsSize", {
            size: (0, import_prettier_bytes.default)(maxTotalFileSize),
            file: file.name
          }));
        }
      }
      if (maxFileSize && file.size != null && file.size > maxFileSize) {
        throw new RestrictionError(this.i18n("exceedsSize", {
          size: (0, import_prettier_bytes.default)(maxFileSize),
          file: file.name
        }));
      }
      if (minFileSize && file.size != null && file.size < minFileSize) {
        throw new RestrictionError(this.i18n("inferiorSize", {
          size: (0, import_prettier_bytes.default)(minFileSize)
        }));
      }
    }
    validateMinNumberOfFiles(files) {
      const {
        minNumberOfFiles
      } = this.getOpts().restrictions;
      if (Object.keys(files).length < minNumberOfFiles) {
        throw new RestrictionError(this.i18n("youHaveToAtLeastSelectX", {
          smart_count: minNumberOfFiles
        }));
      }
    }
    getMissingRequiredMetaFields(file) {
      const error2 = new RestrictionError(this.i18n("missingRequiredMetaFieldOnFile", {
        fileName: file.name
      }));
      const {
        requiredMetaFields
      } = this.getOpts().restrictions;
      const missingFields = [];
      for (const field of requiredMetaFields) {
        if (!Object.hasOwn(file.meta, field) || file.meta[field] === "") {
          missingFields.push(field);
        }
      }
      return {
        missingFields,
        error: error2
      };
    }
  };

  // ../../node_modules/@uppy/core/lib/locale.js
  var locale_default = {
    strings: {
      addBulkFilesFailed: {
        0: "Failed to add %{smart_count} file due to an internal error",
        1: "Failed to add %{smart_count} files due to internal errors"
      },
      youCanOnlyUploadX: {
        0: "You can only upload %{smart_count} file",
        1: "You can only upload %{smart_count} files"
      },
      youHaveToAtLeastSelectX: {
        0: "You have to select at least %{smart_count} file",
        1: "You have to select at least %{smart_count} files"
      },
      exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
      missingRequiredMetaField: "Missing required meta fields",
      missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
      inferiorSize: "This file is smaller than the allowed size of %{size}",
      youCanOnlyUploadFileTypes: "You can only upload: %{types}",
      noMoreFilesAllowed: "Cannot add more files",
      noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
      companionError: "Connection with Companion failed",
      authAborted: "Authentication aborted",
      companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
      failedToUpload: "Failed to upload %{file}",
      noInternetConnection: "No Internet connection",
      connectedToInternet: "Connected to the Internet",
      // Strings for remote providers
      noFilesFound: "You have no files or folders here",
      selectX: {
        0: "Select %{smart_count}",
        1: "Select %{smart_count}"
      },
      allFilesFromFolderNamed: "All files from folder %{name}",
      openFolderNamed: "Open folder %{name}",
      cancel: "Cancel",
      logOut: "Log out",
      filter: "Filter",
      resetFilter: "Reset filter",
      loading: "Loading...",
      authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
      authenticateWith: "Connect to %{pluginName}",
      signInWithGoogle: "Sign in with Google",
      searchImages: "Search for images",
      enterTextToSearch: "Enter text to search for images",
      search: "Search",
      emptyFolderAdded: "No files were added from empty folder",
      folderAlreadyAdded: 'The folder "%{folder}" was already added',
      folderAdded: {
        0: "Added %{smart_count} file from %{folder}",
        1: "Added %{smart_count} files from %{folder}"
      }
    }
  };

  // ../../node_modules/@uppy/core/lib/Uppy.js
  var _Symbol$for;
  var _Symbol$for2;
  function _classPrivateFieldLooseBase3(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id3 = 0;
  function _classPrivateFieldLooseKey3(name) {
    return "__private_" + id3++ + "_" + name;
  }
  var packageJson2 = {
    "version": "3.0.6"
  };
  var _plugins = /* @__PURE__ */ _classPrivateFieldLooseKey3("plugins");
  var _restricter = /* @__PURE__ */ _classPrivateFieldLooseKey3("restricter");
  var _storeUnsubscribe = /* @__PURE__ */ _classPrivateFieldLooseKey3("storeUnsubscribe");
  var _emitter = /* @__PURE__ */ _classPrivateFieldLooseKey3("emitter");
  var _preProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey3("preProcessors");
  var _uploaders = /* @__PURE__ */ _classPrivateFieldLooseKey3("uploaders");
  var _postProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey3("postProcessors");
  var _informAndEmit = /* @__PURE__ */ _classPrivateFieldLooseKey3("informAndEmit");
  var _checkRequiredMetaFieldsOnFile = /* @__PURE__ */ _classPrivateFieldLooseKey3("checkRequiredMetaFieldsOnFile");
  var _checkRequiredMetaFields = /* @__PURE__ */ _classPrivateFieldLooseKey3("checkRequiredMetaFields");
  var _assertNewUploadAllowed = /* @__PURE__ */ _classPrivateFieldLooseKey3("assertNewUploadAllowed");
  var _checkAndCreateFileStateObject = /* @__PURE__ */ _classPrivateFieldLooseKey3("checkAndCreateFileStateObject");
  var _startIfAutoProceed = /* @__PURE__ */ _classPrivateFieldLooseKey3("startIfAutoProceed");
  var _addListeners = /* @__PURE__ */ _classPrivateFieldLooseKey3("addListeners");
  var _updateOnlineStatus = /* @__PURE__ */ _classPrivateFieldLooseKey3("updateOnlineStatus");
  var _createUpload = /* @__PURE__ */ _classPrivateFieldLooseKey3("createUpload");
  var _getUpload = /* @__PURE__ */ _classPrivateFieldLooseKey3("getUpload");
  var _removeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey3("removeUpload");
  var _runUpload = /* @__PURE__ */ _classPrivateFieldLooseKey3("runUpload");
  _Symbol$for = Symbol.for("uppy test: getPlugins");
  _Symbol$for2 = Symbol.for("uppy test: createUpload");
  var Uppy = class {
    /** @type {Record<string, BasePlugin[]>} */
    /**
     * Instantiate Uppy
     *
     * @param {object} opts  Uppy options
     */
    constructor(_opts) {
      Object.defineProperty(this, _runUpload, {
        value: _runUpload2
      });
      Object.defineProperty(this, _removeUpload, {
        value: _removeUpload2
      });
      Object.defineProperty(this, _getUpload, {
        value: _getUpload2
      });
      Object.defineProperty(this, _createUpload, {
        value: _createUpload2
      });
      Object.defineProperty(this, _addListeners, {
        value: _addListeners2
      });
      Object.defineProperty(this, _startIfAutoProceed, {
        value: _startIfAutoProceed2
      });
      Object.defineProperty(this, _checkAndCreateFileStateObject, {
        value: _checkAndCreateFileStateObject2
      });
      Object.defineProperty(this, _assertNewUploadAllowed, {
        value: _assertNewUploadAllowed2
      });
      Object.defineProperty(this, _checkRequiredMetaFields, {
        value: _checkRequiredMetaFields2
      });
      Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
        value: _checkRequiredMetaFieldsOnFile2
      });
      Object.defineProperty(this, _informAndEmit, {
        value: _informAndEmit2
      });
      Object.defineProperty(this, _plugins, {
        writable: true,
        value: /* @__PURE__ */ Object.create(null)
      });
      Object.defineProperty(this, _restricter, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _storeUnsubscribe, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _emitter, {
        writable: true,
        value: (0, import_namespace_emitter.default)()
      });
      Object.defineProperty(this, _preProcessors, {
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      Object.defineProperty(this, _uploaders, {
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      Object.defineProperty(this, _postProcessors, {
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      Object.defineProperty(this, _updateOnlineStatus, {
        writable: true,
        value: this.updateOnlineStatus.bind(this)
      });
      this.defaultLocale = locale_default;
      const defaultOptions4 = {
        id: "uppy",
        autoProceed: false,
        allowMultipleUploadBatches: true,
        debug: false,
        restrictions: defaultOptions,
        meta: {},
        onBeforeFileAdded: (currentFile) => currentFile,
        onBeforeUpload: (files) => files,
        store: new lib_default(),
        logger: justErrorsLogger,
        infoTimeout: 5e3
      };
      this.opts = {
        ...defaultOptions4,
        ..._opts,
        restrictions: {
          ...defaultOptions4.restrictions,
          ..._opts && _opts.restrictions
        }
      };
      if (_opts && _opts.logger && _opts.debug) {
        this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning");
      } else if (_opts && _opts.debug) {
        this.opts.logger = debugLogger;
      }
      this.log(`Using Core v${this.constructor.VERSION}`);
      this.i18nInit();
      this.calculateProgress = (0, import_lodash.default)(this.calculateProgress.bind(this), 500, {
        leading: true,
        trailing: true
      });
      this.store = this.opts.store;
      this.setState({
        plugins: {},
        files: {},
        currentUploads: {},
        allowNewUpload: true,
        capabilities: {
          uploadProgress: supportsUploadProgress(),
          individualCancellation: true,
          resumableUploads: false
        },
        totalProgress: 0,
        meta: {
          ...this.opts.meta
        },
        info: [],
        recoveredState: null
      });
      _classPrivateFieldLooseBase3(this, _restricter)[_restricter] = new Restricter(() => this.opts, this.i18n);
      _classPrivateFieldLooseBase3(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {
        this.emit("state-update", prevState, nextState, patch);
        this.updateAll(nextState);
      });
      if (this.opts.debug && typeof window !== "undefined") {
        window[this.opts.id] = this;
      }
      _classPrivateFieldLooseBase3(this, _addListeners)[_addListeners]();
    }
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      _classPrivateFieldLooseBase3(this, _emitter)[_emitter].emit(event, ...args);
    }
    on(event, callback) {
      _classPrivateFieldLooseBase3(this, _emitter)[_emitter].on(event, callback);
      return this;
    }
    once(event, callback) {
      _classPrivateFieldLooseBase3(this, _emitter)[_emitter].once(event, callback);
      return this;
    }
    off(event, callback) {
      _classPrivateFieldLooseBase3(this, _emitter)[_emitter].off(event, callback);
      return this;
    }
    /**
     * Iterate on all plugins and run `update` on them.
     * Called each time state changes.
     *
     */
    updateAll(state) {
      this.iteratePlugins((plugin) => {
        plugin.update(state);
      });
    }
    /**
     * Updates state with a patch
     *
     * @param {object} patch {foo: 'bar'}
     */
    setState(patch) {
      this.store.setState(patch);
    }
    /**
     * Returns current state.
     *
     * @returns {object}
     */
    getState() {
      return this.store.getState();
    }
    /**
     * Shorthand to set state for a specific file.
     */
    setFileState(fileID, state) {
      if (!this.getState().files[fileID]) {
        throw new Error(`Can\u2019t set state for ${fileID} (the file could have been removed)`);
      }
      this.setState({
        files: {
          ...this.getState().files,
          [fileID]: {
            ...this.getState().files[fileID],
            ...state
          }
        }
      });
    }
    i18nInit() {
      const translator = new Translator([this.defaultLocale, this.opts.locale]);
      this.i18n = translator.translate.bind(translator);
      this.i18nArray = translator.translateArray.bind(translator);
      this.locale = translator.locale;
    }
    setOptions(newOpts) {
      this.opts = {
        ...this.opts,
        ...newOpts,
        restrictions: {
          ...this.opts.restrictions,
          ...newOpts && newOpts.restrictions
        }
      };
      if (newOpts.meta) {
        this.setMeta(newOpts.meta);
      }
      this.i18nInit();
      if (newOpts.locale) {
        this.iteratePlugins((plugin) => {
          plugin.setOptions();
        });
      }
      this.setState();
    }
    resetProgress() {
      const defaultProgress = {
        percentage: 0,
        bytesUploaded: 0,
        uploadComplete: false,
        uploadStarted: null
      };
      const files = {
        ...this.getState().files
      };
      const updatedFiles = {};
      Object.keys(files).forEach((fileID) => {
        const updatedFile = {
          ...files[fileID]
        };
        updatedFile.progress = {
          ...updatedFile.progress,
          ...defaultProgress
        };
        updatedFiles[fileID] = updatedFile;
      });
      this.setState({
        files: updatedFiles,
        totalProgress: 0
      });
      this.emit("reset-progress");
    }
    addPreProcessor(fn4) {
      _classPrivateFieldLooseBase3(this, _preProcessors)[_preProcessors].add(fn4);
    }
    removePreProcessor(fn4) {
      return _classPrivateFieldLooseBase3(this, _preProcessors)[_preProcessors].delete(fn4);
    }
    addPostProcessor(fn4) {
      _classPrivateFieldLooseBase3(this, _postProcessors)[_postProcessors].add(fn4);
    }
    removePostProcessor(fn4) {
      return _classPrivateFieldLooseBase3(this, _postProcessors)[_postProcessors].delete(fn4);
    }
    addUploader(fn4) {
      _classPrivateFieldLooseBase3(this, _uploaders)[_uploaders].add(fn4);
    }
    removeUploader(fn4) {
      return _classPrivateFieldLooseBase3(this, _uploaders)[_uploaders].delete(fn4);
    }
    setMeta(data) {
      const updatedMeta = {
        ...this.getState().meta,
        ...data
      };
      const updatedFiles = {
        ...this.getState().files
      };
      Object.keys(updatedFiles).forEach((fileID) => {
        updatedFiles[fileID] = {
          ...updatedFiles[fileID],
          meta: {
            ...updatedFiles[fileID].meta,
            ...data
          }
        };
      });
      this.log("Adding metadata:");
      this.log(data);
      this.setState({
        meta: updatedMeta,
        files: updatedFiles
      });
    }
    setFileMeta(fileID, data) {
      const updatedFiles = {
        ...this.getState().files
      };
      if (!updatedFiles[fileID]) {
        this.log("Was trying to set metadata for a file that has been removed: ", fileID);
        return;
      }
      const newMeta = {
        ...updatedFiles[fileID].meta,
        ...data
      };
      updatedFiles[fileID] = {
        ...updatedFiles[fileID],
        meta: newMeta
      };
      this.setState({
        files: updatedFiles
      });
    }
    /**
     * Get a file object.
     *
     * @param {string} fileID The ID of the file object to return.
     */
    getFile(fileID) {
      return this.getState().files[fileID];
    }
    /**
     * Get all files in an array.
     */
    getFiles() {
      const {
        files
      } = this.getState();
      return Object.values(files);
    }
    getObjectOfFilesPerState() {
      const {
        files: filesObject,
        totalProgress,
        error: error2
      } = this.getState();
      const files = Object.values(filesObject);
      const inProgressFiles = files.filter((_ref) => {
        let {
          progress
        } = _ref;
        return !progress.uploadComplete && progress.uploadStarted;
      });
      const newFiles = files.filter((file) => !file.progress.uploadStarted);
      const startedFiles = files.filter((file) => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess);
      const uploadStartedFiles = files.filter((file) => file.progress.uploadStarted);
      const pausedFiles = files.filter((file) => file.isPaused);
      const completeFiles = files.filter((file) => file.progress.uploadComplete);
      const erroredFiles = files.filter((file) => file.error);
      const inProgressNotPausedFiles = inProgressFiles.filter((file) => !file.isPaused);
      const processingFiles = files.filter((file) => file.progress.preprocess || file.progress.postprocess);
      return {
        newFiles,
        startedFiles,
        uploadStartedFiles,
        pausedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted: uploadStartedFiles.length > 0,
        isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,
        isAllErrored: !!error2 && erroredFiles.length === files.length,
        isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,
        isUploadInProgress: inProgressFiles.length > 0,
        isSomeGhost: files.some((file) => file.isGhost)
      };
    }
    /*
    * @constructs
    * @param { Error } error
    * @param { undefined } file
    */
    /*
    * @constructs
    * @param { RestrictionError } error
    * @param { UppyFile | undefined } file
    */
    validateRestrictions(file, files) {
      if (files === void 0) {
        files = this.getFiles();
      }
      try {
        _classPrivateFieldLooseBase3(this, _restricter)[_restricter].validate(file, files);
      } catch (err) {
        return err;
      }
      return null;
    }
    checkIfFileAlreadyExists(fileID) {
      const {
        files
      } = this.getState();
      if (files[fileID] && !files[fileID].isGhost) {
        return true;
      }
      return false;
    }
    /**
     * Create a file state object based on user-provided `addFile()` options.
     *
     * Note this is extremely side-effectful and should only be done when a file state object
     * will be added to state immediately afterward!
     *
     * The `files` value is passed in because it may be updated by the caller without updating the store.
     */
    /**
     * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
     * try to guess file type in a clever way, check file against restrictions,
     * and start an upload if `autoProceed === true`.
     *
     * @param {object} file object to add
     * @returns {string} id for the added file
     */
    addFile(file) {
      _classPrivateFieldLooseBase3(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);
      const {
        files
      } = this.getState();
      let newFile = _classPrivateFieldLooseBase3(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file);
      if (files[newFile.id] && files[newFile.id].isGhost) {
        newFile = {
          ...files[newFile.id],
          data: file.data,
          isGhost: false
        };
        this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
      }
      this.setState({
        files: {
          ...files,
          [newFile.id]: newFile
        }
      });
      this.emit("file-added", newFile);
      this.emit("files-added", [newFile]);
      this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);
      _classPrivateFieldLooseBase3(this, _startIfAutoProceed)[_startIfAutoProceed]();
      return newFile.id;
    }
    /**
     * Add multiple files to `state.files`. See the `addFile()` documentation.
     *
     * If an error occurs while adding a file, it is logged and the user is notified.
     * This is good for UI plugins, but not for programmatic use.
     * Programmatic users should usually still use `addFile()` on individual files.
     */
    addFiles(fileDescriptors) {
      _classPrivateFieldLooseBase3(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
      const files = {
        ...this.getState().files
      };
      const newFiles = [];
      const errors = [];
      for (let i4 = 0; i4 < fileDescriptors.length; i4++) {
        try {
          let newFile = _classPrivateFieldLooseBase3(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i4]);
          if (files[newFile.id] && files[newFile.id].isGhost) {
            newFile = {
              ...files[newFile.id],
              data: fileDescriptors[i4].data,
              isGhost: false
            };
            this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
          }
          files[newFile.id] = newFile;
          newFiles.push(newFile);
        } catch (err) {
          if (!err.isRestriction) {
            errors.push(err);
          }
        }
      }
      this.setState({
        files
      });
      newFiles.forEach((newFile) => {
        this.emit("file-added", newFile);
      });
      this.emit("files-added", newFiles);
      if (newFiles.length > 5) {
        this.log(`Added batch of ${newFiles.length} files`);
      } else {
        Object.keys(newFiles).forEach((fileID) => {
          this.log(`Added file: ${newFiles[fileID].name}
 id: ${newFiles[fileID].id}
 type: ${newFiles[fileID].type}`);
        });
      }
      if (newFiles.length > 0) {
        _classPrivateFieldLooseBase3(this, _startIfAutoProceed)[_startIfAutoProceed]();
      }
      if (errors.length > 0) {
        let message = "Multiple errors occurred while adding files:\n";
        errors.forEach((subError) => {
          message += `
 * ${subError.message}`;
        });
        this.info({
          message: this.i18n("addBulkFilesFailed", {
            smart_count: errors.length
          }),
          details: message
        }, "error", this.opts.infoTimeout);
        if (typeof AggregateError === "function") {
          throw new AggregateError(errors, message);
        } else {
          const err = new Error(message);
          err.errors = errors;
          throw err;
        }
      }
    }
    removeFiles(fileIDs, reason) {
      const {
        files,
        currentUploads
      } = this.getState();
      const updatedFiles = {
        ...files
      };
      const updatedUploads = {
        ...currentUploads
      };
      const removedFiles = /* @__PURE__ */ Object.create(null);
      fileIDs.forEach((fileID) => {
        if (files[fileID]) {
          removedFiles[fileID] = files[fileID];
          delete updatedFiles[fileID];
        }
      });
      function fileIsNotRemoved(uploadFileID) {
        return removedFiles[uploadFileID] === void 0;
      }
      Object.keys(updatedUploads).forEach((uploadID) => {
        const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);
        if (newFileIDs.length === 0) {
          delete updatedUploads[uploadID];
          return;
        }
        const {
          capabilities
        } = this.getState();
        if (newFileIDs.length !== currentUploads[uploadID].fileIDs.length && !capabilities.individualCancellation) {
          throw new Error("individualCancellation is disabled");
        }
        updatedUploads[uploadID] = {
          ...currentUploads[uploadID],
          fileIDs: newFileIDs
        };
      });
      const stateUpdate = {
        currentUploads: updatedUploads,
        files: updatedFiles
      };
      if (Object.keys(updatedFiles).length === 0) {
        stateUpdate.allowNewUpload = true;
        stateUpdate.error = null;
        stateUpdate.recoveredState = null;
      }
      this.setState(stateUpdate);
      this.calculateTotalProgress();
      const removedFileIDs = Object.keys(removedFiles);
      removedFileIDs.forEach((fileID) => {
        this.emit("file-removed", removedFiles[fileID], reason);
      });
      if (removedFileIDs.length > 5) {
        this.log(`Removed ${removedFileIDs.length} files`);
      } else {
        this.log(`Removed files: ${removedFileIDs.join(", ")}`);
      }
    }
    removeFile(fileID, reason) {
      if (reason === void 0) {
        reason = null;
      }
      this.removeFiles([fileID], reason);
    }
    pauseResume(fileID) {
      if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
        return void 0;
      }
      const wasPaused = this.getFile(fileID).isPaused || false;
      const isPaused = !wasPaused;
      this.setFileState(fileID, {
        isPaused
      });
      this.emit("upload-pause", fileID, isPaused);
      return isPaused;
    }
    pauseAll() {
      const updatedFiles = {
        ...this.getState().files
      };
      const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
        return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
      });
      inProgressUpdatedFiles.forEach((file) => {
        const updatedFile = {
          ...updatedFiles[file],
          isPaused: true
        };
        updatedFiles[file] = updatedFile;
      });
      this.setState({
        files: updatedFiles
      });
      this.emit("pause-all");
    }
    resumeAll() {
      const updatedFiles = {
        ...this.getState().files
      };
      const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
        return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
      });
      inProgressUpdatedFiles.forEach((file) => {
        const updatedFile = {
          ...updatedFiles[file],
          isPaused: false,
          error: null
        };
        updatedFiles[file] = updatedFile;
      });
      this.setState({
        files: updatedFiles
      });
      this.emit("resume-all");
    }
    retryAll() {
      const updatedFiles = {
        ...this.getState().files
      };
      const filesToRetry = Object.keys(updatedFiles).filter((file) => {
        return updatedFiles[file].error;
      });
      filesToRetry.forEach((file) => {
        const updatedFile = {
          ...updatedFiles[file],
          isPaused: false,
          error: null
        };
        updatedFiles[file] = updatedFile;
      });
      this.setState({
        files: updatedFiles,
        error: null
      });
      this.emit("retry-all", filesToRetry);
      if (filesToRetry.length === 0) {
        return Promise.resolve({
          successful: [],
          failed: []
        });
      }
      const uploadID = _classPrivateFieldLooseBase3(this, _createUpload)[_createUpload](filesToRetry, {
        forceAllowNewUpload: true
        // create new upload even if allowNewUpload: false
      });
      return _classPrivateFieldLooseBase3(this, _runUpload)[_runUpload](uploadID);
    }
    cancelAll(_temp) {
      let {
        reason = "user"
      } = _temp === void 0 ? {} : _temp;
      this.emit("cancel-all", {
        reason
      });
      if (reason === "user") {
        const {
          files
        } = this.getState();
        const fileIDs = Object.keys(files);
        if (fileIDs.length) {
          this.removeFiles(fileIDs, "cancel-all");
        }
        this.setState({
          totalProgress: 0,
          error: null,
          recoveredState: null
        });
      }
    }
    retryUpload(fileID) {
      this.setFileState(fileID, {
        error: null,
        isPaused: false
      });
      this.emit("upload-retry", fileID);
      const uploadID = _classPrivateFieldLooseBase3(this, _createUpload)[_createUpload]([fileID], {
        forceAllowNewUpload: true
        // create new upload even if allowNewUpload: false
      });
      return _classPrivateFieldLooseBase3(this, _runUpload)[_runUpload](uploadID);
    }
    logout() {
      this.iteratePlugins((plugin) => {
        if (plugin.provider && plugin.provider.logout) {
          plugin.provider.logout();
        }
      });
    }
    calculateProgress(file, data) {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
      this.setFileState(file.id, {
        progress: {
          ...this.getFile(file.id).progress,
          bytesUploaded: data.bytesUploaded,
          bytesTotal: data.bytesTotal,
          percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
        }
      });
      this.calculateTotalProgress();
    }
    calculateTotalProgress() {
      const files = this.getFiles();
      const inProgress = files.filter((file) => {
        return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
      });
      if (inProgress.length === 0) {
        this.emit("progress", 0);
        this.setState({
          totalProgress: 0
        });
        return;
      }
      const sizedFiles = inProgress.filter((file) => file.progress.bytesTotal != null);
      const unsizedFiles = inProgress.filter((file) => file.progress.bytesTotal == null);
      if (sizedFiles.length === 0) {
        const progressMax = inProgress.length * 100;
        const currentProgress = unsizedFiles.reduce((acc, file) => {
          return acc + file.progress.percentage;
        }, 0);
        const totalProgress2 = Math.round(currentProgress / progressMax * 100);
        this.setState({
          totalProgress: totalProgress2
        });
        return;
      }
      let totalSize = sizedFiles.reduce((acc, file) => {
        return acc + file.progress.bytesTotal;
      }, 0);
      const averageSize = totalSize / sizedFiles.length;
      totalSize += averageSize * unsizedFiles.length;
      let uploadedSize = 0;
      sizedFiles.forEach((file) => {
        uploadedSize += file.progress.bytesUploaded;
      });
      unsizedFiles.forEach((file) => {
        uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
      });
      let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);
      if (totalProgress > 100) {
        totalProgress = 100;
      }
      this.setState({
        totalProgress
      });
      this.emit("progress", totalProgress);
    }
    /**
     * Registers listeners for all global actions, like:
     * `error`, `file-removed`, `upload-progress`
     */
    updateOnlineStatus() {
      const online = typeof window.navigator.onLine !== "undefined" ? window.navigator.onLine : true;
      if (!online) {
        this.emit("is-offline");
        this.info(this.i18n("noInternetConnection"), "error", 0);
        this.wasOffline = true;
      } else {
        this.emit("is-online");
        if (this.wasOffline) {
          this.emit("back-online");
          this.info(this.i18n("connectedToInternet"), "success", 3e3);
          this.wasOffline = false;
        }
      }
    }
    getID() {
      return this.opts.id;
    }
    /**
     * Registers a plugin with Core.
     *
     * @param {object} Plugin object
     * @param {object} [opts] object with options to be passed to Plugin
     * @returns {object} self for chaining
     */
    // eslint-disable-next-line no-shadow
    use(Plugin, opts) {
      if (typeof Plugin !== "function") {
        const msg = `Expected a plugin class, but got ${Plugin === null ? "null" : typeof Plugin}. Please verify that the plugin was imported and spelled correctly.`;
        throw new TypeError(msg);
      }
      const plugin = new Plugin(this, opts);
      const pluginId = plugin.id;
      if (!pluginId) {
        throw new Error("Your plugin must have an id");
      }
      if (!plugin.type) {
        throw new Error("Your plugin must have a type");
      }
      const existsPluginAlready = this.getPlugin(pluginId);
      if (existsPluginAlready) {
        const msg = `Already found a plugin named '${existsPluginAlready.id}'. Tried to use: '${pluginId}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;
        throw new Error(msg);
      }
      if (Plugin.VERSION) {
        this.log(`Using ${pluginId} v${Plugin.VERSION}`);
      }
      if (plugin.type in _classPrivateFieldLooseBase3(this, _plugins)[_plugins]) {
        _classPrivateFieldLooseBase3(this, _plugins)[_plugins][plugin.type].push(plugin);
      } else {
        _classPrivateFieldLooseBase3(this, _plugins)[_plugins][plugin.type] = [plugin];
      }
      plugin.install();
      return this;
    }
    /**
     * Find one Plugin by name.
     *
     * @param {string} id plugin id
     * @returns {BasePlugin|undefined}
     */
    getPlugin(id14) {
      for (const plugins of Object.values(_classPrivateFieldLooseBase3(this, _plugins)[_plugins])) {
        const foundPlugin = plugins.find((plugin) => plugin.id === id14);
        if (foundPlugin != null) return foundPlugin;
      }
      return void 0;
    }
    [_Symbol$for](type) {
      return _classPrivateFieldLooseBase3(this, _plugins)[_plugins][type];
    }
    /**
     * Iterate through all `use`d plugins.
     *
     * @param {Function} method that will be run on each plugin
     */
    iteratePlugins(method) {
      Object.values(_classPrivateFieldLooseBase3(this, _plugins)[_plugins]).flat(1).forEach(method);
    }
    /**
     * Uninstall and remove a plugin.
     *
     * @param {object} instance The plugin instance to remove.
     */
    removePlugin(instance) {
      this.log(`Removing plugin ${instance.id}`);
      this.emit("plugin-remove", instance);
      if (instance.uninstall) {
        instance.uninstall();
      }
      const list = _classPrivateFieldLooseBase3(this, _plugins)[_plugins][instance.type];
      const index = list.findIndex((item) => item.id === instance.id);
      if (index !== -1) {
        list.splice(index, 1);
      }
      const state = this.getState();
      const updatedState = {
        plugins: {
          ...state.plugins,
          [instance.id]: void 0
        }
      };
      this.setState(updatedState);
    }
    /**
     * Uninstall all plugins and close down this Uppy instance.
     */
    close(_temp2) {
      let {
        reason
      } = _temp2 === void 0 ? {} : _temp2;
      this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
      this.cancelAll({
        reason
      });
      _classPrivateFieldLooseBase3(this, _storeUnsubscribe)[_storeUnsubscribe]();
      this.iteratePlugins((plugin) => {
        this.removePlugin(plugin);
      });
      if (typeof window !== "undefined" && window.removeEventListener) {
        window.removeEventListener("online", _classPrivateFieldLooseBase3(this, _updateOnlineStatus)[_updateOnlineStatus]);
        window.removeEventListener("offline", _classPrivateFieldLooseBase3(this, _updateOnlineStatus)[_updateOnlineStatus]);
      }
    }
    hideInfo() {
      const {
        info
      } = this.getState();
      this.setState({
        info: info.slice(1)
      });
      this.emit("info-hidden");
    }
    /**
     * Set info message in `state.info`, so that UI plugins like `Informer`
     * can display the message.
     *
     * @param {string | object} message Message to be displayed by the informer
     * @param {string} [type]
     * @param {number} [duration]
     */
    info(message, type, duration) {
      if (type === void 0) {
        type = "info";
      }
      if (duration === void 0) {
        duration = 3e3;
      }
      const isComplexMessage = typeof message === "object";
      this.setState({
        info: [...this.getState().info, {
          type,
          message: isComplexMessage ? message.message : message,
          details: isComplexMessage ? message.details : null
        }]
      });
      setTimeout(() => this.hideInfo(), duration);
      this.emit("info-visible");
    }
    /**
     * Passes messages to a function, provided in `opts.logger`.
     * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
     *
     * @param {string|object} message to log
     * @param {string} [type] optional `error` or `warning`
     */
    log(message, type) {
      const {
        logger: logger2
      } = this.opts;
      switch (type) {
        case "error":
          logger2.error(message);
          break;
        case "warning":
          logger2.warn(message);
          break;
        default:
          logger2.debug(message);
          break;
      }
    }
    /**
     * Restore an upload by its ID.
     */
    restore(uploadID) {
      this.log(`Core: attempting to restore upload "${uploadID}"`);
      if (!this.getState().currentUploads[uploadID]) {
        _classPrivateFieldLooseBase3(this, _removeUpload)[_removeUpload](uploadID);
        return Promise.reject(new Error("Nonexistent upload"));
      }
      return _classPrivateFieldLooseBase3(this, _runUpload)[_runUpload](uploadID);
    }
    /**
     * Create an upload for a bunch of files.
     *
     * @param {Array<string>} fileIDs File IDs to include in this upload.
     * @returns {string} ID of this upload.
     */
    [_Symbol$for2]() {
      return _classPrivateFieldLooseBase3(this, _createUpload)[_createUpload](...arguments);
    }
    /**
     * Add data to an upload's result object.
     *
     * @param {string} uploadID The ID of the upload.
     * @param {object} data Data properties to add to the result object.
     */
    addResultData(uploadID, data) {
      if (!_classPrivateFieldLooseBase3(this, _getUpload)[_getUpload](uploadID)) {
        this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
        return;
      }
      const {
        currentUploads
      } = this.getState();
      const currentUpload = {
        ...currentUploads[uploadID],
        result: {
          ...currentUploads[uploadID].result,
          ...data
        }
      };
      this.setState({
        currentUploads: {
          ...currentUploads,
          [uploadID]: currentUpload
        }
      });
    }
    /**
     * Remove an upload, eg. if it has been canceled or completed.
     *
     * @param {string} uploadID The ID of the upload.
     */
    /**
     * Start an upload for all the files that are not currently being uploaded.
     *
     * @returns {Promise}
     */
    upload() {
      var _classPrivateFieldLoo;
      if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase3(this, _plugins)[_plugins].uploader) != null && _classPrivateFieldLoo.length)) {
        this.log("No uploader type plugins are used", "warning");
      }
      let {
        files
      } = this.getState();
      const onBeforeUploadResult = this.opts.onBeforeUpload(files);
      if (onBeforeUploadResult === false) {
        return Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false"));
      }
      if (onBeforeUploadResult && typeof onBeforeUploadResult === "object") {
        files = onBeforeUploadResult;
        this.setState({
          files
        });
      }
      return Promise.resolve().then(() => _classPrivateFieldLooseBase3(this, _restricter)[_restricter].validateMinNumberOfFiles(files)).catch((err) => {
        _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](err);
        throw err;
      }).then(() => {
        if (!_classPrivateFieldLooseBase3(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) {
          throw new RestrictionError(this.i18n("missingRequiredMetaField"));
        }
      }).catch((err) => {
        throw err;
      }).then(() => {
        const {
          currentUploads
        } = this.getState();
        const currentlyUploadingFiles = Object.values(currentUploads).flatMap((curr) => curr.fileIDs);
        const waitingFileIDs = [];
        Object.keys(files).forEach((fileID) => {
          const file = this.getFile(fileID);
          if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
            waitingFileIDs.push(file.id);
          }
        });
        const uploadID = _classPrivateFieldLooseBase3(this, _createUpload)[_createUpload](waitingFileIDs);
        return _classPrivateFieldLooseBase3(this, _runUpload)[_runUpload](uploadID);
      }).catch((err) => {
        this.emit("error", err);
        this.log(err, "error");
        throw err;
      });
    }
  };
  function _informAndEmit2(error2, file) {
    const {
      message,
      details = ""
    } = error2;
    if (error2.isRestriction) {
      this.emit("restriction-failed", file, error2);
    } else {
      this.emit("error", error2);
    }
    this.info({
      message,
      details
    }, "error", this.opts.infoTimeout);
    this.log(error2, "warning");
  }
  function _checkRequiredMetaFieldsOnFile2(file) {
    const {
      missingFields,
      error: error2
    } = _classPrivateFieldLooseBase3(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);
    if (missingFields.length > 0) {
      this.setFileState(file.id, {
        missingRequiredMetaFields: missingFields
      });
      this.log(error2.message);
      this.emit("restriction-failed", file, error2);
      return false;
    }
    return true;
  }
  function _checkRequiredMetaFields2(files) {
    let success = true;
    for (const file of Object.values(files)) {
      if (!_classPrivateFieldLooseBase3(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) {
        success = false;
      }
    }
    return success;
  }
  function _assertNewUploadAllowed2(file) {
    const {
      allowNewUpload
    } = this.getState();
    if (allowNewUpload === false) {
      const error2 = new RestrictionError(this.i18n("noMoreFilesAllowed"));
      _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](error2, file);
      throw error2;
    }
  }
  function _checkAndCreateFileStateObject2(files, fileDescriptor) {
    if (fileDescriptor instanceof File) {
      fileDescriptor = {
        name: fileDescriptor.name,
        type: fileDescriptor.type,
        size: fileDescriptor.size,
        data: fileDescriptor
      };
    }
    const fileType = getFileType(fileDescriptor);
    const fileName = getFileName(fileType, fileDescriptor);
    const fileExtension = getFileNameAndExtension(fileName).extension;
    const isRemote = Boolean(fileDescriptor.isRemote);
    const fileID = generateFileID({
      ...fileDescriptor,
      type: fileType
    });
    if (this.checkIfFileAlreadyExists(fileID)) {
      const error2 = new RestrictionError(this.i18n("noDuplicates", {
        fileName
      }));
      _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](error2, fileDescriptor);
      throw error2;
    }
    const meta = fileDescriptor.meta || {};
    meta.name = fileName;
    meta.type = fileType;
    const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
    let newFile = {
      source: fileDescriptor.source || "",
      id: fileID,
      name: fileName,
      extension: fileExtension || "",
      meta: {
        ...this.getState().meta,
        ...meta
      },
      type: fileType,
      data: fileDescriptor.data,
      progress: {
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: size,
        uploadComplete: false,
        uploadStarted: null
      },
      size,
      isRemote,
      remote: fileDescriptor.remote || "",
      preview: fileDescriptor.preview
    };
    const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);
    if (onBeforeFileAddedResult === false) {
      const error2 = new RestrictionError("Cannot add the file because onBeforeFileAdded returned false.");
      this.emit("restriction-failed", fileDescriptor, error2);
      throw error2;
    } else if (typeof onBeforeFileAddedResult === "object" && onBeforeFileAddedResult !== null) {
      newFile = onBeforeFileAddedResult;
    }
    try {
      const filesArray = Object.keys(files).map((i4) => files[i4]);
      _classPrivateFieldLooseBase3(this, _restricter)[_restricter].validate(newFile, filesArray);
    } catch (err) {
      _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](err, newFile);
      throw err;
    }
    return newFile;
  }
  function _startIfAutoProceed2() {
    if (this.opts.autoProceed && !this.scheduledAutoProceed) {
      this.scheduledAutoProceed = setTimeout(() => {
        this.scheduledAutoProceed = null;
        this.upload().catch((err) => {
          if (!err.isRestriction) {
            this.log(err.stack || err.message || err);
          }
        });
      }, 4);
    }
  }
  function _addListeners2() {
    const errorHandler = (error2, file, response) => {
      let errorMsg = error2.message || "Unknown error";
      if (error2.details) {
        errorMsg += ` ${error2.details}`;
      }
      this.setState({
        error: errorMsg
      });
      if (file != null && file.id in this.getState().files) {
        this.setFileState(file.id, {
          error: errorMsg,
          response
        });
      }
    };
    this.on("error", errorHandler);
    this.on("upload-error", (file, error2, response) => {
      errorHandler(error2, file, response);
      if (typeof error2 === "object" && error2.message) {
        const newError = new Error(error2.message);
        newError.details = error2.message;
        if (error2.details) {
          newError.details += ` ${error2.details}`;
        }
        newError.message = this.i18n("failedToUpload", {
          file: file == null ? void 0 : file.name
        });
        _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](newError);
      } else {
        _classPrivateFieldLooseBase3(this, _informAndEmit)[_informAndEmit](error2);
      }
    });
    let uploadStalledWarningRecentlyEmitted;
    this.on("upload-stalled", (error2, files) => {
      const {
        message
      } = error2;
      const details = files.map((file) => file.meta.name).join(", ");
      if (!uploadStalledWarningRecentlyEmitted) {
        this.info({
          message,
          details
        }, "warning", this.opts.infoTimeout);
        uploadStalledWarningRecentlyEmitted = setTimeout(() => {
          uploadStalledWarningRecentlyEmitted = null;
        }, this.opts.infoTimeout);
      }
      this.log(`${message} ${details}`.trim(), "warning");
    });
    this.on("upload", () => {
      this.setState({
        error: null
      });
    });
    this.on("upload-started", (file) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      this.setFileState(file.id, {
        progress: {
          uploadStarted: Date.now(),
          uploadComplete: false,
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: file.size
        }
      });
    });
    this.on("upload-progress", this.calculateProgress);
    this.on("upload-success", (file, uploadResp) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      const currentProgress = this.getFile(file.id).progress;
      this.setFileState(file.id, {
        progress: {
          ...currentProgress,
          postprocess: _classPrivateFieldLooseBase3(this, _postProcessors)[_postProcessors].size > 0 ? {
            mode: "indeterminate"
          } : null,
          uploadComplete: true,
          percentage: 100,
          bytesUploaded: currentProgress.bytesTotal
        },
        response: uploadResp,
        uploadURL: uploadResp.uploadURL,
        isPaused: false
      });
      if (file.size == null) {
        this.setFileState(file.id, {
          size: uploadResp.bytesUploaded || currentProgress.bytesTotal
        });
      }
      this.calculateTotalProgress();
    });
    this.on("preprocess-progress", (file, progress) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      this.setFileState(file.id, {
        progress: {
          ...this.getFile(file.id).progress,
          preprocess: progress
        }
      });
    });
    this.on("preprocess-complete", (file) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      const files = {
        ...this.getState().files
      };
      files[file.id] = {
        ...files[file.id],
        progress: {
          ...files[file.id].progress
        }
      };
      delete files[file.id].progress.preprocess;
      this.setState({
        files
      });
    });
    this.on("postprocess-progress", (file, progress) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      this.setFileState(file.id, {
        progress: {
          ...this.getState().files[file.id].progress,
          postprocess: progress
        }
      });
    });
    this.on("postprocess-complete", (file) => {
      if (file == null || !this.getFile(file.id)) {
        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);
        return;
      }
      const files = {
        ...this.getState().files
      };
      files[file.id] = {
        ...files[file.id],
        progress: {
          ...files[file.id].progress
        }
      };
      delete files[file.id].progress.postprocess;
      this.setState({
        files
      });
    });
    this.on("restored", () => {
      this.calculateTotalProgress();
    });
    this.on("dashboard:file-edit-complete", (file) => {
      if (file) {
        _classPrivateFieldLooseBase3(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
      }
    });
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("online", _classPrivateFieldLooseBase3(this, _updateOnlineStatus)[_updateOnlineStatus]);
      window.addEventListener("offline", _classPrivateFieldLooseBase3(this, _updateOnlineStatus)[_updateOnlineStatus]);
      setTimeout(_classPrivateFieldLooseBase3(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3);
    }
  }
  function _createUpload2(fileIDs, opts) {
    if (opts === void 0) {
      opts = {};
    }
    const {
      forceAllowNewUpload = false
    } = opts;
    const {
      allowNewUpload,
      currentUploads
    } = this.getState();
    if (!allowNewUpload && !forceAllowNewUpload) {
      throw new Error("Cannot create a new upload: already uploading.");
    }
    const uploadID = nanoid();
    this.emit("upload", {
      id: uploadID,
      fileIDs
    });
    this.setState({
      allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,
      currentUploads: {
        ...currentUploads,
        [uploadID]: {
          fileIDs,
          step: 0,
          result: {}
        }
      }
    });
    return uploadID;
  }
  function _getUpload2(uploadID) {
    const {
      currentUploads
    } = this.getState();
    return currentUploads[uploadID];
  }
  function _removeUpload2(uploadID) {
    const currentUploads = {
      ...this.getState().currentUploads
    };
    delete currentUploads[uploadID];
    this.setState({
      currentUploads
    });
  }
  async function _runUpload2(uploadID) {
    let {
      currentUploads
    } = this.getState();
    let currentUpload = currentUploads[uploadID];
    const restoreStep = currentUpload.step || 0;
    const steps = [..._classPrivateFieldLooseBase3(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase3(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase3(this, _postProcessors)[_postProcessors]];
    try {
      for (let step = restoreStep; step < steps.length; step++) {
        if (!currentUpload) {
          break;
        }
        const fn4 = steps[step];
        const updatedUpload = {
          ...currentUpload,
          step
        };
        this.setState({
          currentUploads: {
            ...currentUploads,
            [uploadID]: updatedUpload
          }
        });
        await fn4(updatedUpload.fileIDs, uploadID);
        currentUploads = this.getState().currentUploads;
        currentUpload = currentUploads[uploadID];
      }
    } catch (err) {
      _classPrivateFieldLooseBase3(this, _removeUpload)[_removeUpload](uploadID);
      throw err;
    }
    if (currentUpload) {
      currentUpload.fileIDs.forEach((fileID) => {
        const file = this.getFile(fileID);
        if (file && file.progress.postprocess) {
          this.emit("postprocess-complete", file);
        }
      });
      const files = currentUpload.fileIDs.map((fileID) => this.getFile(fileID));
      const successful = files.filter((file) => !file.error);
      const failed = files.filter((file) => file.error);
      await this.addResultData(uploadID, {
        successful,
        failed,
        uploadID
      });
      currentUploads = this.getState().currentUploads;
      currentUpload = currentUploads[uploadID];
    }
    let result;
    if (currentUpload) {
      result = currentUpload.result;
      this.emit("complete", result);
      _classPrivateFieldLooseBase3(this, _removeUpload)[_removeUpload](uploadID);
    }
    if (result == null) {
      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
    }
    return result;
  }
  Uppy.VERSION = packageJson2.version;
  var Uppy_default = Uppy;

  // ../../node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var i;
  var t;
  var r;
  var o;
  var f;
  var e;
  var c = {};
  var s = [];
  var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h(n4, l4) {
    for (var u4 in l4) n4[u4] = l4[u4];
    return n4;
  }
  function v(n4) {
    var l4 = n4.parentNode;
    l4 && l4.removeChild(n4);
  }
  function y(l4, u4, i4) {
    var t5, r4, o4, f4 = {};
    for (o4 in u4) "key" == o4 ? t5 = u4[o4] : "ref" == o4 ? r4 = u4[o4] : f4[o4] = u4[o4];
    if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), "function" == typeof l4 && null != l4.defaultProps) for (o4 in l4.defaultProps) void 0 === f4[o4] && (f4[o4] = l4.defaultProps[o4]);
    return p(l4, f4, t5, r4, null);
  }
  function p(n4, i4, t5, r4, o4) {
    var f4 = { type: n4, props: i4, key: t5, ref: r4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o4 ? ++u : o4 };
    return null == o4 && null != l.vnode && l.vnode(f4), f4;
  }
  function d() {
    return { current: null };
  }
  function _(n4) {
    return n4.children;
  }
  function k(n4, l4, u4, i4, t5) {
    var r4;
    for (r4 in u4) "children" === r4 || "key" === r4 || r4 in l4 || g(n4, r4, null, u4[r4], i4);
    for (r4 in l4) t5 && "function" != typeof l4[r4] || "children" === r4 || "key" === r4 || "value" === r4 || "checked" === r4 || u4[r4] === l4[r4] || g(n4, r4, l4[r4], u4[r4], i4);
  }
  function b(n4, l4, u4) {
    "-" === l4[0] ? n4.setProperty(l4, null == u4 ? "" : u4) : n4[l4] = null == u4 ? "" : "number" != typeof u4 || a.test(l4) ? u4 : u4 + "px";
  }
  function g(n4, l4, u4, i4, t5) {
    var r4;
    n: if ("style" === l4) if ("string" == typeof u4) n4.style.cssText = u4;
    else {
      if ("string" == typeof i4 && (n4.style.cssText = i4 = ""), i4) for (l4 in i4) u4 && l4 in u4 || b(n4.style, l4, "");
      if (u4) for (l4 in u4) i4 && u4[l4] === i4[l4] || b(n4.style, l4, u4[l4]);
    }
    else if ("o" === l4[0] && "n" === l4[1]) r4 = l4 !== (l4 = l4.replace(/Capture$/, "")), l4 = l4.toLowerCase() in n4 ? l4.toLowerCase().slice(2) : l4.slice(2), n4.l || (n4.l = {}), n4.l[l4 + r4] = u4, u4 ? i4 || n4.addEventListener(l4, r4 ? w : m, r4) : n4.removeEventListener(l4, r4 ? w : m, r4);
    else if ("dangerouslySetInnerHTML" !== l4) {
      if (t5) l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && l4 in n4) try {
        n4[l4] = null == u4 ? "" : u4;
        break n;
      } catch (n5) {
      }
      "function" == typeof u4 || (null == u4 || false === u4 && -1 == l4.indexOf("-") ? n4.removeAttribute(l4) : n4.setAttribute(l4, u4));
    }
  }
  function m(n4) {
    t = true;
    try {
      return this.l[n4.type + false](l.event ? l.event(n4) : n4);
    } finally {
      t = false;
    }
  }
  function w(n4) {
    t = true;
    try {
      return this.l[n4.type + true](l.event ? l.event(n4) : n4);
    } finally {
      t = false;
    }
  }
  function x(n4, l4) {
    this.props = n4, this.context = l4;
  }
  function A(n4, l4) {
    if (null == l4) return n4.__ ? A(n4.__, n4.__.__k.indexOf(n4) + 1) : null;
    for (var u4; l4 < n4.__k.length; l4++) if (null != (u4 = n4.__k[l4]) && null != u4.__e) return u4.__e;
    return "function" == typeof n4.type ? A(n4) : null;
  }
  function P(n4) {
    var l4, u4;
    if (null != (n4 = n4.__) && null != n4.__c) {
      for (n4.__e = n4.__c.base = null, l4 = 0; l4 < n4.__k.length; l4++) if (null != (u4 = n4.__k[l4]) && null != u4.__e) {
        n4.__e = n4.__c.base = u4.__e;
        break;
      }
      return P(n4);
    }
  }
  function C(n4) {
    t ? setTimeout(n4) : f(n4);
  }
  function T(n4) {
    (!n4.__d && (n4.__d = true) && r.push(n4) && !$2.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($2);
  }
  function $2() {
    var n4, l4, u4, i4, t5, o4, f4, e4;
    for (r.sort(function(n5, l5) {
      return n5.__v.__b - l5.__v.__b;
    }); n4 = r.shift(); ) n4.__d && (l4 = r.length, i4 = void 0, t5 = void 0, f4 = (o4 = (u4 = n4).__v).__e, (e4 = u4.__P) && (i4 = [], (t5 = h({}, o4)).__v = o4.__v + 1, M(e4, o4, t5, u4.__n, void 0 !== e4.ownerSVGElement, null != o4.__h ? [f4] : null, i4, null == f4 ? A(o4) : f4, o4.__h), N(i4, o4), o4.__e != f4 && P(o4)), r.length > l4 && r.sort(function(n5, l5) {
      return n5.__v.__b - l5.__v.__b;
    }));
    $2.__r = 0;
  }
  function H(n4, l4, u4, i4, t5, r4, o4, f4, e4, a4) {
    var h4, v4, y4, d4, k4, b4, g4, m4 = i4 && i4.__k || s, w4 = m4.length;
    for (u4.__k = [], h4 = 0; h4 < l4.length; h4++) if (null != (d4 = u4.__k[h4] = null == (d4 = l4[h4]) || "boolean" == typeof d4 ? null : "string" == typeof d4 || "number" == typeof d4 || "bigint" == typeof d4 ? p(null, d4, null, null, d4) : Array.isArray(d4) ? p(_, { children: d4 }, null, null, null) : d4.__b > 0 ? p(d4.type, d4.props, d4.key, d4.ref ? d4.ref : null, d4.__v) : d4)) {
      if (d4.__ = u4, d4.__b = u4.__b + 1, null === (y4 = m4[h4]) || y4 && d4.key == y4.key && d4.type === y4.type) m4[h4] = void 0;
      else for (v4 = 0; v4 < w4; v4++) {
        if ((y4 = m4[v4]) && d4.key == y4.key && d4.type === y4.type) {
          m4[v4] = void 0;
          break;
        }
        y4 = null;
      }
      M(n4, d4, y4 = y4 || c, t5, r4, o4, f4, e4, a4), k4 = d4.__e, (v4 = d4.ref) && y4.ref != v4 && (g4 || (g4 = []), y4.ref && g4.push(y4.ref, null, d4), g4.push(v4, d4.__c || k4, d4)), null != k4 ? (null == b4 && (b4 = k4), "function" == typeof d4.type && d4.__k === y4.__k ? d4.__d = e4 = I(d4, e4, n4) : e4 = z(n4, d4, y4, m4, k4, e4), "function" == typeof u4.type && (u4.__d = e4)) : e4 && y4.__e == e4 && e4.parentNode != n4 && (e4 = A(y4));
    }
    for (u4.__e = b4, h4 = w4; h4--; ) null != m4[h4] && ("function" == typeof u4.type && null != m4[h4].__e && m4[h4].__e == u4.__d && (u4.__d = L(i4).nextSibling), q(m4[h4], m4[h4]));
    if (g4) for (h4 = 0; h4 < g4.length; h4++) S(g4[h4], g4[++h4], g4[++h4]);
  }
  function I(n4, l4, u4) {
    for (var i4, t5 = n4.__k, r4 = 0; t5 && r4 < t5.length; r4++) (i4 = t5[r4]) && (i4.__ = n4, l4 = "function" == typeof i4.type ? I(i4, l4, u4) : z(u4, i4, i4, t5, i4.__e, l4));
    return l4;
  }
  function j(n4, l4) {
    return l4 = l4 || [], null == n4 || "boolean" == typeof n4 || (Array.isArray(n4) ? n4.some(function(n5) {
      j(n5, l4);
    }) : l4.push(n4)), l4;
  }
  function z(n4, l4, u4, i4, t5, r4) {
    var o4, f4, e4;
    if (void 0 !== l4.__d) o4 = l4.__d, l4.__d = void 0;
    else if (null == u4 || t5 != r4 || null == t5.parentNode) n: if (null == r4 || r4.parentNode !== n4) n4.appendChild(t5), o4 = null;
    else {
      for (f4 = r4, e4 = 0; (f4 = f4.nextSibling) && e4 < i4.length; e4 += 1) if (f4 == t5) break n;
      n4.insertBefore(t5, r4), o4 = r4;
    }
    return void 0 !== o4 ? o4 : t5.nextSibling;
  }
  function L(n4) {
    var l4, u4, i4;
    if (null == n4.type || "string" == typeof n4.type) return n4.__e;
    if (n4.__k) {
      for (l4 = n4.__k.length - 1; l4 >= 0; l4--) if ((u4 = n4.__k[l4]) && (i4 = L(u4))) return i4;
    }
    return null;
  }
  function M(n4, u4, i4, t5, r4, o4, f4, e4, c4) {
    var s4, a4, v4, y4, p4, d4, k4, b4, g4, m4, w4, A4, P4, C4, T4, $5 = u4.type;
    if (void 0 !== u4.constructor) return null;
    null != i4.__h && (c4 = i4.__h, e4 = u4.__e = i4.__e, u4.__h = null, o4 = [e4]), (s4 = l.__b) && s4(u4);
    try {
      n: if ("function" == typeof $5) {
        if (b4 = u4.props, g4 = (s4 = $5.contextType) && t5[s4.__c], m4 = s4 ? g4 ? g4.props.value : s4.__ : t5, i4.__c ? k4 = (a4 = u4.__c = i4.__c).__ = a4.__E : ("prototype" in $5 && $5.prototype.render ? u4.__c = a4 = new $5(b4, m4) : (u4.__c = a4 = new x(b4, m4), a4.constructor = $5, a4.render = B), g4 && g4.sub(a4), a4.props = b4, a4.state || (a4.state = {}), a4.context = m4, a4.__n = t5, v4 = a4.__d = true, a4.__h = [], a4._sb = []), null == a4.__s && (a4.__s = a4.state), null != $5.getDerivedStateFromProps && (a4.__s == a4.state && (a4.__s = h({}, a4.__s)), h(a4.__s, $5.getDerivedStateFromProps(b4, a4.__s))), y4 = a4.props, p4 = a4.state, a4.__v = u4, v4) null == $5.getDerivedStateFromProps && null != a4.componentWillMount && a4.componentWillMount(), null != a4.componentDidMount && a4.__h.push(a4.componentDidMount);
        else {
          if (null == $5.getDerivedStateFromProps && b4 !== y4 && null != a4.componentWillReceiveProps && a4.componentWillReceiveProps(b4, m4), !a4.__e && null != a4.shouldComponentUpdate && false === a4.shouldComponentUpdate(b4, a4.__s, m4) || u4.__v === i4.__v) {
            for (u4.__v !== i4.__v && (a4.props = b4, a4.state = a4.__s, a4.__d = false), u4.__e = i4.__e, u4.__k = i4.__k, u4.__k.forEach(function(n5) {
              n5 && (n5.__ = u4);
            }), w4 = 0; w4 < a4._sb.length; w4++) a4.__h.push(a4._sb[w4]);
            a4._sb = [], a4.__h.length && f4.push(a4);
            break n;
          }
          null != a4.componentWillUpdate && a4.componentWillUpdate(b4, a4.__s, m4), null != a4.componentDidUpdate && a4.__h.push(function() {
            a4.componentDidUpdate(y4, p4, d4);
          });
        }
        if (a4.context = m4, a4.props = b4, a4.__P = n4, A4 = l.__r, P4 = 0, "prototype" in $5 && $5.prototype.render) {
          for (a4.state = a4.__s, a4.__d = false, A4 && A4(u4), s4 = a4.render(a4.props, a4.state, a4.context), C4 = 0; C4 < a4._sb.length; C4++) a4.__h.push(a4._sb[C4]);
          a4._sb = [];
        } else do {
          a4.__d = false, A4 && A4(u4), s4 = a4.render(a4.props, a4.state, a4.context), a4.state = a4.__s;
        } while (a4.__d && ++P4 < 25);
        a4.state = a4.__s, null != a4.getChildContext && (t5 = h(h({}, t5), a4.getChildContext())), v4 || null == a4.getSnapshotBeforeUpdate || (d4 = a4.getSnapshotBeforeUpdate(y4, p4)), T4 = null != s4 && s4.type === _ && null == s4.key ? s4.props.children : s4, H(n4, Array.isArray(T4) ? T4 : [T4], u4, i4, t5, r4, o4, f4, e4, c4), a4.base = u4.__e, u4.__h = null, a4.__h.length && f4.push(a4), k4 && (a4.__E = a4.__ = null), a4.__e = false;
      } else null == o4 && u4.__v === i4.__v ? (u4.__k = i4.__k, u4.__e = i4.__e) : u4.__e = O(i4.__e, u4, i4, t5, r4, o4, f4, c4);
      (s4 = l.diffed) && s4(u4);
    } catch (n5) {
      u4.__v = null, (c4 || null != o4) && (u4.__e = e4, u4.__h = !!c4, o4[o4.indexOf(e4)] = null), l.__e(n5, u4, i4);
    }
  }
  function N(n4, u4) {
    l.__c && l.__c(u4, n4), n4.some(function(u5) {
      try {
        n4 = u5.__h, u5.__h = [], n4.some(function(n5) {
          n5.call(u5);
        });
      } catch (n5) {
        l.__e(n5, u5.__v);
      }
    });
  }
  function O(l4, u4, i4, t5, r4, o4, f4, e4) {
    var s4, a4, h4, y4 = i4.props, p4 = u4.props, d4 = u4.type, _4 = 0;
    if ("svg" === d4 && (r4 = true), null != o4) {
      for (; _4 < o4.length; _4++) if ((s4 = o4[_4]) && "setAttribute" in s4 == !!d4 && (d4 ? s4.localName === d4 : 3 === s4.nodeType)) {
        l4 = s4, o4[_4] = null;
        break;
      }
    }
    if (null == l4) {
      if (null === d4) return document.createTextNode(p4);
      l4 = r4 ? document.createElementNS("http://www.w3.org/2000/svg", d4) : document.createElement(d4, p4.is && p4), o4 = null, e4 = false;
    }
    if (null === d4) y4 === p4 || e4 && l4.data === p4 || (l4.data = p4);
    else {
      if (o4 = o4 && n.call(l4.childNodes), a4 = (y4 = i4.props || c).dangerouslySetInnerHTML, h4 = p4.dangerouslySetInnerHTML, !e4) {
        if (null != o4) for (y4 = {}, _4 = 0; _4 < l4.attributes.length; _4++) y4[l4.attributes[_4].name] = l4.attributes[_4].value;
        (h4 || a4) && (h4 && (a4 && h4.__html == a4.__html || h4.__html === l4.innerHTML) || (l4.innerHTML = h4 && h4.__html || ""));
      }
      if (k(l4, p4, y4, r4, e4), h4) u4.__k = [];
      else if (_4 = u4.props.children, H(l4, Array.isArray(_4) ? _4 : [_4], u4, i4, t5, r4 && "foreignObject" !== d4, o4, f4, o4 ? o4[0] : i4.__k && A(i4, 0), e4), null != o4) for (_4 = o4.length; _4--; ) null != o4[_4] && v(o4[_4]);
      e4 || ("value" in p4 && void 0 !== (_4 = p4.value) && (_4 !== l4.value || "progress" === d4 && !_4 || "option" === d4 && _4 !== y4.value) && g(l4, "value", _4, y4.value, false), "checked" in p4 && void 0 !== (_4 = p4.checked) && _4 !== l4.checked && g(l4, "checked", _4, y4.checked, false));
    }
    return l4;
  }
  function S(n4, u4, i4) {
    try {
      "function" == typeof n4 ? n4(u4) : n4.current = u4;
    } catch (n5) {
      l.__e(n5, i4);
    }
  }
  function q(n4, u4, i4) {
    var t5, r4;
    if (l.unmount && l.unmount(n4), (t5 = n4.ref) && (t5.current && t5.current !== n4.__e || S(t5, null, u4)), null != (t5 = n4.__c)) {
      if (t5.componentWillUnmount) try {
        t5.componentWillUnmount();
      } catch (n5) {
        l.__e(n5, u4);
      }
      t5.base = t5.__P = null, n4.__c = void 0;
    }
    if (t5 = n4.__k) for (r4 = 0; r4 < t5.length; r4++) t5[r4] && q(t5[r4], u4, i4 || "function" != typeof n4.type);
    i4 || null == n4.__e || v(n4.__e), n4.__ = n4.__e = n4.__d = void 0;
  }
  function B(n4, l4, u4) {
    return this.constructor(n4, u4);
  }
  function D(u4, i4, t5) {
    var r4, o4, f4;
    l.__ && l.__(u4, i4), o4 = (r4 = "function" == typeof t5) ? null : t5 && t5.__k || i4.__k, f4 = [], M(i4, u4 = (!r4 && t5 || i4).__k = y(_, null, [u4]), o4 || c, c, void 0 !== i4.ownerSVGElement, !r4 && t5 ? [t5] : o4 ? null : i4.firstChild ? n.call(i4.childNodes) : null, f4, !r4 && t5 ? t5 : o4 ? o4.__e : i4.firstChild, r4), N(f4, u4);
  }
  function F(l4, u4, i4) {
    var t5, r4, o4, f4 = h({}, l4.props);
    for (o4 in u4) "key" == o4 ? t5 = u4[o4] : "ref" == o4 ? r4 = u4[o4] : f4[o4] = u4[o4];
    return arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), p(l4.type, f4, t5 || l4.key, r4 || l4.ref, null);
  }
  n = s.slice, l = { __e: function(n4, l4, u4, i4) {
    for (var t5, r4, o4; l4 = l4.__; ) if ((t5 = l4.__c) && !t5.__) try {
      if ((r4 = t5.constructor) && null != r4.getDerivedStateFromError && (t5.setState(r4.getDerivedStateFromError(n4)), o4 = t5.__d), null != t5.componentDidCatch && (t5.componentDidCatch(n4, i4 || {}), o4 = t5.__d), o4) return t5.__E = t5;
    } catch (l5) {
      n4 = l5;
    }
    throw n4;
  } }, u = 0, i = function(n4) {
    return null != n4 && void 0 === n4.constructor;
  }, t = false, x.prototype.setState = function(n4, l4) {
    var u4;
    u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n4 && (n4 = n4(h({}, u4), this.props)), n4 && h(u4, n4), null != n4 && this.__v && (l4 && this._sb.push(l4), T(this));
  }, x.prototype.forceUpdate = function(n4) {
    this.__v && (this.__e = true, n4 && this.__h.push(n4), T(this));
  }, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $2.__r = 0, e = 0;

  // ../../node_modules/@uppy/utils/lib/isDOMElement.js
  function isDOMElement(obj) {
    return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
  }

  // ../../node_modules/@uppy/utils/lib/findDOMElement.js
  function findDOMElement(element, context) {
    if (context === void 0) {
      context = document;
    }
    if (typeof element === "string") {
      return context.querySelector(element);
    }
    if (isDOMElement(element)) {
      return element;
    }
    return null;
  }

  // ../../node_modules/@uppy/utils/lib/getTextDirection.js
  function getTextDirection(element) {
    var _element;
    while (element && !element.dir) {
      element = element.parentNode;
    }
    return (_element = element) == null ? void 0 : _element.dir;
  }
  var getTextDirection_default = getTextDirection;

  // ../../node_modules/@uppy/core/lib/BasePlugin.js
  var BasePlugin = class {
    constructor(uppy, opts) {
      if (opts === void 0) {
        opts = {};
      }
      this.uppy = uppy;
      this.opts = opts;
    }
    getPluginState() {
      const {
        plugins
      } = this.uppy.getState();
      return plugins[this.id] || {};
    }
    setPluginState(update) {
      const {
        plugins
      } = this.uppy.getState();
      this.uppy.setState({
        plugins: {
          ...plugins,
          [this.id]: {
            ...plugins[this.id],
            ...update
          }
        }
      });
    }
    setOptions(newOpts) {
      this.opts = {
        ...this.opts,
        ...newOpts
      };
      this.setPluginState();
      this.i18nInit();
    }
    i18nInit() {
      const translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
      this.i18n = translator.translate.bind(translator);
      this.i18nArray = translator.translateArray.bind(translator);
      this.setPluginState();
    }
    /**
     * Extendable methods
     * ==================
     * These methods are here to serve as an overview of the extendable methods as well as
     * making them not conditional in use, such as `if (this.afterUpdate)`.
     */
    // eslint-disable-next-line class-methods-use-this
    addTarget() {
      throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
    }
    // eslint-disable-next-line class-methods-use-this
    install() {
    }
    // eslint-disable-next-line class-methods-use-this
    uninstall() {
    }
    /**
     * Called when plugin is mounted, whether in DOM or into another plugin.
     * Needed because sometimes plugins are mounted separately/after `install`,
     * so this.el and this.parent might not be available in `install`.
     * This is the case with @uppy/react plugins, for example.
     */
    render() {
      throw new Error("Extend the render method to add your plugin to a DOM element");
    }
    // eslint-disable-next-line class-methods-use-this
    update() {
    }
    // Called after every state update, after everything's mounted. Debounced.
    // eslint-disable-next-line class-methods-use-this
    afterUpdate() {
    }
  };

  // ../../node_modules/@uppy/core/lib/UIPlugin.js
  function _classPrivateFieldLooseBase4(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id4 = 0;
  function _classPrivateFieldLooseKey4(name) {
    return "__private_" + id4++ + "_" + name;
  }
  function debounce4(fn4) {
    let calling = null;
    let latestArgs = null;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      latestArgs = args;
      if (!calling) {
        calling = Promise.resolve().then(() => {
          calling = null;
          return fn4(...latestArgs);
        });
      }
      return calling;
    };
  }
  var _updateUI = /* @__PURE__ */ _classPrivateFieldLooseKey4("updateUI");
  var UIPlugin = class _UIPlugin extends BasePlugin {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, _updateUI, {
        writable: true,
        value: void 0
      });
    }
    getTargetPlugin(target) {
      let targetPlugin;
      if (typeof target === "object" && target instanceof _UIPlugin) {
        targetPlugin = target;
      } else if (typeof target === "function") {
        const Target = target;
        this.uppy.iteratePlugins((p4) => {
          if (p4 instanceof Target) {
            targetPlugin = p4;
          }
        });
      }
      return targetPlugin;
    }
    /**
     * Check if supplied `target` is a DOM element or an `object`.
     * If its an object  target is a plugin, and we search `plugins`
     * for a plugin with same name and return its target.
     */
    mount(target, plugin) {
      const callerPluginName = plugin.id;
      const targetElement = findDOMElement(target);
      if (targetElement) {
        this.isTargetDOMEl = true;
        const uppyRootElement = document.createElement("div");
        uppyRootElement.classList.add("uppy-Root");
        _classPrivateFieldLooseBase4(this, _updateUI)[_updateUI] = debounce4((state) => {
          if (!this.uppy.getPlugin(this.id)) return;
          D(this.render(state), uppyRootElement);
          this.afterUpdate();
        });
        this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);
        if (this.opts.replaceTargetContent) {
          targetElement.innerHTML = "";
        }
        D(this.render(this.uppy.getState()), uppyRootElement);
        this.el = uppyRootElement;
        targetElement.appendChild(uppyRootElement);
        uppyRootElement.dir = this.opts.direction || getTextDirection_default(uppyRootElement) || "ltr";
        this.onMount();
        return this.el;
      }
      const targetPlugin = this.getTargetPlugin(target);
      if (targetPlugin) {
        this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
        this.parent = targetPlugin;
        this.el = targetPlugin.addTarget(plugin);
        this.onMount();
        return this.el;
      }
      this.uppy.log(`Not installing ${callerPluginName}`);
      let message = `Invalid target option given to ${callerPluginName}.`;
      if (typeof target === "function") {
        message += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.";
      } else {
        message += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.";
      }
      throw new Error(message);
    }
    update(state) {
      if (this.el != null) {
        var _classPrivateFieldLoo, _classPrivateFieldLoo2;
        (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase4(this, _updateUI))[_updateUI]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
      }
    }
    unmount() {
      if (this.isTargetDOMEl) {
        var _this$el;
        (_this$el = this.el) == null ? void 0 : _this$el.remove();
      }
      this.onUnmount();
    }
    // eslint-disable-next-line class-methods-use-this
    onMount() {
    }
    // eslint-disable-next-line class-methods-use-this
    onUnmount() {
    }
  };
  var UIPlugin_default = UIPlugin;

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/toArray.js
  var toArray_default = Array.from;

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/isDragDropSupported.js
  function isDragDropSupported() {
    const div2 = document.body;
    if (!("draggable" in div2) || !("ondragstart" in div2 && "ondrop" in div2)) {
      return false;
    }
    if (!("FormData" in window)) {
      return false;
    }
    if (!("FileReader" in window)) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js
  function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
    let {
      onSuccess
    } = _ref;
    directoryReader.readEntries(
      (entries) => {
        const newEntries = [...oldEntries, ...entries];
        if (entries.length) {
          queueMicrotask(() => {
            getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
              onSuccess
            });
          });
        } else {
          onSuccess(newEntries);
        }
      },
      // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
      (error2) => {
        logDropError(error2);
        onSuccess(oldEntries);
      }
    );
  }

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js
  function getAsFileSystemHandleFromEntry(entry, logDropError) {
    if (entry == null) return entry;
    return {
      kind: (
        // eslint-disable-next-line no-nested-ternary
        entry.isFile ? "file" : entry.isDirectory ? "directory" : void 0
      ),
      name: entry.name,
      getFile() {
        return new Promise((resolve, reject) => entry.file(resolve, reject));
      },
      async *values() {
        const directoryReader = entry.createReader();
        const entries = await new Promise((resolve) => {
          getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
            onSuccess: (dirEntries) => resolve(dirEntries.map((file) => getAsFileSystemHandleFromEntry(file, logDropError)))
          });
        });
        yield* entries;
      },
      isSameEntry: void 0
    };
  }
  function createPromiseToAddFileOrParseDirectory(entry, relativePath, lastResortFile) {
    try {
      if (lastResortFile === void 0) {
        lastResortFile = void 0;
      }
      return async function* () {
        const getNextRelativePath = () => `${relativePath}/${entry.name}`;
        if (entry.kind === "file") {
          const file = await entry.getFile();
          if (file != null) {
            ;
            file.relativePath = relativePath ? getNextRelativePath() : null;
            yield file;
          } else if (lastResortFile != null) yield lastResortFile;
        } else if (entry.kind === "directory") {
          for await (const handle of entry.values()) {
            yield* createPromiseToAddFileOrParseDirectory(handle, relativePath ? getNextRelativePath() : entry.name);
          }
        } else if (lastResortFile != null) yield lastResortFile;
      }();
    } catch (e4) {
      return Promise.reject(e4);
    }
  }
  async function* getFilesFromDataTransfer(dataTransfer, logDropError) {
    const fileSystemHandles = await Promise.all(Array.from(dataTransfer.items, async (item) => {
      var _fileSystemHandle;
      let fileSystemHandle;
      const getAsEntry = () => typeof item.getAsEntry === "function" ? item.getAsEntry() : item.webkitGetAsEntry();
      (_fileSystemHandle = fileSystemHandle) != null ? _fileSystemHandle : fileSystemHandle = getAsFileSystemHandleFromEntry(getAsEntry(), logDropError);
      return {
        fileSystemHandle,
        lastResortFile: item.getAsFile()
        // can be used as a fallback in case other methods fail
      };
    }));
    for (const {
      lastResortFile,
      fileSystemHandle
    } of fileSystemHandles) {
      if (fileSystemHandle != null) {
        try {
          yield* createPromiseToAddFileOrParseDirectory(fileSystemHandle, "", lastResortFile);
        } catch (err) {
          if (lastResortFile != null) {
            yield lastResortFile;
          } else {
            logDropError(err);
          }
        }
      } else if (lastResortFile != null) yield lastResortFile;
    }
  }

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/getDroppedFiles/utils/fallbackApi.js
  function fallbackApi(dataTransfer) {
    const files = toArray_default(dataTransfer.files);
    return Promise.resolve(files);
  }

  // ../../node_modules/@uppy/drag-drop/node_modules/@uppy/utils/lib/getDroppedFiles/index.js
  async function getDroppedFiles(dataTransfer, options) {
    var _options$logDropError;
    const logDropError = (_options$logDropError = options == null ? void 0 : options.logDropError) != null ? _options$logDropError : Function.prototype;
    try {
      const accumulator = [];
      for await (const file of getFilesFromDataTransfer(dataTransfer, logDropError)) {
        accumulator.push(file);
      }
      return accumulator;
    } catch {
      return fallbackApi(dataTransfer);
    }
  }

  // ../../node_modules/@uppy/drag-drop/lib/locale.js
  var locale_default2 = {
    strings: {
      // Text to show on the droppable area.
      // `%{browse}` is replaced with a link that opens the system file selection dialog.
      dropHereOr: "Drop here or %{browse}",
      // Used as the label for the link that opens the system file selection dialog.
      browse: "browse"
    }
  };

  // ../../node_modules/@uppy/drag-drop/lib/DragDrop.js
  var packageJson3 = {
    "version": "3.1.0"
  };
  var defaultOptions2 = {
    inputName: "files[]",
    width: "100%",
    height: "100%"
  };
  var DragDrop = class _DragDrop extends UIPlugin_default {
    constructor(uppy, opts) {
      super(uppy, {
        ...defaultOptions2,
        ...opts
      });
      this.isDragDropSupported = isDragDropSupported();
      this.addFiles = (files) => {
        const descriptors = files.map((file) => ({
          source: this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        }));
        try {
          this.uppy.addFiles(descriptors);
        } catch (err) {
          this.uppy.log(err);
        }
      };
      this.onInputChange = (event) => {
        const files = toArray_default(event.target.files);
        if (files.length > 0) {
          this.uppy.log("[DragDrop] Files selected through input");
          this.addFiles(files);
        }
        event.target.value = null;
      };
      this.handleDragOver = (event) => {
        var _this$opts$onDragOver, _this$opts;
        event.preventDefault();
        event.stopPropagation();
        const {
          types
        } = event.dataTransfer;
        const hasFiles = types.some((type) => type === "Files");
        const {
          allowNewUpload
        } = this.uppy.getState();
        if (!hasFiles || !allowNewUpload) {
          event.dataTransfer.dropEffect = "none";
          clearTimeout(this.removeDragOverClassTimeout);
          return;
        }
        event.dataTransfer.dropEffect = "copy";
        clearTimeout(this.removeDragOverClassTimeout);
        this.setPluginState({
          isDraggingOver: true
        });
        (_this$opts$onDragOver = (_this$opts = this.opts).onDragOver) == null || _this$opts$onDragOver.call(_this$opts, event);
      };
      this.handleDragLeave = (event) => {
        var _this$opts$onDragLeav, _this$opts2;
        event.preventDefault();
        event.stopPropagation();
        clearTimeout(this.removeDragOverClassTimeout);
        this.removeDragOverClassTimeout = setTimeout(() => {
          this.setPluginState({
            isDraggingOver: false
          });
        }, 50);
        (_this$opts$onDragLeav = (_this$opts2 = this.opts).onDragLeave) == null || _this$opts$onDragLeav.call(_this$opts2, event);
      };
      this.handleDrop = async (event) => {
        var _this$opts$onDrop, _this$opts3;
        event.preventDefault();
        event.stopPropagation();
        clearTimeout(this.removeDragOverClassTimeout);
        this.setPluginState({
          isDraggingOver: false
        });
        const logDropError = (error2) => {
          this.uppy.log(error2, "error");
        };
        const files = await getDroppedFiles(event.dataTransfer, {
          logDropError
        });
        if (files.length > 0) {
          this.uppy.log("[DragDrop] Files dropped");
          this.addFiles(files);
        }
        (_this$opts$onDrop = (_this$opts3 = this.opts).onDrop) == null || _this$opts$onDrop.call(_this$opts3, event);
      };
      this.type = "acquirer";
      this.id = this.opts.id || "DragDrop";
      this.title = "Drag & Drop";
      this.defaultLocale = locale_default2;
      this.i18nInit();
    }
    renderHiddenFileInput() {
      const {
        restrictions
      } = this.uppy.opts;
      return y("input", {
        className: "uppy-DragDrop-input",
        type: "file",
        hidden: true,
        ref: (ref) => {
          this.fileInputRef = ref;
        },
        name: this.opts.inputName,
        multiple: restrictions.maxNumberOfFiles !== 1,
        accept: restrictions.allowedFileTypes,
        onChange: this.onInputChange
      });
    }
    static renderArrowSvg() {
      return y("svg", {
        "aria-hidden": "true",
        focusable: "false",
        className: "uppy-c-icon uppy-DragDrop-arrow",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16"
      }, y("path", {
        d: "M11 10V0H5v10H2l6 6 6-6h-3zm0 0",
        fillRule: "evenodd"
      }));
    }
    renderLabel() {
      return y("div", {
        className: "uppy-DragDrop-label"
      }, this.i18nArray("dropHereOr", {
        browse: y("span", {
          className: "uppy-DragDrop-browse"
        }, this.i18n("browse"))
      }));
    }
    renderNote() {
      return y("span", {
        className: "uppy-DragDrop-note"
      }, this.opts.note);
    }
    render() {
      const dragDropClass = `uppy-u-reset
      uppy-DragDrop-container
      ${this.isDragDropSupported ? "uppy-DragDrop--isDragDropSupported" : ""}
      ${this.getPluginState().isDraggingOver ? "uppy-DragDrop--isDraggingOver" : ""}
    `;
      const dragDropStyle = {
        width: this.opts.width,
        height: this.opts.height
      };
      return y("button", {
        type: "button",
        className: dragDropClass,
        style: dragDropStyle,
        onClick: () => this.fileInputRef.click(),
        onDragOver: this.handleDragOver,
        onDragLeave: this.handleDragLeave,
        onDrop: this.handleDrop
      }, this.renderHiddenFileInput(), y("div", {
        className: "uppy-DragDrop-inner"
      }, _DragDrop.renderArrowSvg(), this.renderLabel(), this.renderNote()));
    }
    install() {
      const {
        target
      } = this.opts;
      this.setPluginState({
        isDraggingOver: false
      });
      if (target) {
        this.mount(target, this);
      }
    }
    uninstall() {
      this.unmount();
    }
  };
  DragDrop.VERSION = packageJson3.version;

  // ../../node_modules/@uppy/informer/lib/FadeIn.js
  var TRANSITION_MS = 300;
  var FadeIn = class extends x {
    constructor() {
      super(...arguments);
      this.ref = d();
    }
    componentWillEnter(callback) {
      this.ref.current.style.opacity = "1";
      this.ref.current.style.transform = "none";
      setTimeout(callback, TRANSITION_MS);
    }
    componentWillLeave(callback) {
      this.ref.current.style.opacity = "0";
      this.ref.current.style.transform = "translateY(350%)";
      setTimeout(callback, TRANSITION_MS);
    }
    render() {
      const {
        children
      } = this.props;
      return y("div", {
        className: "uppy-Informer-animated",
        ref: this.ref
      }, children);
    }
  };

  // ../../node_modules/@uppy/informer/lib/TransitionGroup.js
  function assign(obj, props) {
    return Object.assign(obj, props);
  }
  function getKey(vnode, fallback) {
    var _vnode$key;
    return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;
  }
  function linkRef(component, name) {
    const cache2 = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
    return cache2[name] || (cache2[name] = (c4) => {
      component.refs[name] = c4;
    });
  }
  function getChildMapping(children) {
    const out = {};
    for (let i4 = 0; i4 < children.length; i4++) {
      if (children[i4] != null) {
        const key = getKey(children[i4], i4.toString(36));
        out[key] = children[i4];
      }
    }
    return out;
  }
  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};
    const getValueForKey = (key) => next.hasOwnProperty(key) ? next[key] : prev[key];
    const nextKeysPending = {};
    let pendingKeys = [];
    for (const prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    const childMapping = {};
    for (const nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (let i4 = 0; i4 < nextKeysPending[nextKey].length; i4++) {
          const pendingNextKey = nextKeysPending[nextKey][i4];
          childMapping[nextKeysPending[nextKey][i4]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (let i4 = 0; i4 < pendingKeys.length; i4++) {
      childMapping[pendingKeys[i4]] = getValueForKey(pendingKeys[i4]);
    }
    return childMapping;
  }
  var identity = (i4) => i4;
  var TransitionGroup = class extends x {
    constructor(props, context) {
      super(props, context);
      this.refs = {};
      this.state = {
        children: getChildMapping(j(j(this.props.children)) || [])
      };
      this.performAppear = this.performAppear.bind(this);
      this.performEnter = this.performEnter.bind(this);
      this.performLeave = this.performLeave.bind(this);
    }
    componentWillMount() {
      this.currentlyTransitioningKeys = {};
      this.keysToAbortLeave = [];
      this.keysToEnter = [];
      this.keysToLeave = [];
    }
    componentDidMount() {
      const initialChildMapping = this.state.children;
      for (const key in initialChildMapping) {
        if (initialChildMapping[key]) {
          this.performAppear(key);
        }
      }
    }
    componentWillReceiveProps(nextProps) {
      const nextChildMapping = getChildMapping(j(nextProps.children) || []);
      const prevChildMapping = this.state.children;
      this.setState((prevState) => ({
        children: mergeChildMappings(prevState.children, nextChildMapping)
      }));
      let key;
      for (key in nextChildMapping) {
        if (nextChildMapping.hasOwnProperty(key)) {
          const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
          if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
            this.keysToEnter.push(key);
            this.keysToAbortLeave.push(key);
          } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
            this.keysToEnter.push(key);
          }
        }
      }
      for (key in prevChildMapping) {
        if (prevChildMapping.hasOwnProperty(key)) {
          const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
          if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
            this.keysToLeave.push(key);
          }
        }
      }
    }
    componentDidUpdate() {
      const {
        keysToEnter
      } = this;
      this.keysToEnter = [];
      keysToEnter.forEach(this.performEnter);
      const {
        keysToLeave
      } = this;
      this.keysToLeave = [];
      keysToLeave.forEach(this.performLeave);
    }
    _finishAbort(key) {
      const idx = this.keysToAbortLeave.indexOf(key);
      if (idx !== -1) {
        this.keysToAbortLeave.splice(idx, 1);
      }
    }
    performAppear(key) {
      this.currentlyTransitioningKeys[key] = true;
      const component = this.refs[key];
      if (component != null && component.componentWillAppear) {
        component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
      } else {
        this._handleDoneAppearing(key);
      }
    }
    _handleDoneAppearing(key) {
      const component = this.refs[key];
      if (component != null && component.componentDidAppear) {
        component.componentDidAppear();
      }
      delete this.currentlyTransitioningKeys[key];
      this._finishAbort(key);
      const currentChildMapping = getChildMapping(j(this.props.children) || []);
      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        this.performLeave(key);
      }
    }
    performEnter(key) {
      this.currentlyTransitioningKeys[key] = true;
      const component = this.refs[key];
      if (component != null && component.componentWillEnter) {
        component.componentWillEnter(this._handleDoneEntering.bind(this, key));
      } else {
        this._handleDoneEntering(key);
      }
    }
    _handleDoneEntering(key) {
      const component = this.refs[key];
      if (component != null && component.componentDidEnter) {
        component.componentDidEnter();
      }
      delete this.currentlyTransitioningKeys[key];
      this._finishAbort(key);
      const currentChildMapping = getChildMapping(j(this.props.children) || []);
      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        this.performLeave(key);
      }
    }
    performLeave(key) {
      const idx = this.keysToAbortLeave.indexOf(key);
      if (idx !== -1) {
        return;
      }
      this.currentlyTransitioningKeys[key] = true;
      const component = this.refs[key];
      if (component != null && component.componentWillLeave) {
        component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
      } else {
        this._handleDoneLeaving(key);
      }
    }
    _handleDoneLeaving(key) {
      const idx = this.keysToAbortLeave.indexOf(key);
      if (idx !== -1) {
        return;
      }
      const component = this.refs[key];
      if (component != null && component.componentDidLeave) {
        component.componentDidLeave();
      }
      delete this.currentlyTransitioningKeys[key];
      const currentChildMapping = getChildMapping(j(this.props.children) || []);
      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
        this.performEnter(key);
      } else {
        const children = assign({}, this.state.children);
        delete children[key];
        this.setState({
          children
        });
      }
    }
    render(_ref, _ref2) {
      let {
        childFactory,
        transitionLeave,
        transitionName,
        transitionAppear,
        transitionEnter,
        transitionLeaveTimeout,
        transitionEnterTimeout,
        transitionAppearTimeout,
        component,
        ...props
      } = _ref;
      let {
        children
      } = _ref2;
      const childrenToRender = Object.entries(children).map((_ref3) => {
        let [key, child] = _ref3;
        if (!child) return void 0;
        const ref = linkRef(this, key);
        return F(childFactory(child), {
          ref,
          key
        });
      }).filter(Boolean);
      return y(component, props, childrenToRender);
    }
  };
  TransitionGroup.defaultProps = {
    component: "span",
    childFactory: identity
  };
  var TransitionGroup_default = TransitionGroup;

  // ../../node_modules/@uppy/informer/lib/Informer.js
  var packageJson4 = {
    "version": "3.1.0"
  };
  var Informer = class extends UIPlugin_default {
    constructor(uppy, opts) {
      super(uppy, opts);
      this.render = (state) => {
        return y("div", {
          className: "uppy uppy-Informer"
        }, y(TransitionGroup_default, null, state.info.map((info) => y(FadeIn, {
          key: info.message
        }, y("p", {
          role: "alert"
        }, info.message, " ", info.details && y("span", {
          "aria-label": info.details,
          "data-microtip-position": "top-left",
          "data-microtip-size": "medium",
          role: "tooltip",
          onClick: () => (
            // eslint-disable-next-line no-alert
            alert(`${info.message} 

 ${info.details}`)
          )
        }, "?"))))));
      };
      this.type = "progressindicator";
      this.id = this.opts.id || "Informer";
      this.title = "Informer";
    }
    install() {
      const {
        target
      } = this.opts;
      if (target) {
        this.mount(target, this);
      }
    }
  };
  Informer.VERSION = packageJson4.version;

  // ../../node_modules/@uppy/utils/lib/RateLimitedQueue.js
  function _classPrivateFieldLooseBase5(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id5 = 0;
  function _classPrivateFieldLooseKey5(name) {
    return "__private_" + id5++ + "_" + name;
  }
  function createCancelError(cause) {
    return new Error("Cancelled", {
      cause
    });
  }
  function abortOn(signal) {
    if (signal != null) {
      const abortPromise = () => this.abort(signal.reason);
      signal.addEventListener("abort", abortPromise, {
        once: true
      });
      const removeAbortListener = () => {
        signal.removeEventListener("abort", abortPromise);
      };
      this.then(removeAbortListener, removeAbortListener);
    }
    return this;
  }
  var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey5("activeRequests");
  var _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey5("queuedHandlers");
  var _paused = /* @__PURE__ */ _classPrivateFieldLooseKey5("paused");
  var _pauseTimer = /* @__PURE__ */ _classPrivateFieldLooseKey5("pauseTimer");
  var _downLimit = /* @__PURE__ */ _classPrivateFieldLooseKey5("downLimit");
  var _upperLimit = /* @__PURE__ */ _classPrivateFieldLooseKey5("upperLimit");
  var _rateLimitingTimer = /* @__PURE__ */ _classPrivateFieldLooseKey5("rateLimitingTimer");
  var _call = /* @__PURE__ */ _classPrivateFieldLooseKey5("call");
  var _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey5("queueNext");
  var _next = /* @__PURE__ */ _classPrivateFieldLooseKey5("next");
  var _queue = /* @__PURE__ */ _classPrivateFieldLooseKey5("queue");
  var _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey5("dequeue");
  var _resume = /* @__PURE__ */ _classPrivateFieldLooseKey5("resume");
  var _increaseLimit = /* @__PURE__ */ _classPrivateFieldLooseKey5("increaseLimit");
  var RateLimitedQueue = class {
    constructor(limit) {
      Object.defineProperty(this, _dequeue, {
        value: _dequeue2
      });
      Object.defineProperty(this, _queue, {
        value: _queue2
      });
      Object.defineProperty(this, _next, {
        value: _next2
      });
      Object.defineProperty(this, _queueNext, {
        value: _queueNext2
      });
      Object.defineProperty(this, _call, {
        value: _call2
      });
      Object.defineProperty(this, _activeRequests, {
        writable: true,
        value: 0
      });
      Object.defineProperty(this, _queuedHandlers, {
        writable: true,
        value: []
      });
      Object.defineProperty(this, _paused, {
        writable: true,
        value: false
      });
      Object.defineProperty(this, _pauseTimer, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _downLimit, {
        writable: true,
        value: 1
      });
      Object.defineProperty(this, _upperLimit, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _rateLimitingTimer, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _resume, {
        writable: true,
        value: () => this.resume()
      });
      Object.defineProperty(this, _increaseLimit, {
        writable: true,
        value: () => {
          if (_classPrivateFieldLooseBase5(this, _paused)[_paused]) {
            _classPrivateFieldLooseBase5(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase5(this, _increaseLimit)[_increaseLimit], 0);
            return;
          }
          _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit] = this.limit;
          this.limit = Math.ceil((_classPrivateFieldLooseBase5(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit]) / 2);
          for (let i4 = _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit]; i4 <= this.limit; i4++) {
            _classPrivateFieldLooseBase5(this, _queueNext)[_queueNext]();
          }
          if (_classPrivateFieldLooseBase5(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit] > 3) {
            _classPrivateFieldLooseBase5(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase5(this, _increaseLimit)[_increaseLimit], 2e3);
          } else {
            _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase5(this, _downLimit)[_downLimit] / 2);
          }
        }
      });
      if (typeof limit !== "number" || limit === 0) {
        this.limit = Infinity;
      } else {
        this.limit = limit;
      }
    }
    run(fn4, queueOptions) {
      if (!_classPrivateFieldLooseBase5(this, _paused)[_paused] && _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] < this.limit) {
        return _classPrivateFieldLooseBase5(this, _call)[_call](fn4);
      }
      return _classPrivateFieldLooseBase5(this, _queue)[_queue](fn4, queueOptions);
    }
    wrapPromiseFunction(fn4, queueOptions) {
      var _this = this;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let queuedRequest;
        const outerPromise = new Promise((resolve, reject) => {
          queuedRequest = _this.run(() => {
            let cancelError;
            let innerPromise;
            try {
              innerPromise = Promise.resolve(fn4(...args));
            } catch (err) {
              innerPromise = Promise.reject(err);
            }
            innerPromise.then((result) => {
              if (cancelError) {
                reject(cancelError);
              } else {
                queuedRequest.done();
                resolve(result);
              }
            }, (err) => {
              if (cancelError) {
                reject(cancelError);
              } else {
                queuedRequest.done();
                reject(err);
              }
            });
            return (cause) => {
              cancelError = createCancelError(cause);
            };
          }, queueOptions);
        });
        outerPromise.abort = (cause) => {
          queuedRequest.abort(cause);
        };
        outerPromise.abortOn = abortOn;
        return outerPromise;
      };
    }
    resume() {
      _classPrivateFieldLooseBase5(this, _paused)[_paused] = false;
      clearTimeout(_classPrivateFieldLooseBase5(this, _pauseTimer)[_pauseTimer]);
      for (let i4 = 0; i4 < this.limit; i4++) {
        _classPrivateFieldLooseBase5(this, _queueNext)[_queueNext]();
      }
    }
    /**
     * Freezes the queue for a while or indefinitely.
     *
     * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
     *                                    If omitted, the queue won't resume automatically.
     */
    pause(duration) {
      if (duration === void 0) {
        duration = null;
      }
      _classPrivateFieldLooseBase5(this, _paused)[_paused] = true;
      clearTimeout(_classPrivateFieldLooseBase5(this, _pauseTimer)[_pauseTimer]);
      if (duration != null) {
        _classPrivateFieldLooseBase5(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase5(this, _resume)[_resume], duration);
      }
    }
    /**
     * Pauses the queue for a duration, and lower the limit of concurrent requests
     * when the queue resumes. When the queue resumes, it tries to progressively
     * increase the limit in `this.#increaseLimit` until another call is made to
     * `this.rateLimit`.
     * Call this function when using the RateLimitedQueue for network requests and
     * the remote server responds with 429 HTTP code.
     *
     * @param {number} duration in milliseconds.
     */
    rateLimit(duration) {
      clearTimeout(_classPrivateFieldLooseBase5(this, _rateLimitingTimer)[_rateLimitingTimer]);
      this.pause(duration);
      if (this.limit > 1 && Number.isFinite(this.limit)) {
        _classPrivateFieldLooseBase5(this, _upperLimit)[_upperLimit] = this.limit - 1;
        this.limit = _classPrivateFieldLooseBase5(this, _downLimit)[_downLimit];
        _classPrivateFieldLooseBase5(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase5(this, _increaseLimit)[_increaseLimit], duration);
      }
    }
    get isPaused() {
      return _classPrivateFieldLooseBase5(this, _paused)[_paused];
    }
  };
  function _call2(fn4) {
    _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] += 1;
    let done = false;
    let cancelActive;
    try {
      cancelActive = fn4();
    } catch (err) {
      _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] -= 1;
      throw err;
    }
    return {
      abort: (cause) => {
        if (done) return;
        done = true;
        _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] -= 1;
        cancelActive(cause);
        _classPrivateFieldLooseBase5(this, _queueNext)[_queueNext]();
      },
      done: () => {
        if (done) return;
        done = true;
        _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] -= 1;
        _classPrivateFieldLooseBase5(this, _queueNext)[_queueNext]();
      }
    };
  }
  function _queueNext2() {
    queueMicrotask(() => _classPrivateFieldLooseBase5(this, _next)[_next]());
  }
  function _next2() {
    if (_classPrivateFieldLooseBase5(this, _paused)[_paused] || _classPrivateFieldLooseBase5(this, _activeRequests)[_activeRequests] >= this.limit) {
      return;
    }
    if (_classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].length === 0) {
      return;
    }
    const next = _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].shift();
    const handler = _classPrivateFieldLooseBase5(this, _call)[_call](next.fn);
    next.abort = handler.abort;
    next.done = handler.done;
  }
  function _queue2(fn4, options) {
    if (options === void 0) {
      options = {};
    }
    const handler = {
      fn: fn4,
      priority: options.priority || 0,
      abort: () => {
        _classPrivateFieldLooseBase5(this, _dequeue)[_dequeue](handler);
      },
      done: () => {
        throw new Error("Cannot mark a queued request as done: this indicates a bug");
      }
    };
    const index = _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
      return handler.priority > other.priority;
    });
    if (index === -1) {
      _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].push(handler);
    } else {
      _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
    }
    return handler;
  }
  function _dequeue2(handler) {
    const index = _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
    if (index !== -1) {
      _classPrivateFieldLooseBase5(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
    }
  }
  var internalRateLimitedQueue = Symbol("__queue");

  // ../../node_modules/@uppy/utils/lib/NetworkError.js
  var NetworkError = class extends Error {
    constructor(error2, xhr) {
      if (xhr === void 0) {
        xhr = null;
      }
      super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
      this.cause = error2;
      this.isNetworkError = true;
      this.request = xhr;
    }
  };
  var NetworkError_default = NetworkError;

  // ../../node_modules/@uppy/utils/lib/fetchWithNetworkError.js
  function fetchWithNetworkError() {
    return fetch(...arguments).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      } else {
        throw new NetworkError_default(err);
      }
    });
  }

  // ../../node_modules/@uppy/utils/lib/ErrorWithCause.js
  var ErrorWithCause = class extends Error {
    constructor(message, options) {
      if (options === void 0) {
        options = {};
      }
      super(message);
      this.cause = options.cause;
      if (this.cause && has(this.cause, "isNetworkError")) {
        this.isNetworkError = this.cause.isNetworkError;
      }
    }
  };
  var ErrorWithCause_default = ErrorWithCause;

  // ../../node_modules/@uppy/companion-client/lib/AuthError.js
  var AuthError = class extends Error {
    constructor() {
      super("Authorization required");
      this.name = "AuthError";
      this.isAuthError = true;
    }
  };
  var AuthError_default = AuthError;

  // ../../node_modules/@uppy/companion-client/lib/RequestClient.js
  var _Symbol$for3;
  function _classPrivateFieldLooseBase6(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id6 = 0;
  function _classPrivateFieldLooseKey6(name) {
    return "__private_" + id6++ + "_" + name;
  }
  var packageJson5 = {
    "version": "3.1.1"
  };
  function stripSlash(url) {
    return url.replace(/\/$/, "");
  }
  async function handleJSONResponse(res) {
    if (res.status === 401) {
      throw new AuthError_default();
    }
    const jsonPromise = res.json();
    if (res.ok) {
      return jsonPromise;
    }
    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
    try {
      const errData = await jsonPromise;
      errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
      errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
    } catch {
    }
    throw new Error(errMsg);
  }
  var allowedHeadersCache = /* @__PURE__ */ new Map();
  var _companionHeaders = /* @__PURE__ */ _classPrivateFieldLooseKey6("companionHeaders");
  var _getUrl = /* @__PURE__ */ _classPrivateFieldLooseKey6("getUrl");
  var _request = /* @__PURE__ */ _classPrivateFieldLooseKey6("request");
  _Symbol$for3 = Symbol.for("uppy test: getCompanionHeaders");
  var RequestClient = class _RequestClient {
    constructor(uppy, opts) {
      Object.defineProperty(this, _request, {
        value: _request2
      });
      Object.defineProperty(this, _getUrl, {
        value: _getUrl2
      });
      Object.defineProperty(this, _companionHeaders, {
        writable: true,
        value: void 0
      });
      this.uppy = uppy;
      this.opts = opts;
      this.onReceiveResponse = this.onReceiveResponse.bind(this);
      _classPrivateFieldLooseBase6(this, _companionHeaders)[_companionHeaders] = opts == null ? void 0 : opts.companionHeaders;
    }
    setCompanionHeaders(headers) {
      _classPrivateFieldLooseBase6(this, _companionHeaders)[_companionHeaders] = headers;
    }
    [_Symbol$for3]() {
      return _classPrivateFieldLooseBase6(this, _companionHeaders)[_companionHeaders];
    }
    get hostname() {
      const {
        companion
      } = this.uppy.getState();
      const host = this.opts.companionUrl;
      return stripSlash(companion && companion[host] ? companion[host] : host);
    }
    async headers() {
      const defaultHeaders = {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Uppy-Versions": `@uppy/companion-client=${_RequestClient.VERSION}`
      };
      return {
        ...defaultHeaders,
        ..._classPrivateFieldLooseBase6(this, _companionHeaders)[_companionHeaders]
      };
    }
    onReceiveResponse(_ref) {
      let {
        headers
      } = _ref;
      const state = this.uppy.getState();
      const companion = state.companion || {};
      const host = this.opts.companionUrl;
      if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
        this.uppy.setState({
          companion: {
            ...companion,
            [host]: headers.get("i-am")
          }
        });
      }
    }
    /*
      Preflight was added to avoid breaking change between older Companion-client versions and
      newer Companion versions and vice-versa. Usually the break will manifest via CORS errors because a
      version of companion-client could be sending certain headers to a version of Companion server that
      does not support those headers. In which case, the default preflight would lead to CORS.
      So to avoid those errors, we do preflight ourselves, to see what headers the Companion server
      we are communicating with allows. And based on that, companion-client knows what headers to
      send and what headers to not send.
       The preflight only happens once throughout the life-cycle of a certain
      Companion-client <-> Companion-server pair (allowedHeadersCache).
      Subsequent requests use the cached result of the preflight.
      However if there is an error retrieving the allowed headers, we will try again next time
    */
    async preflight(path) {
      const allowedHeadersCached = allowedHeadersCache.get(this.hostname);
      if (allowedHeadersCached != null) return allowedHeadersCached;
      const fallbackAllowedHeaders = ["accept", "content-type", "uppy-auth-token"];
      const promise = (async () => {
        try {
          const response = await fetch(_classPrivateFieldLooseBase6(this, _getUrl)[_getUrl](path), {
            method: "OPTIONS"
          });
          const header = response.headers.get("access-control-allow-headers");
          if (header == null || header === "*") {
            allowedHeadersCache.set(this.hostname, fallbackAllowedHeaders);
            return fallbackAllowedHeaders;
          }
          this.uppy.log(`[CompanionClient] adding allowed preflight headers to companion cache: ${this.hostname} ${header}`);
          const allowedHeaders = header.split(",").map((headerName) => headerName.trim().toLowerCase());
          allowedHeadersCache.set(this.hostname, allowedHeaders);
          return allowedHeaders;
        } catch (err) {
          this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, "warning");
          allowedHeadersCache.delete(this.hostname);
          return fallbackAllowedHeaders;
        }
      })();
      allowedHeadersCache.set(this.hostname, promise);
      return promise;
    }
    async preflightAndHeaders(path) {
      const [allowedHeaders, headers] = await Promise.all([this.preflight(path), this.headers()]);
      return Object.fromEntries(Object.entries(headers).filter((_ref2) => {
        let [header] = _ref2;
        if (!allowedHeaders.includes(header.toLowerCase())) {
          this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
          return false;
        }
        return true;
      }));
    }
    async get(path, options) {
      if (options === void 0) {
        options = void 0;
      }
      if (typeof options === "boolean") options = {
        skipPostResponse: options
      };
      return _classPrivateFieldLooseBase6(this, _request)[_request]({
        ...options,
        path
      });
    }
    async post(path, data, options) {
      if (options === void 0) {
        options = void 0;
      }
      if (typeof options === "boolean") options = {
        skipPostResponse: options
      };
      return _classPrivateFieldLooseBase6(this, _request)[_request]({
        ...options,
        path,
        method: "POST",
        data
      });
    }
    async delete(path, data, options) {
      if (data === void 0) {
        data = void 0;
      }
      if (typeof options === "boolean") options = {
        skipPostResponse: options
      };
      return _classPrivateFieldLooseBase6(this, _request)[_request]({
        ...options,
        path,
        method: "DELETE",
        data
      });
    }
  };
  function _getUrl2(url) {
    if (/^(https?:|)\/\//.test(url)) {
      return url;
    }
    return `${this.hostname}/${url}`;
  }
  async function _request2(_ref3) {
    let {
      path,
      method = "GET",
      data,
      skipPostResponse,
      signal
    } = _ref3;
    try {
      const headers = await this.preflightAndHeaders(path);
      const response = await fetchWithNetworkError(_classPrivateFieldLooseBase6(this, _getUrl)[_getUrl](path), {
        method,
        signal,
        headers,
        credentials: this.opts.companionCookiesRule || "same-origin",
        body: data ? JSON.stringify(data) : null
      });
      if (!skipPostResponse) this.onReceiveResponse(response);
      return handleJSONResponse(response);
    } catch (err) {
      if (err != null && err.isAuthError) throw err;
      throw new ErrorWithCause_default(`Could not ${method} ${_classPrivateFieldLooseBase6(this, _getUrl)[_getUrl](path)}`, {
        cause: err
      });
    }
  }
  RequestClient.VERSION = packageJson5.version;

  // ../../node_modules/@uppy/companion-client/lib/tokenStorage.js
  var tokenStorage_exports = {};
  __export(tokenStorage_exports, {
    getItem: () => getItem,
    removeItem: () => removeItem,
    setItem: () => setItem
  });
  function setItem(key, value) {
    return new Promise((resolve) => {
      localStorage.setItem(key, value);
      resolve();
    });
  }
  function getItem(key) {
    return Promise.resolve(localStorage.getItem(key));
  }
  function removeItem(key) {
    return new Promise((resolve) => {
      localStorage.removeItem(key);
      resolve();
    });
  }

  // ../../node_modules/@uppy/companion-client/lib/Provider.js
  var getName = (id14) => {
    return id14.split("-").map((s4) => s4.charAt(0).toUpperCase() + s4.slice(1)).join(" ");
  };
  var Provider = class extends RequestClient {
    constructor(uppy, opts) {
      super(uppy, opts);
      this.provider = opts.provider;
      this.id = this.provider;
      this.name = this.opts.name || getName(this.id);
      this.pluginId = this.opts.pluginId;
      this.tokenKey = `companion-${this.pluginId}-auth-token`;
      this.companionKeysParams = this.opts.companionKeysParams;
      this.preAuthToken = null;
    }
    async headers() {
      const [headers, token] = await Promise.all([super.headers(), this.getAuthToken()]);
      const authHeaders = {};
      if (token) {
        authHeaders["uppy-auth-token"] = token;
      }
      if (this.companionKeysParams) {
        authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
          params: this.companionKeysParams
        }));
      }
      return {
        ...headers,
        ...authHeaders
      };
    }
    onReceiveResponse(response) {
      super.onReceiveResponse(response);
      const plugin = this.uppy.getPlugin(this.pluginId);
      const oldAuthenticated = plugin.getPluginState().authenticated;
      const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
      plugin.setPluginState({
        authenticated
      });
      return response;
    }
    setAuthToken(token) {
      return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
    }
    getAuthToken() {
      return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
    }
    /**
     * Ensure we have a preauth token if necessary. Attempts to fetch one if we don't,
     * or rejects if loading one fails.
     */
    async ensurePreAuth() {
      if (this.companionKeysParams && !this.preAuthToken) {
        await this.fetchPreAuthToken();
        if (!this.preAuthToken) {
          throw new Error("Could not load authentication data required for third-party login. Please try again later.");
        }
      }
    }
    authUrl(queries) {
      if (queries === void 0) {
        queries = {};
      }
      const params = new URLSearchParams(queries);
      if (this.preAuthToken) {
        params.set("uppyPreAuthToken", this.preAuthToken);
      }
      return `${this.hostname}/${this.id}/connect?${params}`;
    }
    fileUrl(id14) {
      return `${this.hostname}/${this.id}/get/${id14}`;
    }
    async fetchPreAuthToken() {
      if (!this.companionKeysParams) {
        return;
      }
      try {
        const res = await this.post(`${this.id}/preauth/`, {
          params: this.companionKeysParams
        });
        this.preAuthToken = res.token;
      } catch (err) {
        this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, "warning");
      }
    }
    list(directory) {
      return this.get(`${this.id}/list/${directory || ""}`);
    }
    logout() {
      return this.get(`${this.id}/logout`).then((response) => Promise.all([response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)])).then((_ref) => {
        let [response] = _ref;
        return response;
      });
    }
    static initPlugin(plugin, opts, defaultOpts) {
      plugin.type = "acquirer";
      plugin.files = [];
      if (defaultOpts) {
        plugin.opts = {
          ...defaultOpts,
          ...opts
        };
      }
      if (opts.serverUrl || opts.serverPattern) {
        throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
      }
      if (opts.companionAllowedHosts) {
        const pattern = opts.companionAllowedHosts;
        if (typeof pattern !== "string" && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
          throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
        }
        plugin.opts.companionAllowedHosts = pattern;
      } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
        plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`;
      } else {
        plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
      }
      plugin.storage = plugin.opts.storage || tokenStorage_exports;
    }
  };

  // ../../node_modules/@uppy/companion-client/lib/Socket.js
  var import_namespace_emitter2 = __toESM(require_namespace_emitter(), 1);
  var _Symbol$for4;
  var _Symbol$for22;
  function _classPrivateFieldLooseBase7(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id7 = 0;
  function _classPrivateFieldLooseKey7(name) {
    return "__private_" + id7++ + "_" + name;
  }
  var _queued = /* @__PURE__ */ _classPrivateFieldLooseKey7("queued");
  var _emitter2 = /* @__PURE__ */ _classPrivateFieldLooseKey7("emitter");
  var _isOpen = /* @__PURE__ */ _classPrivateFieldLooseKey7("isOpen");
  var _socket = /* @__PURE__ */ _classPrivateFieldLooseKey7("socket");
  var _handleMessage = /* @__PURE__ */ _classPrivateFieldLooseKey7("handleMessage");
  _Symbol$for4 = Symbol.for("uppy test: getSocket");
  _Symbol$for22 = Symbol.for("uppy test: getQueued");
  var UppySocket = class {
    constructor(opts) {
      Object.defineProperty(this, _queued, {
        writable: true,
        value: []
      });
      Object.defineProperty(this, _emitter2, {
        writable: true,
        value: (0, import_namespace_emitter2.default)()
      });
      Object.defineProperty(this, _isOpen, {
        writable: true,
        value: false
      });
      Object.defineProperty(this, _socket, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _handleMessage, {
        writable: true,
        value: (e4) => {
          try {
            const message = JSON.parse(e4.data);
            this.emit(message.action, message.payload);
          } catch (err) {
            console.log(err);
          }
        }
      });
      this.opts = opts;
      if (!opts || opts.autoOpen !== false) {
        this.open();
      }
    }
    get isOpen() {
      return _classPrivateFieldLooseBase7(this, _isOpen)[_isOpen];
    }
    [_Symbol$for4]() {
      return _classPrivateFieldLooseBase7(this, _socket)[_socket];
    }
    [_Symbol$for22]() {
      return _classPrivateFieldLooseBase7(this, _queued)[_queued];
    }
    open() {
      _classPrivateFieldLooseBase7(this, _socket)[_socket] = new WebSocket(this.opts.target);
      _classPrivateFieldLooseBase7(this, _socket)[_socket].onopen = () => {
        _classPrivateFieldLooseBase7(this, _isOpen)[_isOpen] = true;
        while (_classPrivateFieldLooseBase7(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase7(this, _isOpen)[_isOpen]) {
          const first = _classPrivateFieldLooseBase7(this, _queued)[_queued].shift();
          this.send(first.action, first.payload);
        }
      };
      _classPrivateFieldLooseBase7(this, _socket)[_socket].onclose = () => {
        _classPrivateFieldLooseBase7(this, _isOpen)[_isOpen] = false;
      };
      _classPrivateFieldLooseBase7(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase7(this, _handleMessage)[_handleMessage];
    }
    close() {
      var _classPrivateFieldLoo;
      (_classPrivateFieldLoo = _classPrivateFieldLooseBase7(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
    }
    send(action, payload) {
      if (!_classPrivateFieldLooseBase7(this, _isOpen)[_isOpen]) {
        _classPrivateFieldLooseBase7(this, _queued)[_queued].push({
          action,
          payload
        });
        return;
      }
      _classPrivateFieldLooseBase7(this, _socket)[_socket].send(JSON.stringify({
        action,
        payload
      }));
    }
    on(action, handler) {
      _classPrivateFieldLooseBase7(this, _emitter2)[_emitter2].on(action, handler);
    }
    emit(action, payload) {
      _classPrivateFieldLooseBase7(this, _emitter2)[_emitter2].emit(action, payload);
    }
    once(action, handler) {
      _classPrivateFieldLooseBase7(this, _emitter2)[_emitter2].once(action, handler);
    }
  };

  // ../../node_modules/@uppy/utils/lib/emitSocketProgress.js
  var import_lodash2 = __toESM(require_lodash(), 1);
  function emitSocketProgress(uploader, progressData, file) {
    const {
      progress,
      bytesUploaded,
      bytesTotal
    } = progressData;
    if (progress) {
      uploader.uppy.log(`Upload progress: ${progress}`);
      uploader.uppy.emit("upload-progress", file, {
        uploader,
        bytesUploaded,
        bytesTotal
      });
    }
  }
  var emitSocketProgress_default = (0, import_lodash2.default)(emitSocketProgress, 300, {
    leading: true,
    trailing: true
  });

  // ../../node_modules/@uppy/utils/lib/getSocketHost.js
  function getSocketHost(url) {
    const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
    const host = regex.exec(url)[1];
    const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
    return `${socketProtocol}://${host}`;
  }

  // ../../node_modules/@uppy/utils/lib/EventTracker.js
  function _classPrivateFieldLooseBase8(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id8 = 0;
  function _classPrivateFieldLooseKey8(name) {
    return "__private_" + id8++ + "_" + name;
  }
  var _emitter3 = /* @__PURE__ */ _classPrivateFieldLooseKey8("emitter");
  var _events = /* @__PURE__ */ _classPrivateFieldLooseKey8("events");
  var EventTracker = class {
    constructor(emitter) {
      Object.defineProperty(this, _emitter3, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _events, {
        writable: true,
        value: []
      });
      _classPrivateFieldLooseBase8(this, _emitter3)[_emitter3] = emitter;
    }
    on(event, fn4) {
      _classPrivateFieldLooseBase8(this, _events)[_events].push([event, fn4]);
      return _classPrivateFieldLooseBase8(this, _emitter3)[_emitter3].on(event, fn4);
    }
    remove() {
      for (const [event, fn4] of _classPrivateFieldLooseBase8(this, _events)[_events].splice(0)) {
        _classPrivateFieldLooseBase8(this, _emitter3)[_emitter3].off(event, fn4);
      }
    }
  };

  // ../../node_modules/@uppy/utils/lib/ProgressTimeout.js
  function _classPrivateFieldLooseBase9(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id9 = 0;
  function _classPrivateFieldLooseKey9(name) {
    return "__private_" + id9++ + "_" + name;
  }
  var _aliveTimer = /* @__PURE__ */ _classPrivateFieldLooseKey9("aliveTimer");
  var _isDone = /* @__PURE__ */ _classPrivateFieldLooseKey9("isDone");
  var _onTimedOut = /* @__PURE__ */ _classPrivateFieldLooseKey9("onTimedOut");
  var _timeout = /* @__PURE__ */ _classPrivateFieldLooseKey9("timeout");
  var ProgressTimeout = class {
    constructor(timeout, timeoutHandler) {
      Object.defineProperty(this, _aliveTimer, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _isDone, {
        writable: true,
        value: false
      });
      Object.defineProperty(this, _onTimedOut, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _timeout, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldLooseBase9(this, _timeout)[_timeout] = timeout;
      _classPrivateFieldLooseBase9(this, _onTimedOut)[_onTimedOut] = timeoutHandler;
    }
    progress() {
      if (_classPrivateFieldLooseBase9(this, _isDone)[_isDone]) return;
      if (_classPrivateFieldLooseBase9(this, _timeout)[_timeout] > 0) {
        clearTimeout(_classPrivateFieldLooseBase9(this, _aliveTimer)[_aliveTimer]);
        _classPrivateFieldLooseBase9(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase9(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase9(this, _timeout)[_timeout]);
      }
    }
    done() {
      if (!_classPrivateFieldLooseBase9(this, _isDone)[_isDone]) {
        clearTimeout(_classPrivateFieldLooseBase9(this, _aliveTimer)[_aliveTimer]);
        _classPrivateFieldLooseBase9(this, _aliveTimer)[_aliveTimer] = null;
        _classPrivateFieldLooseBase9(this, _isDone)[_isDone] = true;
      }
    }
  };
  var ProgressTimeout_default = ProgressTimeout;

  // ../../node_modules/@uppy/utils/lib/isNetworkError.js
  function isNetworkError(xhr) {
    if (!xhr) {
      return false;
    }
    return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
  }
  var isNetworkError_default = isNetworkError;

  // ../../node_modules/@uppy/aws-s3/lib/MiniXHRUpload.js
  function _classPrivateFieldLooseBase10(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id10 = 0;
  function _classPrivateFieldLooseKey10(name) {
    return "__private_" + id10++ + "_" + name;
  }
  function buildResponseError(xhr, error2) {
    if (isNetworkError_default(xhr)) return new NetworkError_default(error2, xhr);
    const err = new ErrorWithCause_default("Upload error", {
      cause: error2
    });
    err.request = xhr;
    return err;
  }
  function setTypeInBlob(file) {
    const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
    return dataWithUpdatedType;
  }
  function addMetadata(formData, meta, opts) {
    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta);
    allowedMetaFields.forEach((item) => {
      formData.append(item, meta[item]);
    });
  }
  function createFormDataUpload(file, opts) {
    const formPost = new FormData();
    addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  var createBareUpload = (file) => file.data;
  var _queueRequestSocketToken = /* @__PURE__ */ _classPrivateFieldLooseKey10("queueRequestSocketToken");
  var _getOptions = /* @__PURE__ */ _classPrivateFieldLooseKey10("getOptions");
  var _addEventHandlerForFile = /* @__PURE__ */ _classPrivateFieldLooseKey10("addEventHandlerForFile");
  var _addEventHandlerIfFileStillExists = /* @__PURE__ */ _classPrivateFieldLooseKey10("addEventHandlerIfFileStillExists");
  var _uploadLocalFile = /* @__PURE__ */ _classPrivateFieldLooseKey10("uploadLocalFile");
  var _requestSocketToken = /* @__PURE__ */ _classPrivateFieldLooseKey10("requestSocketToken");
  var _uploadRemoteFile = /* @__PURE__ */ _classPrivateFieldLooseKey10("uploadRemoteFile");
  var MiniXHRUpload = class {
    constructor(_uppy, _opts) {
      Object.defineProperty(this, _uploadRemoteFile, {
        value: _uploadRemoteFile2
      });
      Object.defineProperty(this, _uploadLocalFile, {
        value: _uploadLocalFile2
      });
      Object.defineProperty(this, _addEventHandlerIfFileStillExists, {
        value: _addEventHandlerIfFileStillExists2
      });
      Object.defineProperty(this, _addEventHandlerForFile, {
        value: _addEventHandlerForFile2
      });
      Object.defineProperty(this, _getOptions, {
        value: _getOptions2
      });
      Object.defineProperty(this, _queueRequestSocketToken, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _requestSocketToken, {
        writable: true,
        value: async (file) => {
          const opts = _classPrivateFieldLooseBase10(this, _getOptions)[_getOptions](file);
          const Client = file.remote.providerOptions.provider ? Provider : RequestClient;
          const client = new Client(this.uppy, file.remote.providerOptions);
          const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(file.meta);
          if (file.tus) {
            Object.assign(opts, file.tus);
          }
          const res = await client.post(file.remote.url, {
            ...file.remote.body,
            protocol: "multipart",
            endpoint: opts.endpoint,
            size: file.data.size,
            fieldname: opts.fieldName,
            metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),
            httpMethod: opts.method,
            useFormData: opts.formData,
            headers: opts.headers
          });
          return res.token;
        }
      });
      this.uppy = _uppy;
      this.opts = {
        validateStatus(status) {
          return status >= 200 && status < 300;
        },
        ..._opts
      };
      this.requests = _opts[internalRateLimitedQueue];
      this.uploaderEvents = /* @__PURE__ */ Object.create(null);
      this.i18n = _opts.i18n;
      _classPrivateFieldLooseBase10(this, _queueRequestSocketToken)[_queueRequestSocketToken] = this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase10(this, _requestSocketToken)[_requestSocketToken], {
        priority: -1
      });
    }
    uploadFile(id14, current, total) {
      const file = this.uppy.getFile(id14);
      if (file.error) {
        throw new Error(file.error);
      } else if (file.isRemote) {
        return _classPrivateFieldLooseBase10(this, _uploadRemoteFile)[_uploadRemoteFile](file, current, total);
      }
      return _classPrivateFieldLooseBase10(this, _uploadLocalFile)[_uploadLocalFile](file, current, total);
    }
    connectToServerSocket(file) {
      return new Promise((resolve, reject) => {
        const opts = _classPrivateFieldLooseBase10(this, _getOptions)[_getOptions](file);
        const token = file.serverToken;
        const host = getSocketHost(file.remote.companionUrl);
        let socket;
        const createSocket = () => {
          if (socket != null) return;
          socket = new UppySocket({
            target: `${host}/api/${token}`
          });
          socket.on("progress", (progressData) => emitSocketProgress_default(this, progressData, file));
          socket.on("success", (data) => {
            const body = opts.getResponseData(data.response.responseText, data.response);
            const uploadURL = body[opts.responseUrlFieldName];
            const uploadResp = {
              status: data.response.status,
              body,
              uploadURL,
              bytesUploaded: data.bytesUploaded
            };
            this.uppy.emit("upload-success", file, uploadResp);
            queuedRequest.done();
            socket.close();
            if (this.uploaderEvents[file.id]) {
              this.uploaderEvents[file.id].remove();
              this.uploaderEvents[file.id] = null;
            }
            return resolve();
          });
          socket.on("error", (errData) => {
            const resp = errData.response;
            const error2 = resp ? opts.getResponseError(resp.responseText, resp) : new ErrorWithCause_default(errData.error.message, {
              cause: errData.error
            });
            this.uppy.emit("upload-error", file, error2);
            queuedRequest.done();
            if (this.uploaderEvents[file.id]) {
              this.uploaderEvents[file.id].remove();
              this.uploaderEvents[file.id] = null;
            }
            reject(error2);
          });
        };
        this.uploaderEvents[file.id] = new EventTracker(this.uppy);
        let queuedRequest = this.requests.run(() => {
          if (file.isPaused) {
            var _socket2;
            (_socket2 = socket) == null ? void 0 : _socket2.send("pause", {});
          } else {
            createSocket();
          }
          return () => socket.close();
        });
        _classPrivateFieldLooseBase10(this, _addEventHandlerForFile)[_addEventHandlerForFile]("file-removed", file.id, () => {
          var _socket2;
          (_socket2 = socket) == null ? void 0 : _socket2.send("cancel", {});
          queuedRequest.abort();
          resolve(`upload ${file.id} was removed`);
        });
        _classPrivateFieldLooseBase10(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]("cancel-all", file.id, function(_temp) {
          let {
            reason
          } = _temp === void 0 ? {} : _temp;
          if (reason === "user") {
            var _socket3;
            (_socket3 = socket) == null ? void 0 : _socket3.send("cancel", {});
            queuedRequest.abort();
          }
          resolve(`upload ${file.id} was canceled`);
        });
        const onRetryRequest = () => {
          if (socket == null) {
            queuedRequest.abort();
          } else {
            socket.send("pause", {});
            queuedRequest.done();
          }
          queuedRequest = this.requests.run(() => {
            if (!file.isPaused) {
              if (socket == null) {
                createSocket();
              } else {
                socket.send("resume", {});
              }
            }
            return () => socket.close();
          });
        };
        _classPrivateFieldLooseBase10(this, _addEventHandlerForFile)[_addEventHandlerForFile]("upload-retry", file.id, onRetryRequest);
        _classPrivateFieldLooseBase10(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]("retry-all", file.id, onRetryRequest);
      }).catch((err) => {
        this.uppy.emit("upload-error", file, err);
        return Promise.reject(err);
      });
    }
  };
  function _getOptions2(file) {
    var _file$xhrUpload;
    const {
      uppy
    } = this;
    const overrides = uppy.getState().xhrUpload;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {
        ...this.opts.headers,
        ...overrides == null ? void 0 : overrides.headers,
        ...(_file$xhrUpload = file.xhrUpload) == null ? void 0 : _file$xhrUpload.headers
      }
    };
    return opts;
  }
  function _addEventHandlerForFile2(eventName, fileID, eventHandler) {
    this.uploaderEvents[fileID].on(eventName, (fileOrID) => {
      var _fileOrID$id;
      const id14 = (_fileOrID$id = fileOrID == null ? void 0 : fileOrID.id) != null ? _fileOrID$id : fileOrID;
      if (fileID === id14) eventHandler();
    });
  }
  function _addEventHandlerIfFileStillExists2(eventName, fileID, eventHandler) {
    var _this = this;
    this.uploaderEvents[fileID].on(eventName, function() {
      if (_this.uppy.getFile(fileID)) eventHandler(...arguments);
    });
  }
  function _uploadLocalFile2(file, current, total) {
    const opts = _classPrivateFieldLooseBase10(this, _getOptions)[_getOptions](file);
    this.uppy.log(`uploading ${current} of ${total}`);
    return new Promise((resolve, reject) => {
      const data = opts.formData ? createFormDataUpload(file, opts) : createBareUpload(file, opts);
      const xhr = new XMLHttpRequest();
      this.uploaderEvents[file.id] = new EventTracker(this.uppy);
      const timer = new ProgressTimeout_default(opts.timeout, () => {
        xhr.abort();
        queuedRequest.done();
        const error2 = new Error(this.i18n("timedOut", {
          seconds: Math.ceil(opts.timeout / 1e3)
        }));
        this.uppy.emit("upload-error", file, error2);
        reject(error2);
      });
      const id14 = nanoid();
      xhr.upload.addEventListener("loadstart", () => {
        this.uppy.log(`[AwsS3/XHRUpload] ${id14} started`);
      });
      xhr.upload.addEventListener("progress", (ev) => {
        this.uppy.log(`[AwsS3/XHRUpload] ${id14} progress: ${ev.loaded} / ${ev.total}`);
        timer.progress();
        if (ev.lengthComputable) {
          this.uppy.emit("upload-progress", file, {
            uploader: this,
            bytesUploaded: ev.loaded,
            bytesTotal: ev.total
          });
        }
      });
      xhr.addEventListener("load", (ev) => {
        this.uppy.log(`[AwsS3/XHRUpload] ${id14} finished`);
        timer.done();
        queuedRequest.done();
        if (this.uploaderEvents[file.id]) {
          this.uploaderEvents[file.id].remove();
          this.uploaderEvents[file.id] = null;
        }
        if (opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
          const body2 = opts.getResponseData(xhr.responseText, xhr);
          const uploadURL = body2[opts.responseUrlFieldName];
          const uploadResp = {
            status: ev.target.status,
            body: body2,
            uploadURL
          };
          this.uppy.emit("upload-success", file, uploadResp);
          if (uploadURL) {
            this.uppy.log(`Download ${file.name} from ${uploadURL}`);
          }
          return resolve(file);
        }
        const body = opts.getResponseData(xhr.responseText, xhr);
        const error2 = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
        const response = {
          status: ev.target.status,
          body
        };
        this.uppy.emit("upload-error", file, error2, response);
        return reject(error2);
      });
      xhr.addEventListener("error", () => {
        this.uppy.log(`[AwsS3/XHRUpload] ${id14} errored`);
        timer.done();
        queuedRequest.done();
        if (this.uploaderEvents[file.id]) {
          this.uploaderEvents[file.id].remove();
          this.uploaderEvents[file.id] = null;
        }
        const error2 = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
        this.uppy.emit("upload-error", file, error2);
        return reject(error2);
      });
      xhr.open(opts.method.toUpperCase(), opts.endpoint, true);
      xhr.withCredentials = Boolean(opts.withCredentials);
      if (opts.responseType !== "") {
        xhr.responseType = opts.responseType;
      }
      Object.keys(opts.headers).forEach((header) => {
        xhr.setRequestHeader(header, opts.headers[header]);
      });
      const queuedRequest = this.requests.run(() => {
        xhr.send(data);
        return () => {
          timer.done();
          xhr.abort();
        };
      }, {
        priority: 1
      });
      _classPrivateFieldLooseBase10(this, _addEventHandlerForFile)[_addEventHandlerForFile]("file-removed", file.id, () => {
        queuedRequest.abort();
        reject(new Error("File removed"));
      });
      _classPrivateFieldLooseBase10(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]("cancel-all", file.id, function(_temp2) {
        let {
          reason
        } = _temp2 === void 0 ? {} : _temp2;
        if (reason === "user") {
          queuedRequest.abort();
        }
        reject(new Error("Upload cancelled"));
      });
    });
  }
  async function _uploadRemoteFile2(file) {
    try {
      if (file.serverToken) {
        return this.connectToServerSocket(file);
      }
      const serverToken = await _classPrivateFieldLooseBase10(this, _queueRequestSocketToken)[_queueRequestSocketToken](file);
      if (!this.uppy.getState().files[file.id]) return void 0;
      this.uppy.setFileState(file.id, {
        serverToken
      });
      return this.connectToServerSocket(this.uppy.getFile(file.id));
    } catch (err) {
      this.uppy.emit("upload-error", file, err);
      throw err;
    }
  }

  // ../../node_modules/@uppy/aws-s3/lib/isXml.js
  function removeMimeParameters(mimeType) {
    return mimeType.replace(/;.*$/, "");
  }
  function isXml(content, xhr) {
    const rawContentType = xhr.headers ? xhr.headers["content-type"] : xhr.getResponseHeader("Content-Type");
    if (typeof rawContentType === "string") {
      const contentType = removeMimeParameters(rawContentType).toLowerCase();
      if (contentType === "application/xml" || contentType === "text/xml") {
        return true;
      }
      if (contentType === "text/html" && /^<\?xml /.test(content)) {
        return true;
      }
    }
    return false;
  }
  var isXml_default = isXml;

  // ../../node_modules/@uppy/aws-s3/lib/locale.js
  var locale_default3 = {
    strings: {
      timedOut: "Upload stalled for %{seconds} seconds, aborting."
    }
  };

  // ../../node_modules/@uppy/aws-s3/lib/index.js
  var _Symbol$for5;
  function _classPrivateFieldLooseBase11(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id11 = 0;
  function _classPrivateFieldLooseKey11(name) {
    return "__private_" + id11++ + "_" + name;
  }
  var packageJson6 = {
    "version": "3.0.5"
  };
  function resolveUrl(origin, link) {
    if (!origin && !link.startsWith("https://") && !link.startsWith("http://")) {
      link = `https://${link}`;
    }
    return new URL(link, origin || void 0).toString();
  }
  function getXmlValue(source, tagName) {
    const start4 = source.indexOf(`<${tagName}>`);
    const end3 = source.indexOf(`</${tagName}>`, start4);
    return start4 !== -1 && end3 !== -1 ? source.slice(start4 + tagName.length + 2, end3) : "";
  }
  function assertServerError(res) {
    if (res && res.error) {
      const error2 = new Error(res.message);
      Object.assign(error2, res.error);
      throw error2;
    }
    return res;
  }
  function validateParameters(file, params) {
    const valid = params != null && typeof params.url === "string" && (typeof params.fields === "object" || params.fields == null);
    if (!valid) {
      const err = new TypeError(`AwsS3: got incorrect result from 'getUploadParameters()' for file '${file.name}', expected an object '{ url, method, fields, headers }' but got '${JSON.stringify(params)}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`);
      throw err;
    }
    const methodIsValid = params.method == null || /^p(u|os)t$/i.test(params.method);
    if (!methodIsValid) {
      const err = new TypeError(`AwsS3: got incorrect method from 'getUploadParameters()' for file '${file.name}', expected  'put' or 'post' but got '${params.method}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`);
      throw err;
    }
  }
  function defaultGetResponseError(content, xhr) {
    if (!isXml_default(content, xhr)) {
      return void 0;
    }
    const error2 = getXmlValue(content, "Message");
    return new Error(error2);
  }
  var warnedSuccessActionStatus = false;
  var _client = /* @__PURE__ */ _classPrivateFieldLooseKey11("client");
  var _requests = /* @__PURE__ */ _classPrivateFieldLooseKey11("requests");
  var _uploader = /* @__PURE__ */ _classPrivateFieldLooseKey11("uploader");
  var _handleUpload = /* @__PURE__ */ _classPrivateFieldLooseKey11("handleUpload");
  var _setCompanionHeaders = /* @__PURE__ */ _classPrivateFieldLooseKey11("setCompanionHeaders");
  _Symbol$for5 = Symbol.for("uppy test: getClient");
  var AwsS3 = class extends BasePlugin {
    constructor(uppy, opts) {
      super(uppy, opts);
      Object.defineProperty(this, _client, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _requests, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _uploader, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _handleUpload, {
        writable: true,
        value: (fileIDs) => {
          const paramsPromises = /* @__PURE__ */ Object.create(null);
          function onremove(file) {
            var _paramsPromises$id;
            const {
              id: id14
            } = file;
            (_paramsPromises$id = paramsPromises[id14]) == null ? void 0 : _paramsPromises$id.abort();
          }
          this.uppy.on("file-removed", onremove);
          fileIDs.forEach((id14) => {
            const file = this.uppy.getFile(id14);
            this.uppy.emit("upload-started", file);
          });
          const getUploadParameters = _classPrivateFieldLooseBase11(this, _requests)[_requests].wrapPromiseFunction((file) => {
            return this.opts.getUploadParameters(file);
          });
          const numberOfFiles = fileIDs.length;
          return Promise.allSettled(fileIDs.map((id14, index) => {
            paramsPromises[id14] = getUploadParameters(this.uppy.getFile(id14));
            return paramsPromises[id14].then((params) => {
              delete paramsPromises[id14];
              const file = this.uppy.getFile(id14);
              validateParameters(file, params);
              const {
                method = "post",
                url,
                fields,
                headers
              } = params;
              const xhrOpts = {
                method,
                formData: method.toLowerCase() === "post",
                endpoint: url,
                allowedMetaFields: fields ? Object.keys(fields) : []
              };
              if (headers) {
                xhrOpts.headers = headers;
              }
              this.uppy.setFileState(file.id, {
                meta: {
                  ...file.meta,
                  ...fields
                },
                xhrUpload: xhrOpts
              });
              return _classPrivateFieldLooseBase11(this, _uploader)[_uploader].uploadFile(file.id, index, numberOfFiles);
            }).catch((error2) => {
              delete paramsPromises[id14];
              const file = this.uppy.getFile(id14);
              this.uppy.emit("upload-error", file, error2);
              return Promise.reject(error2);
            });
          })).finally(() => {
            this.uppy.off("file-removed", onremove);
          });
        }
      });
      Object.defineProperty(this, _setCompanionHeaders, {
        writable: true,
        value: () => {
          _classPrivateFieldLooseBase11(this, _client)[_client].setCompanionHeaders(this.opts.companionHeaders);
          return Promise.resolve();
        }
      });
      this.type = "uploader";
      this.id = this.opts.id || "AwsS3";
      this.title = "AWS S3";
      this.defaultLocale = locale_default3;
      const defaultOptions4 = {
        timeout: 30 * 1e3,
        limit: 0,
        allowedMetaFields: [],
        // have to opt in
        getUploadParameters: this.getUploadParameters.bind(this),
        companionHeaders: {}
      };
      this.opts = {
        ...defaultOptions4,
        ...opts
      };
      if ((opts == null ? void 0 : opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
        throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
      }
      this.i18nInit();
      _classPrivateFieldLooseBase11(this, _client)[_client] = new RequestClient(uppy, opts);
      _classPrivateFieldLooseBase11(this, _requests)[_requests] = new RateLimitedQueue(this.opts.limit);
    }
    [_Symbol$for5]() {
      return _classPrivateFieldLooseBase11(this, _client)[_client];
    }
    // TODO: remove getter and setter for #client on the next major release
    get client() {
      return _classPrivateFieldLooseBase11(this, _client)[_client];
    }
    set client(client) {
      _classPrivateFieldLooseBase11(this, _client)[_client] = client;
    }
    getUploadParameters(file) {
      if (!this.opts.companionUrl) {
        throw new Error("Expected a `companionUrl` option containing a Companion address.");
      }
      const filename = file.meta.name;
      const {
        type
      } = file.meta;
      const metadata = Object.fromEntries(this.opts.allowedMetaFields.filter((key) => file.meta[key] != null).map((key) => [`metadata[${key}]`, file.meta[key].toString()]));
      const query = new URLSearchParams({
        filename,
        type,
        ...metadata
      });
      return _classPrivateFieldLooseBase11(this, _client)[_client].get(`s3/params?${query}`).then(assertServerError);
    }
    install() {
      const {
        uppy
      } = this;
      uppy.addPreProcessor(_classPrivateFieldLooseBase11(this, _setCompanionHeaders)[_setCompanionHeaders]);
      uppy.addUploader(_classPrivateFieldLooseBase11(this, _handleUpload)[_handleUpload]);
      function defaultGetResponseData(content, xhr) {
        const opts = this;
        if (!isXml_default(content, xhr)) {
          if (opts.method.toUpperCase() === "POST") {
            if (!warnedSuccessActionStatus) {
              uppy.log("[AwsS3] No response data found, make sure to set the success_action_status AWS SDK option to 201. See https://uppy.io/docs/aws-s3/#POST-Uploads", "warning");
              warnedSuccessActionStatus = true;
            }
            return {
              location: null
            };
          }
          if (!xhr.responseURL) {
            return {
              location: null
            };
          }
          return {
            location: xhr.responseURL.replace(/\?.*$/, "")
          };
        }
        return {
          // Some S3 alternatives do not reply with an absolute URL.
          // Eg DigitalOcean Spaces uses /$bucketName/xyz
          location: resolveUrl(xhr.responseURL, getXmlValue(content, "Location")),
          bucket: getXmlValue(content, "Bucket"),
          key: getXmlValue(content, "Key"),
          etag: getXmlValue(content, "ETag")
        };
      }
      const xhrOptions = {
        fieldName: "file",
        responseUrlFieldName: "location",
        timeout: this.opts.timeout,
        // Share the rate limiting queue with XHRUpload.
        [internalRateLimitedQueue]: _classPrivateFieldLooseBase11(this, _requests)[_requests],
        responseType: "text",
        getResponseData: this.opts.getResponseData || defaultGetResponseData,
        getResponseError: defaultGetResponseError
      };
      xhrOptions.i18n = this.i18n;
      _classPrivateFieldLooseBase11(this, _uploader)[_uploader] = new MiniXHRUpload(uppy, xhrOptions);
    }
    uninstall() {
      this.uppy.removePreProcessor(_classPrivateFieldLooseBase11(this, _setCompanionHeaders)[_setCompanionHeaders]);
      this.uppy.removeUploader(_classPrivateFieldLooseBase11(this, _handleUpload)[_handleUpload]);
    }
  };
  AwsS3.VERSION = packageJson6.version;

  // ../../node_modules/@uppy/compressor/node_modules/@uppy/utils/lib/RateLimitedQueue.js
  function _classPrivateFieldLooseBase12(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id12 = 0;
  function _classPrivateFieldLooseKey12(name) {
    return "__private_" + id12++ + "_" + name;
  }
  function createCancelError2(cause) {
    return new Error("Cancelled", {
      cause
    });
  }
  function abortOn2(signal) {
    if (signal != null) {
      var _this$then;
      const abortPromise = () => this.abort(signal.reason);
      signal.addEventListener("abort", abortPromise, {
        once: true
      });
      const removeAbortListener = () => {
        signal.removeEventListener("abort", abortPromise);
      };
      (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);
    }
    return this;
  }
  var _activeRequests2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("activeRequests");
  var _queuedHandlers2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("queuedHandlers");
  var _paused2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("paused");
  var _pauseTimer2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("pauseTimer");
  var _downLimit2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("downLimit");
  var _upperLimit2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("upperLimit");
  var _rateLimitingTimer2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("rateLimitingTimer");
  var _call3 = /* @__PURE__ */ _classPrivateFieldLooseKey12("call");
  var _queueNext3 = /* @__PURE__ */ _classPrivateFieldLooseKey12("queueNext");
  var _next3 = /* @__PURE__ */ _classPrivateFieldLooseKey12("next");
  var _queue3 = /* @__PURE__ */ _classPrivateFieldLooseKey12("queue");
  var _dequeue3 = /* @__PURE__ */ _classPrivateFieldLooseKey12("dequeue");
  var _resume2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("resume");
  var _increaseLimit2 = /* @__PURE__ */ _classPrivateFieldLooseKey12("increaseLimit");
  var RateLimitedQueue2 = class {
    constructor(limit) {
      Object.defineProperty(this, _dequeue3, {
        value: _dequeue22
      });
      Object.defineProperty(this, _queue3, {
        value: _queue22
      });
      Object.defineProperty(this, _next3, {
        value: _next22
      });
      Object.defineProperty(this, _queueNext3, {
        value: _queueNext22
      });
      Object.defineProperty(this, _call3, {
        value: _call22
      });
      Object.defineProperty(this, _activeRequests2, {
        writable: true,
        value: 0
      });
      Object.defineProperty(this, _queuedHandlers2, {
        writable: true,
        value: []
      });
      Object.defineProperty(this, _paused2, {
        writable: true,
        value: false
      });
      Object.defineProperty(this, _pauseTimer2, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _downLimit2, {
        writable: true,
        value: 1
      });
      Object.defineProperty(this, _upperLimit2, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _rateLimitingTimer2, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _resume2, {
        writable: true,
        value: () => this.resume()
      });
      Object.defineProperty(this, _increaseLimit2, {
        writable: true,
        value: () => {
          if (_classPrivateFieldLooseBase12(this, _paused2)[_paused2]) {
            _classPrivateFieldLooseBase12(this, _rateLimitingTimer2)[_rateLimitingTimer2] = setTimeout(_classPrivateFieldLooseBase12(this, _increaseLimit2)[_increaseLimit2], 0);
            return;
          }
          _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2] = this.limit;
          this.limit = Math.ceil((_classPrivateFieldLooseBase12(this, _upperLimit2)[_upperLimit2] + _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2]) / 2);
          for (let i4 = _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2]; i4 <= this.limit; i4++) {
            _classPrivateFieldLooseBase12(this, _queueNext3)[_queueNext3]();
          }
          if (_classPrivateFieldLooseBase12(this, _upperLimit2)[_upperLimit2] - _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2] > 3) {
            _classPrivateFieldLooseBase12(this, _rateLimitingTimer2)[_rateLimitingTimer2] = setTimeout(_classPrivateFieldLooseBase12(this, _increaseLimit2)[_increaseLimit2], 2e3);
          } else {
            _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2] = Math.floor(_classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2] / 2);
          }
        }
      });
      if (typeof limit !== "number" || limit === 0) {
        this.limit = Infinity;
      } else {
        this.limit = limit;
      }
    }
    run(fn4, queueOptions) {
      if (!_classPrivateFieldLooseBase12(this, _paused2)[_paused2] && _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] < this.limit) {
        return _classPrivateFieldLooseBase12(this, _call3)[_call3](fn4);
      }
      return _classPrivateFieldLooseBase12(this, _queue3)[_queue3](fn4, queueOptions);
    }
    wrapSyncFunction(fn4, queueOptions) {
      var _this = this;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const queuedRequest = _this.run(() => {
          fn4(...args);
          queueMicrotask(() => queuedRequest.done());
          return () => {
          };
        }, queueOptions);
        return {
          abortOn: abortOn2,
          abort() {
            queuedRequest.abort();
          }
        };
      };
    }
    wrapPromiseFunction(fn4, queueOptions) {
      var _this2 = this;
      return function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        let queuedRequest;
        const outerPromise = new Promise((resolve, reject) => {
          queuedRequest = _this2.run(() => {
            let cancelError;
            let innerPromise;
            try {
              innerPromise = Promise.resolve(fn4(...args));
            } catch (err) {
              innerPromise = Promise.reject(err);
            }
            innerPromise.then((result) => {
              if (cancelError) {
                reject(cancelError);
              } else {
                queuedRequest.done();
                resolve(result);
              }
            }, (err) => {
              if (cancelError) {
                reject(cancelError);
              } else {
                queuedRequest.done();
                reject(err);
              }
            });
            return (cause) => {
              cancelError = createCancelError2(cause);
            };
          }, queueOptions);
        });
        outerPromise.abort = (cause) => {
          queuedRequest.abort(cause);
        };
        outerPromise.abortOn = abortOn2;
        return outerPromise;
      };
    }
    resume() {
      _classPrivateFieldLooseBase12(this, _paused2)[_paused2] = false;
      clearTimeout(_classPrivateFieldLooseBase12(this, _pauseTimer2)[_pauseTimer2]);
      for (let i4 = 0; i4 < this.limit; i4++) {
        _classPrivateFieldLooseBase12(this, _queueNext3)[_queueNext3]();
      }
    }
    /**
     * Freezes the queue for a while or indefinitely.
     *
     * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
     *                                    If omitted, the queue won't resume automatically.
     */
    pause(duration) {
      if (duration === void 0) {
        duration = null;
      }
      _classPrivateFieldLooseBase12(this, _paused2)[_paused2] = true;
      clearTimeout(_classPrivateFieldLooseBase12(this, _pauseTimer2)[_pauseTimer2]);
      if (duration != null) {
        _classPrivateFieldLooseBase12(this, _pauseTimer2)[_pauseTimer2] = setTimeout(_classPrivateFieldLooseBase12(this, _resume2)[_resume2], duration);
      }
    }
    /**
     * Pauses the queue for a duration, and lower the limit of concurrent requests
     * when the queue resumes. When the queue resumes, it tries to progressively
     * increase the limit in `this.#increaseLimit` until another call is made to
     * `this.rateLimit`.
     * Call this function when using the RateLimitedQueue for network requests and
     * the remote server responds with 429 HTTP code.
     *
     * @param {number} duration in milliseconds.
     */
    rateLimit(duration) {
      clearTimeout(_classPrivateFieldLooseBase12(this, _rateLimitingTimer2)[_rateLimitingTimer2]);
      this.pause(duration);
      if (this.limit > 1 && Number.isFinite(this.limit)) {
        _classPrivateFieldLooseBase12(this, _upperLimit2)[_upperLimit2] = this.limit - 1;
        this.limit = _classPrivateFieldLooseBase12(this, _downLimit2)[_downLimit2];
        _classPrivateFieldLooseBase12(this, _rateLimitingTimer2)[_rateLimitingTimer2] = setTimeout(_classPrivateFieldLooseBase12(this, _increaseLimit2)[_increaseLimit2], duration);
      }
    }
    get isPaused() {
      return _classPrivateFieldLooseBase12(this, _paused2)[_paused2];
    }
  };
  function _call22(fn4) {
    _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] += 1;
    let done = false;
    let cancelActive;
    try {
      cancelActive = fn4();
    } catch (err) {
      _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] -= 1;
      throw err;
    }
    return {
      abort: (cause) => {
        if (done) return;
        done = true;
        _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] -= 1;
        cancelActive == null || cancelActive(cause);
        _classPrivateFieldLooseBase12(this, _queueNext3)[_queueNext3]();
      },
      done: () => {
        if (done) return;
        done = true;
        _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] -= 1;
        _classPrivateFieldLooseBase12(this, _queueNext3)[_queueNext3]();
      }
    };
  }
  function _queueNext22() {
    queueMicrotask(() => _classPrivateFieldLooseBase12(this, _next3)[_next3]());
  }
  function _next22() {
    if (_classPrivateFieldLooseBase12(this, _paused2)[_paused2] || _classPrivateFieldLooseBase12(this, _activeRequests2)[_activeRequests2] >= this.limit) {
      return;
    }
    if (_classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].length === 0) {
      return;
    }
    const next = _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].shift();
    if (next == null) {
      throw new Error("Invariant violation: next is null");
    }
    const handler = _classPrivateFieldLooseBase12(this, _call3)[_call3](next.fn);
    next.abort = handler.abort;
    next.done = handler.done;
  }
  function _queue22(fn4, options) {
    const handler = {
      fn: fn4,
      priority: (options == null ? void 0 : options.priority) || 0,
      abort: () => {
        _classPrivateFieldLooseBase12(this, _dequeue3)[_dequeue3](handler);
      },
      done: () => {
        throw new Error("Cannot mark a queued request as done: this indicates a bug");
      }
    };
    const index = _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].findIndex((other) => {
      return handler.priority > other.priority;
    });
    if (index === -1) {
      _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].push(handler);
    } else {
      _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].splice(index, 0, handler);
    }
    return handler;
  }
  function _dequeue22(handler) {
    const index = _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].indexOf(handler);
    if (index !== -1) {
      _classPrivateFieldLooseBase12(this, _queuedHandlers2)[_queuedHandlers2].splice(index, 1);
    }
  }
  var internalRateLimitedQueue2 = Symbol("__queue");

  // ../../node_modules/@uppy/compressor/node_modules/@uppy/utils/lib/getFileNameAndExtension.js
  function getFileNameAndExtension2(fullFileName) {
    const lastDot = fullFileName.lastIndexOf(".");
    if (lastDot === -1 || lastDot === fullFileName.length - 1) {
      return {
        name: fullFileName,
        extension: void 0
      };
    }
    return {
      name: fullFileName.slice(0, lastDot),
      extension: fullFileName.slice(lastDot + 1)
    };
  }

  // ../../node_modules/@uppy/compressor/lib/index.js
  var import_prettier_bytes2 = __toESM(require_prettierBytes2(), 1);
  var import_compressorjs = __toESM(require_compressor(), 1);

  // ../../node_modules/@uppy/compressor/lib/locale.js
  var locale_default4 = {
    strings: {
      // Shown in the Status Bar
      compressingImages: "Compressing images...",
      compressedX: "Saved %{size} by compressing images"
    }
  };

  // ../../node_modules/@uppy/compressor/lib/index.js
  function _classPrivateFieldLooseBase13(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
  var id13 = 0;
  function _classPrivateFieldLooseKey13(name) {
    return "__private_" + id13++ + "_" + name;
  }
  var _RateLimitedQueue = /* @__PURE__ */ _classPrivateFieldLooseKey13("RateLimitedQueue");
  var Compressor = class extends BasePlugin {
    constructor(uppy, opts) {
      super(uppy, opts);
      Object.defineProperty(this, _RateLimitedQueue, {
        writable: true,
        value: void 0
      });
      this.id = this.opts.id || "Compressor";
      this.type = "modifier";
      this.defaultLocale = locale_default4;
      const defaultOptions4 = {
        quality: 0.6,
        limit: 10
      };
      this.opts = {
        ...defaultOptions4,
        ...opts
      };
      _classPrivateFieldLooseBase13(this, _RateLimitedQueue)[_RateLimitedQueue] = new RateLimitedQueue2(this.opts.limit);
      this.i18nInit();
      this.prepareUpload = this.prepareUpload.bind(this);
      this.compress = this.compress.bind(this);
    }
    compress(blob) {
      return new Promise((resolve, reject) => {
        new import_compressorjs.default(blob, {
          ...this.opts,
          success: resolve,
          error: reject
        });
      });
    }
    async prepareUpload(fileIDs) {
      let totalCompressedSize = 0;
      const compressedFiles = [];
      const compressAndApplyResult = _classPrivateFieldLooseBase13(this, _RateLimitedQueue)[_RateLimitedQueue].wrapPromiseFunction(async (file) => {
        try {
          const compressedBlob = await this.compress(file.data);
          const compressedSavingsSize = file.data.size - compressedBlob.size;
          this.uppy.log(`[Image Compressor] Image ${file.id} compressed by ${(0, import_prettier_bytes2.default)(compressedSavingsSize)}`);
          totalCompressedSize += compressedSavingsSize;
          const {
            name,
            type,
            size
          } = compressedBlob;
          const compressedFileName = getFileNameAndExtension2(name);
          const metaFileName = getFileNameAndExtension2(file.meta.name);
          const newMetaName = `${metaFileName.name}.${compressedFileName.extension}`;
          this.uppy.setFileState(file.id, {
            ...name && {
              name
            },
            ...compressedFileName.extension && {
              extension: compressedFileName.extension
            },
            ...type && {
              type
            },
            ...size && {
              size
            },
            data: compressedBlob,
            meta: {
              ...file.meta,
              type,
              name: newMetaName
            }
          });
          compressedFiles.push(file);
        } catch (err) {
          this.uppy.log(`[Image Compressor] Failed to compress ${file.id}:`, "warning");
          this.uppy.log(err, "warning");
        }
      });
      const promises = fileIDs.map((fileID) => {
        var _file$type;
        const file = this.uppy.getFile(fileID);
        this.uppy.emit("preprocess-progress", file, {
          mode: "indeterminate",
          message: this.i18n("compressingImages")
        });
        if (file.isRemote) {
          return Promise.resolve();
        }
        if (!file.data.type) {
          file.data = file.data.slice(0, file.data.size, file.type);
        }
        if (!((_file$type = file.type) != null && _file$type.startsWith("image/"))) {
          return Promise.resolve();
        }
        return compressAndApplyResult(file);
      });
      await Promise.all(promises);
      this.uppy.emit("compressor:complete", compressedFiles);
      if (totalCompressedSize > 1024) {
        this.uppy.info(this.i18n("compressedX", {
          size: (0, import_prettier_bytes2.default)(totalCompressedSize)
        }), "info");
      }
      for (const fileID of fileIDs) {
        const file = this.uppy.getFile(fileID);
        this.uppy.emit("preprocess-complete", file);
      }
    }
    install() {
      this.uppy.addPreProcessor(this.prepareUpload);
    }
    uninstall() {
      this.uppy.removePreProcessor(this.prepareUpload);
    }
  };

  // ../../node_modules/@uppy/utils/lib/dataURItoBlob.js
  var DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
  function dataURItoBlob(dataURI, opts, toFile) {
    var _ref, _opts$mimeType;
    const dataURIData = DATA_URL_PATTERN.exec(dataURI);
    const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : "plain/text";
    let data;
    if (dataURIData[2] != null) {
      const binary = atob(decodeURIComponent(dataURIData[3]));
      const bytes = new Uint8Array(binary.length);
      for (let i4 = 0; i4 < binary.length; i4++) {
        bytes[i4] = binary.charCodeAt(i4);
      }
      data = [bytes];
    } else {
      data = [decodeURIComponent(dataURIData[3])];
    }
    if (toFile) {
      return new File(data, opts.name || "", {
        type: mimeType
      });
    }
    return new Blob(data, {
      type: mimeType
    });
  }

  // ../../node_modules/@uppy/utils/lib/isObjectURL.js
  function isObjectURL(url) {
    return url.startsWith("blob:");
  }

  // ../../node_modules/@uppy/utils/lib/isPreviewSupported.js
  function isPreviewSupported(fileType) {
    if (!fileType) return false;
    return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
  }

  // ../../node_modules/exifr/dist/mini.esm.mjs
  function e2(e4, t5, s4) {
    return t5 in e4 ? Object.defineProperty(e4, t5, { value: s4, enumerable: true, configurable: true, writable: true }) : e4[t5] = s4, e4;
  }
  var t2 = "undefined" != typeof self ? self : global;
  var s2 = "undefined" != typeof navigator;
  var i2 = s2 && "undefined" == typeof HTMLImageElement;
  var n2 = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node);
  var r2 = t2.Buffer;
  var a2 = !!r2;
  var h2 = (e4) => void 0 !== e4;
  function f2(e4) {
    return void 0 === e4 || (e4 instanceof Map ? 0 === e4.size : 0 === Object.values(e4).filter(h2).length);
  }
  function l2(e4) {
    let t5 = new Error(e4);
    throw delete t5.stack, t5;
  }
  function o2(e4) {
    let t5 = function(e5) {
      let t6 = 0;
      return e5.ifd0.enabled && (t6 += 1024), e5.exif.enabled && (t6 += 2048), e5.makerNote && (t6 += 2048), e5.userComment && (t6 += 1024), e5.gps.enabled && (t6 += 512), e5.interop.enabled && (t6 += 100), e5.ifd1.enabled && (t6 += 1024), t6 + 2048;
    }(e4);
    return e4.jfif.enabled && (t5 += 50), e4.xmp.enabled && (t5 += 2e4), e4.iptc.enabled && (t5 += 14e3), e4.icc.enabled && (t5 += 6e3), t5;
  }
  var u2 = (e4) => String.fromCharCode.apply(null, e4);
  var d2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
  var c2 = class _c {
    static from(e4, t5) {
      return e4 instanceof this && e4.le === t5 ? e4 : new _c(e4, void 0, void 0, t5);
    }
    constructor(e4, t5 = 0, s4, i4) {
      if ("boolean" == typeof i4 && (this.le = i4), Array.isArray(e4) && (e4 = new Uint8Array(e4)), 0 === e4) this.byteOffset = 0, this.byteLength = 0;
      else if (e4 instanceof ArrayBuffer) {
        void 0 === s4 && (s4 = e4.byteLength - t5);
        let i5 = new DataView(e4, t5, s4);
        this._swapDataView(i5);
      } else if (e4 instanceof Uint8Array || e4 instanceof DataView || e4 instanceof _c) {
        void 0 === s4 && (s4 = e4.byteLength - t5), (t5 += e4.byteOffset) + s4 > e4.byteOffset + e4.byteLength && l2("Creating view outside of available memory in ArrayBuffer");
        let i5 = new DataView(e4.buffer, t5, s4);
        this._swapDataView(i5);
      } else if ("number" == typeof e4) {
        let t6 = new DataView(new ArrayBuffer(e4));
        this._swapDataView(t6);
      } else l2("Invalid input argument for BufferView: " + e4);
    }
    _swapArrayBuffer(e4) {
      this._swapDataView(new DataView(e4));
    }
    _swapBuffer(e4) {
      this._swapDataView(new DataView(e4.buffer, e4.byteOffset, e4.byteLength));
    }
    _swapDataView(e4) {
      this.dataView = e4, this.buffer = e4.buffer, this.byteOffset = e4.byteOffset, this.byteLength = e4.byteLength;
    }
    _lengthToEnd(e4) {
      return this.byteLength - e4;
    }
    set(e4, t5, s4 = _c) {
      return e4 instanceof DataView || e4 instanceof _c ? e4 = new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength) : e4 instanceof ArrayBuffer && (e4 = new Uint8Array(e4)), e4 instanceof Uint8Array || l2("BufferView.set(): Invalid data argument."), this.toUint8().set(e4, t5), new s4(this, t5, e4.byteLength);
    }
    subarray(e4, t5) {
      return t5 = t5 || this._lengthToEnd(e4), new _c(this, e4, t5);
    }
    toUint8() {
      return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
    }
    getUint8Array(e4, t5) {
      return new Uint8Array(this.buffer, this.byteOffset + e4, t5);
    }
    getString(e4 = 0, t5 = this.byteLength) {
      let s4 = this.getUint8Array(e4, t5);
      return i4 = s4, d2 ? d2.decode(i4) : a2 ? Buffer.from(i4).toString("utf8") : decodeURIComponent(escape(u2(i4)));
      var i4;
    }
    getLatin1String(e4 = 0, t5 = this.byteLength) {
      let s4 = this.getUint8Array(e4, t5);
      return u2(s4);
    }
    getUnicodeString(e4 = 0, t5 = this.byteLength) {
      const s4 = [];
      for (let i4 = 0; i4 < t5 && e4 + i4 < this.byteLength; i4 += 2) s4.push(this.getUint16(e4 + i4));
      return u2(s4);
    }
    getInt8(e4) {
      return this.dataView.getInt8(e4);
    }
    getUint8(e4) {
      return this.dataView.getUint8(e4);
    }
    getInt16(e4, t5 = this.le) {
      return this.dataView.getInt16(e4, t5);
    }
    getInt32(e4, t5 = this.le) {
      return this.dataView.getInt32(e4, t5);
    }
    getUint16(e4, t5 = this.le) {
      return this.dataView.getUint16(e4, t5);
    }
    getUint32(e4, t5 = this.le) {
      return this.dataView.getUint32(e4, t5);
    }
    getFloat32(e4, t5 = this.le) {
      return this.dataView.getFloat32(e4, t5);
    }
    getFloat64(e4, t5 = this.le) {
      return this.dataView.getFloat64(e4, t5);
    }
    getFloat(e4, t5 = this.le) {
      return this.dataView.getFloat32(e4, t5);
    }
    getDouble(e4, t5 = this.le) {
      return this.dataView.getFloat64(e4, t5);
    }
    getUintBytes(e4, t5, s4) {
      switch (t5) {
        case 1:
          return this.getUint8(e4, s4);
        case 2:
          return this.getUint16(e4, s4);
        case 4:
          return this.getUint32(e4, s4);
        case 8:
          return this.getUint64 && this.getUint64(e4, s4);
      }
    }
    getUint(e4, t5, s4) {
      switch (t5) {
        case 8:
          return this.getUint8(e4, s4);
        case 16:
          return this.getUint16(e4, s4);
        case 32:
          return this.getUint32(e4, s4);
        case 64:
          return this.getUint64 && this.getUint64(e4, s4);
      }
    }
    toString(e4) {
      return this.dataView.toString(e4, this.constructor.name);
    }
    ensureChunk() {
    }
  };
  function p2(e4, t5) {
    l2(`${e4} '${t5}' was not loaded, try using full build of exifr.`);
  }
  var g2 = class extends Map {
    constructor(e4) {
      super(), this.kind = e4;
    }
    get(e4, t5) {
      return this.has(e4) || p2(this.kind, e4), t5 && (e4 in t5 || function(e5, t6) {
        l2(`Unknown ${e5} '${t6}'.`);
      }(this.kind, e4), t5[e4].enabled || p2(this.kind, e4)), super.get(e4);
    }
    keyList() {
      return Array.from(this.keys());
    }
  };
  var m2 = new g2("file parser");
  var y2 = new g2("segment parser");
  var b2 = new g2("file reader");
  var w2 = t2.fetch;
  function k2(e4, t5) {
    return (i4 = e4).startsWith("data:") || i4.length > 1e4 ? v2(e4, t5, "base64") : n2 && e4.includes("://") ? O2(e4, t5, "url", S2) : n2 ? v2(e4, t5, "fs") : s2 ? O2(e4, t5, "url", S2) : void l2("Invalid input argument");
    var i4;
  }
  async function O2(e4, t5, s4, i4) {
    return b2.has(s4) ? v2(e4, t5, s4) : i4 ? async function(e5, t6) {
      let s5 = await t6(e5);
      return new c2(s5);
    }(e4, i4) : void l2(`Parser ${s4} is not loaded`);
  }
  async function v2(e4, t5, s4) {
    let i4 = new (b2.get(s4))(e4, t5);
    return await i4.read(), i4;
  }
  var S2 = (e4) => w2(e4).then((e5) => e5.arrayBuffer());
  var A2 = (e4) => new Promise((t5, s4) => {
    let i4 = new FileReader();
    i4.onloadend = () => t5(i4.result || new ArrayBuffer()), i4.onerror = s4, i4.readAsArrayBuffer(e4);
  });
  var U = class extends Map {
    get tagKeys() {
      return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
    }
    get tagValues() {
      return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
    }
  };
  function x2(e4, t5, s4) {
    let i4 = new U();
    for (let [e5, t6] of s4) i4.set(e5, t6);
    if (Array.isArray(t5)) for (let s5 of t5) e4.set(s5, i4);
    else e4.set(t5, i4);
    return i4;
  }
  function C2(e4, t5, s4) {
    let i4, n4 = e4.get(t5);
    for (i4 of s4) n4.set(i4[0], i4[1]);
  }
  var B2 = /* @__PURE__ */ new Map();
  var V = /* @__PURE__ */ new Map();
  var I2 = /* @__PURE__ */ new Map();
  var L2 = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"];
  var T2 = ["jfif", "xmp", "icc", "iptc", "ihdr"];
  var z2 = ["tiff", ...T2];
  var P2 = ["ifd0", "ifd1", "exif", "gps", "interop"];
  var F2 = [...z2, ...P2];
  var j2 = ["makerNote", "userComment"];
  var E = ["translateKeys", "translateValues", "reviveValues", "multiSegment"];
  var M2 = [...E, "sanitize", "mergeOutput", "silentErrors"];
  var _2 = class {
    get translate() {
      return this.translateKeys || this.translateValues || this.reviveValues;
    }
  };
  var D2 = class extends _2 {
    get needed() {
      return this.enabled || this.deps.size > 0;
    }
    constructor(t5, s4, i4, n4) {
      if (super(), e2(this, "enabled", false), e2(this, "skip", /* @__PURE__ */ new Set()), e2(this, "pick", /* @__PURE__ */ new Set()), e2(this, "deps", /* @__PURE__ */ new Set()), e2(this, "translateKeys", false), e2(this, "translateValues", false), e2(this, "reviveValues", false), this.key = t5, this.enabled = s4, this.parse = this.enabled, this.applyInheritables(n4), this.canBeFiltered = P2.includes(t5), this.canBeFiltered && (this.dict = B2.get(t5)), void 0 !== i4) if (Array.isArray(i4)) this.parse = this.enabled = true, this.canBeFiltered && i4.length > 0 && this.translateTagSet(i4, this.pick);
      else if ("object" == typeof i4) {
        if (this.enabled = true, this.parse = false !== i4.parse, this.canBeFiltered) {
          let { pick: e4, skip: t6 } = i4;
          e4 && e4.length > 0 && this.translateTagSet(e4, this.pick), t6 && t6.length > 0 && this.translateTagSet(t6, this.skip);
        }
        this.applyInheritables(i4);
      } else true === i4 || false === i4 ? this.parse = this.enabled = i4 : l2(`Invalid options argument: ${i4}`);
    }
    applyInheritables(e4) {
      let t5, s4;
      for (t5 of E) s4 = e4[t5], void 0 !== s4 && (this[t5] = s4);
    }
    translateTagSet(e4, t5) {
      if (this.dict) {
        let s4, i4, { tagKeys: n4, tagValues: r4 } = this.dict;
        for (s4 of e4) "string" == typeof s4 ? (i4 = r4.indexOf(s4), -1 === i4 && (i4 = n4.indexOf(Number(s4))), -1 !== i4 && t5.add(Number(n4[i4]))) : t5.add(s4);
      } else for (let s4 of e4) t5.add(s4);
    }
    finalizeFilters() {
      !this.enabled && this.deps.size > 0 ? (this.enabled = true, X(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && X(this.pick, this.deps);
    }
  };
  var N2 = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 };
  var $3 = /* @__PURE__ */ new Map();
  var R = class extends _2 {
    static useCached(e4) {
      let t5 = $3.get(e4);
      return void 0 !== t5 || (t5 = new this(e4), $3.set(e4, t5)), t5;
    }
    constructor(e4) {
      super(), true === e4 ? this.setupFromTrue() : void 0 === e4 ? this.setupFromUndefined() : Array.isArray(e4) ? this.setupFromArray(e4) : "object" == typeof e4 ? this.setupFromObject(e4) : l2(`Invalid options argument ${e4}`), void 0 === this.firstChunkSize && (this.firstChunkSize = s2 ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
    }
    setupFromUndefined() {
      let e4;
      for (e4 of L2) this[e4] = N2[e4];
      for (e4 of M2) this[e4] = N2[e4];
      for (e4 of j2) this[e4] = N2[e4];
      for (e4 of F2) this[e4] = new D2(e4, N2[e4], void 0, this);
    }
    setupFromTrue() {
      let e4;
      for (e4 of L2) this[e4] = N2[e4];
      for (e4 of M2) this[e4] = N2[e4];
      for (e4 of j2) this[e4] = true;
      for (e4 of F2) this[e4] = new D2(e4, true, void 0, this);
    }
    setupFromArray(e4) {
      let t5;
      for (t5 of L2) this[t5] = N2[t5];
      for (t5 of M2) this[t5] = N2[t5];
      for (t5 of j2) this[t5] = N2[t5];
      for (t5 of F2) this[t5] = new D2(t5, false, void 0, this);
      this.setupGlobalFilters(e4, void 0, P2);
    }
    setupFromObject(e4) {
      let t5;
      for (t5 of (P2.ifd0 = P2.ifd0 || P2.image, P2.ifd1 = P2.ifd1 || P2.thumbnail, Object.assign(this, e4), L2)) this[t5] = W(e4[t5], N2[t5]);
      for (t5 of M2) this[t5] = W(e4[t5], N2[t5]);
      for (t5 of j2) this[t5] = W(e4[t5], N2[t5]);
      for (t5 of z2) this[t5] = new D2(t5, N2[t5], e4[t5], this);
      for (t5 of P2) this[t5] = new D2(t5, N2[t5], e4[t5], this.tiff);
      this.setupGlobalFilters(e4.pick, e4.skip, P2, F2), true === e4.tiff ? this.batchEnableWithBool(P2, true) : false === e4.tiff ? this.batchEnableWithUserValue(P2, e4) : Array.isArray(e4.tiff) ? this.setupGlobalFilters(e4.tiff, void 0, P2) : "object" == typeof e4.tiff && this.setupGlobalFilters(e4.tiff.pick, e4.tiff.skip, P2);
    }
    batchEnableWithBool(e4, t5) {
      for (let s4 of e4) this[s4].enabled = t5;
    }
    batchEnableWithUserValue(e4, t5) {
      for (let s4 of e4) {
        let e5 = t5[s4];
        this[s4].enabled = false !== e5 && void 0 !== e5;
      }
    }
    setupGlobalFilters(e4, t5, s4, i4 = s4) {
      if (e4 && e4.length) {
        for (let e5 of i4) this[e5].enabled = false;
        let t6 = K(e4, s4);
        for (let [e5, s5] of t6) X(this[e5].pick, s5), this[e5].enabled = true;
      } else if (t5 && t5.length) {
        let e5 = K(t5, s4);
        for (let [t6, s5] of e5) X(this[t6].skip, s5);
      }
    }
    filterNestedSegmentTags() {
      let { ifd0: e4, exif: t5, xmp: s4, iptc: i4, icc: n4 } = this;
      this.makerNote ? t5.deps.add(37500) : t5.skip.add(37500), this.userComment ? t5.deps.add(37510) : t5.skip.add(37510), s4.enabled || e4.skip.add(700), i4.enabled || e4.skip.add(33723), n4.enabled || e4.skip.add(34675);
    }
    traverseTiffDependencyTree() {
      let { ifd0: e4, exif: t5, gps: s4, interop: i4 } = this;
      i4.needed && (t5.deps.add(40965), e4.deps.add(40965)), t5.needed && e4.deps.add(34665), s4.needed && e4.deps.add(34853), this.tiff.enabled = P2.some((e5) => true === this[e5].enabled) || this.makerNote || this.userComment;
      for (let e5 of P2) this[e5].finalizeFilters();
    }
    get onlyTiff() {
      return !T2.map((e4) => this[e4].enabled).some((e4) => true === e4) && this.tiff.enabled;
    }
    checkLoadedPlugins() {
      for (let e4 of z2) this[e4].enabled && !y2.has(e4) && p2("segment parser", e4);
    }
  };
  function K(e4, t5) {
    let s4, i4, n4, r4, a4 = [];
    for (n4 of t5) {
      for (r4 of (s4 = B2.get(n4), i4 = [], s4)) (e4.includes(r4[0]) || e4.includes(r4[1])) && i4.push(r4[0]);
      i4.length && a4.push([n4, i4]);
    }
    return a4;
  }
  function W(e4, t5) {
    return void 0 !== e4 ? e4 : void 0 !== t5 ? t5 : void 0;
  }
  function X(e4, t5) {
    for (let s4 of t5) e4.add(s4);
  }
  e2(R, "default", N2);
  var H2 = class {
    constructor(t5) {
      e2(this, "parsers", {}), e2(this, "output", {}), e2(this, "errors", []), e2(this, "pushToErrors", (e4) => this.errors.push(e4)), this.options = R.useCached(t5);
    }
    async read(e4) {
      this.file = await function(e5, t5) {
        return "string" == typeof e5 ? k2(e5, t5) : s2 && !i2 && e5 instanceof HTMLImageElement ? k2(e5.src, t5) : e5 instanceof Uint8Array || e5 instanceof ArrayBuffer || e5 instanceof DataView ? new c2(e5) : s2 && e5 instanceof Blob ? O2(e5, t5, "blob", A2) : void l2("Invalid input argument");
      }(e4, this.options);
    }
    setup() {
      if (this.fileParser) return;
      let { file: e4 } = this, t5 = e4.getUint16(0);
      for (let [s4, i4] of m2) if (i4.canHandle(e4, t5)) return this.fileParser = new i4(this.options, this.file, this.parsers), e4[s4] = true;
      this.file.close && this.file.close(), l2("Unknown file format");
    }
    async parse() {
      let { output: e4, errors: t5 } = this;
      return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t5.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t5.length > 0 && (e4.errors = t5), f2(s4 = e4) ? void 0 : s4;
      var s4;
    }
    async executeParsers() {
      let { output: e4 } = this;
      await this.fileParser.parse();
      let t5 = Object.values(this.parsers).map(async (t6) => {
        let s4 = await t6.parse();
        t6.assignToOutput(e4, s4);
      });
      this.options.silentErrors && (t5 = t5.map((e5) => e5.catch(this.pushToErrors))), await Promise.all(t5);
    }
    async extractThumbnail() {
      this.setup();
      let { options: e4, file: t5 } = this, s4 = y2.get("tiff", e4);
      var i4;
      if (t5.tiff ? i4 = { start: 0, type: "tiff" } : t5.jpeg && (i4 = await this.fileParser.getOrFindSegment("tiff")), void 0 === i4) return;
      let n4 = await this.fileParser.ensureSegmentChunk(i4), r4 = this.parsers.tiff = new s4(n4, e4, t5), a4 = await r4.extractThumbnail();
      return t5.close && t5.close(), a4;
    }
  };
  async function Y(e4, t5) {
    let s4 = new H2(t5);
    return await s4.read(e4), s4.parse();
  }
  var G = Object.freeze({ __proto__: null, parse: Y, Exifr: H2, fileParsers: m2, segmentParsers: y2, fileReaders: b2, tagKeys: B2, tagValues: V, tagRevivers: I2, createDictionary: x2, extendDictionary: C2, fetchUrlAsArrayBuffer: S2, readBlobAsArrayBuffer: A2, chunkedProps: L2, otherSegments: T2, segments: z2, tiffBlocks: P2, segmentsAndBlocks: F2, tiffExtractables: j2, inheritables: E, allFormatters: M2, Options: R });
  var J = class {
    static findPosition(e4, t5) {
      let s4 = e4.getUint16(t5 + 2) + 2, i4 = "function" == typeof this.headerLength ? this.headerLength(e4, t5, s4) : this.headerLength, n4 = t5 + i4, r4 = s4 - i4;
      return { offset: t5, length: s4, headerLength: i4, start: n4, size: r4, end: n4 + r4 };
    }
    static parse(e4, t5 = {}) {
      return new this(e4, new R({ [this.type]: t5 }), e4).parse();
    }
    normalizeInput(e4) {
      return e4 instanceof c2 ? e4 : new c2(e4);
    }
    constructor(t5, s4 = {}, i4) {
      e2(this, "errors", []), e2(this, "raw", /* @__PURE__ */ new Map()), e2(this, "handleError", (e4) => {
        if (!this.options.silentErrors) throw e4;
        this.errors.push(e4.message);
      }), this.chunk = this.normalizeInput(t5), this.file = i4, this.type = this.constructor.type, this.globalOptions = this.options = s4, this.localOptions = s4[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
    }
    translate() {
      this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
    }
    get output() {
      return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
    }
    translateBlock(e4, t5) {
      let s4 = I2.get(t5), i4 = V.get(t5), n4 = B2.get(t5), r4 = this.options[t5], a4 = r4.reviveValues && !!s4, h4 = r4.translateValues && !!i4, f4 = r4.translateKeys && !!n4, l4 = {};
      for (let [t6, r5] of e4) a4 && s4.has(t6) ? r5 = s4.get(t6)(r5) : h4 && i4.has(t6) && (r5 = this.translateValue(r5, i4.get(t6))), f4 && n4.has(t6) && (t6 = n4.get(t6) || t6), l4[t6] = r5;
      return l4;
    }
    translateValue(e4, t5) {
      return t5[e4] || t5.DEFAULT || e4;
    }
    assignToOutput(e4, t5) {
      this.assignObjectToOutput(e4, this.constructor.type, t5);
    }
    assignObjectToOutput(e4, t5, s4) {
      if (this.globalOptions.mergeOutput) return Object.assign(e4, s4);
      e4[t5] ? Object.assign(e4[t5], s4) : e4[t5] = s4;
    }
  };
  e2(J, "headerLength", 4), e2(J, "type", void 0), e2(J, "multiSegment", false), e2(J, "canHandle", () => false);
  function q2(e4) {
    return 192 === e4 || 194 === e4 || 196 === e4 || 219 === e4 || 221 === e4 || 218 === e4 || 254 === e4;
  }
  function Q(e4) {
    return e4 >= 224 && e4 <= 239;
  }
  function Z(e4, t5, s4) {
    for (let [i4, n4] of y2) if (n4.canHandle(e4, t5, s4)) return i4;
  }
  var ee3 = class extends class {
    constructor(t5, s4, i4) {
      e2(this, "errors", []), e2(this, "ensureSegmentChunk", async (e4) => {
        let t6 = e4.start, s5 = e4.size || 65536;
        if (this.file.chunked) if (this.file.available(t6, s5)) e4.chunk = this.file.subarray(t6, s5);
        else try {
          e4.chunk = await this.file.readChunk(t6, s5);
        } catch (t7) {
          l2(`Couldn't read segment: ${JSON.stringify(e4)}. ${t7.message}`);
        }
        else this.file.byteLength > t6 + s5 ? e4.chunk = this.file.subarray(t6, s5) : void 0 === e4.size ? e4.chunk = this.file.subarray(t6) : l2("Segment unreachable: " + JSON.stringify(e4));
        return e4.chunk;
      }), this.extendOptions && this.extendOptions(t5), this.options = t5, this.file = s4, this.parsers = i4;
    }
    injectSegment(e4, t5) {
      this.options[e4].enabled && this.createParser(e4, t5);
    }
    createParser(e4, t5) {
      let s4 = new (y2.get(e4))(t5, this.options, this.file);
      return this.parsers[e4] = s4;
    }
    createParsers(e4) {
      for (let t5 of e4) {
        let { type: e5, chunk: s4 } = t5, i4 = this.options[e5];
        if (i4 && i4.enabled) {
          let t6 = this.parsers[e5];
          t6 && t6.append || t6 || this.createParser(e5, s4);
        }
      }
    }
    async readSegments(e4) {
      let t5 = e4.map(this.ensureSegmentChunk);
      await Promise.all(t5);
    }
  } {
    constructor(...t5) {
      super(...t5), e2(this, "appSegments", []), e2(this, "jpegSegments", []), e2(this, "unknownSegments", []);
    }
    static canHandle(e4, t5) {
      return 65496 === t5;
    }
    async parse() {
      await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
    }
    setupSegmentFinderArgs(e4) {
      true === e4 ? (this.findAll = true, this.wanted = new Set(y2.keyList())) : (e4 = void 0 === e4 ? y2.keyList().filter((e5) => this.options[e5].enabled) : e4.filter((e5) => this.options[e5].enabled && y2.has(e5)), this.findAll = false, this.remaining = new Set(e4), this.wanted = new Set(e4)), this.unfinishedMultiSegment = false;
    }
    async findAppSegments(e4 = 0, t5) {
      this.setupSegmentFinderArgs(t5);
      let { file: s4, findAll: i4, wanted: n4, remaining: r4 } = this;
      if (!i4 && this.file.chunked && (i4 = Array.from(n4).some((e5) => {
        let t6 = y2.get(e5), s5 = this.options[e5];
        return t6.multiSegment && s5.multiSegment;
      }), i4 && await this.file.readWhole()), e4 = this.findAppSegmentsInRange(e4, s4.byteLength), !this.options.onlyTiff && s4.chunked) {
        let t6 = false;
        for (; r4.size > 0 && !t6 && (s4.canReadNextChunk || this.unfinishedMultiSegment); ) {
          let { nextChunkOffset: i5 } = s4, n5 = this.appSegments.some((e5) => !this.file.available(e5.offset || e5.start, e5.length || e5.size));
          if (t6 = e4 > i5 && !n5 ? !await s4.readNextChunk(e4) : !await s4.readNextChunk(i5), void 0 === (e4 = this.findAppSegmentsInRange(e4, s4.byteLength))) return;
        }
      }
    }
    findAppSegmentsInRange(e4, t5) {
      t5 -= 2;
      let s4, i4, n4, r4, a4, h4, { file: f4, findAll: l4, wanted: o4, remaining: u4, options: d4 } = this;
      for (; e4 < t5; e4++) if (255 === f4.getUint8(e4)) {
        if (s4 = f4.getUint8(e4 + 1), Q(s4)) {
          if (i4 = f4.getUint16(e4 + 2), n4 = Z(f4, e4, i4), n4 && o4.has(n4) && (r4 = y2.get(n4), a4 = r4.findPosition(f4, e4), h4 = d4[n4], a4.type = n4, this.appSegments.push(a4), !l4 && (r4.multiSegment && h4.multiSegment ? (this.unfinishedMultiSegment = a4.chunkNumber < a4.chunkCount, this.unfinishedMultiSegment || u4.delete(n4)) : u4.delete(n4), 0 === u4.size))) break;
          d4.recordUnknownSegments && (a4 = J.findPosition(f4, e4), a4.marker = s4, this.unknownSegments.push(a4)), e4 += i4 + 1;
        } else if (q2(s4)) {
          if (i4 = f4.getUint16(e4 + 2), 218 === s4 && false !== d4.stopAfterSos) return;
          d4.recordJpegSegments && this.jpegSegments.push({ offset: e4, length: i4, marker: s4 }), e4 += i4 + 1;
        }
      }
      return e4;
    }
    mergeMultiSegments() {
      if (!this.appSegments.some((e5) => e5.multiSegment)) return;
      let e4 = function(e5, t5) {
        let s4, i4, n4, r4 = /* @__PURE__ */ new Map();
        for (let a4 = 0; a4 < e5.length; a4++) s4 = e5[a4], i4 = s4[t5], r4.has(i4) ? n4 = r4.get(i4) : r4.set(i4, n4 = []), n4.push(s4);
        return Array.from(r4);
      }(this.appSegments, "type");
      this.mergedAppSegments = e4.map(([e5, t5]) => {
        let s4 = y2.get(e5, this.options);
        if (s4.handleMultiSegments) {
          return { type: e5, chunk: s4.handleMultiSegments(t5) };
        }
        return t5[0];
      });
    }
    getSegment(e4) {
      return this.appSegments.find((t5) => t5.type === e4);
    }
    async getOrFindSegment(e4) {
      let t5 = this.getSegment(e4);
      return void 0 === t5 && (await this.findAppSegments(0, [e4]), t5 = this.getSegment(e4)), t5;
    }
  };
  e2(ee3, "type", "jpeg"), m2.set("jpeg", ee3);
  var te = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
  var se = class extends J {
    parseHeader() {
      var e4 = this.chunk.getUint16();
      18761 === e4 ? this.le = true : 19789 === e4 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
    }
    parseTags(e4, t5, s4 = /* @__PURE__ */ new Map()) {
      let { pick: i4, skip: n4 } = this.options[t5];
      i4 = new Set(i4);
      let r4 = i4.size > 0, a4 = 0 === n4.size, h4 = this.chunk.getUint16(e4);
      e4 += 2;
      for (let f4 = 0; f4 < h4; f4++) {
        let h5 = this.chunk.getUint16(e4);
        if (r4) {
          if (i4.has(h5) && (s4.set(h5, this.parseTag(e4, h5, t5)), i4.delete(h5), 0 === i4.size)) break;
        } else !a4 && n4.has(h5) || s4.set(h5, this.parseTag(e4, h5, t5));
        e4 += 12;
      }
      return s4;
    }
    parseTag(e4, t5, s4) {
      let { chunk: i4 } = this, n4 = i4.getUint16(e4 + 2), r4 = i4.getUint32(e4 + 4), a4 = te[n4];
      if (a4 * r4 <= 4 ? e4 += 8 : e4 = i4.getUint32(e4 + 8), (n4 < 1 || n4 > 13) && l2(`Invalid TIFF value type. block: ${s4.toUpperCase()}, tag: ${t5.toString(16)}, type: ${n4}, offset ${e4}`), e4 > i4.byteLength && l2(`Invalid TIFF value offset. block: ${s4.toUpperCase()}, tag: ${t5.toString(16)}, type: ${n4}, offset ${e4} is outside of chunk size ${i4.byteLength}`), 1 === n4) return i4.getUint8Array(e4, r4);
      if (2 === n4) return "" === (h4 = function(e5) {
        for (; e5.endsWith("\0"); ) e5 = e5.slice(0, -1);
        return e5;
      }(h4 = i4.getString(e4, r4)).trim()) ? void 0 : h4;
      var h4;
      if (7 === n4) return i4.getUint8Array(e4, r4);
      if (1 === r4) return this.parseTagValue(n4, e4);
      {
        let t6 = new (function(e5) {
          switch (e5) {
            case 1:
              return Uint8Array;
            case 3:
              return Uint16Array;
            case 4:
              return Uint32Array;
            case 5:
              return Array;
            case 6:
              return Int8Array;
            case 8:
              return Int16Array;
            case 9:
              return Int32Array;
            case 10:
              return Array;
            case 11:
              return Float32Array;
            case 12:
              return Float64Array;
            default:
              return Array;
          }
        }(n4))(r4), s5 = a4;
        for (let i5 = 0; i5 < r4; i5++) t6[i5] = this.parseTagValue(n4, e4), e4 += s5;
        return t6;
      }
    }
    parseTagValue(e4, t5) {
      let { chunk: s4 } = this;
      switch (e4) {
        case 1:
          return s4.getUint8(t5);
        case 3:
          return s4.getUint16(t5);
        case 4:
          return s4.getUint32(t5);
        case 5:
          return s4.getUint32(t5) / s4.getUint32(t5 + 4);
        case 6:
          return s4.getInt8(t5);
        case 8:
          return s4.getInt16(t5);
        case 9:
          return s4.getInt32(t5);
        case 10:
          return s4.getInt32(t5) / s4.getInt32(t5 + 4);
        case 11:
          return s4.getFloat(t5);
        case 12:
          return s4.getDouble(t5);
        case 13:
          return s4.getUint32(t5);
        default:
          l2(`Invalid tiff type ${e4}`);
      }
    }
  };
  var ie = class extends se {
    static canHandle(e4, t5) {
      return 225 === e4.getUint8(t5 + 1) && 1165519206 === e4.getUint32(t5 + 4) && 0 === e4.getUint16(t5 + 8);
    }
    async parse() {
      this.parseHeader();
      let { options: e4 } = this;
      return e4.ifd0.enabled && await this.parseIfd0Block(), e4.exif.enabled && await this.safeParse("parseExifBlock"), e4.gps.enabled && await this.safeParse("parseGpsBlock"), e4.interop.enabled && await this.safeParse("parseInteropBlock"), e4.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
    }
    safeParse(e4) {
      let t5 = this[e4]();
      return void 0 !== t5.catch && (t5 = t5.catch(this.handleError)), t5;
    }
    findIfd0Offset() {
      void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
    }
    findIfd1Offset() {
      if (void 0 === this.ifd1Offset) {
        this.findIfd0Offset();
        let e4 = this.chunk.getUint16(this.ifd0Offset), t5 = this.ifd0Offset + 2 + 12 * e4;
        this.ifd1Offset = this.chunk.getUint32(t5);
      }
    }
    parseBlock(e4, t5) {
      let s4 = /* @__PURE__ */ new Map();
      return this[t5] = s4, this.parseTags(e4, t5, s4), s4;
    }
    async parseIfd0Block() {
      if (this.ifd0) return;
      let { file: e4 } = this;
      this.findIfd0Offset(), this.ifd0Offset < 8 && l2("Malformed EXIF data"), !e4.chunked && this.ifd0Offset > e4.byteLength && l2(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e4.byteLength}`), e4.tiff && await e4.ensureChunk(this.ifd0Offset, o2(this.options));
      let t5 = this.parseBlock(this.ifd0Offset, "ifd0");
      return 0 !== t5.size ? (this.exifOffset = t5.get(34665), this.interopOffset = t5.get(40965), this.gpsOffset = t5.get(34853), this.xmp = t5.get(700), this.iptc = t5.get(33723), this.icc = t5.get(34675), this.options.sanitize && (t5.delete(34665), t5.delete(40965), t5.delete(34853), t5.delete(700), t5.delete(33723), t5.delete(34675)), t5) : void 0;
    }
    async parseExifBlock() {
      if (this.exif) return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset) return;
      this.file.tiff && await this.file.ensureChunk(this.exifOffset, o2(this.options));
      let e4 = this.parseBlock(this.exifOffset, "exif");
      return this.interopOffset || (this.interopOffset = e4.get(40965)), this.makerNote = e4.get(37500), this.userComment = e4.get(37510), this.options.sanitize && (e4.delete(40965), e4.delete(37500), e4.delete(37510)), this.unpack(e4, 41728), this.unpack(e4, 41729), e4;
    }
    unpack(e4, t5) {
      let s4 = e4.get(t5);
      s4 && 1 === s4.length && e4.set(t5, s4[0]);
    }
    async parseGpsBlock() {
      if (this.gps) return;
      if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset) return;
      let e4 = this.parseBlock(this.gpsOffset, "gps");
      return e4 && e4.has(2) && e4.has(4) && (e4.set("latitude", ne(...e4.get(2), e4.get(1))), e4.set("longitude", ne(...e4.get(4), e4.get(3)))), e4;
    }
    async parseInteropBlock() {
      if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, "interop");
    }
    async parseThumbnailBlock(e4 = false) {
      if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e4)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
    }
    async extractThumbnail() {
      if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1) return;
      let e4 = this.ifd1.get(513), t5 = this.ifd1.get(514);
      return this.chunk.getUint8Array(e4, t5);
    }
    get image() {
      return this.ifd0;
    }
    get thumbnail() {
      return this.ifd1;
    }
    createOutput() {
      let e4, t5, s4, i4 = {};
      for (t5 of P2) if (e4 = this[t5], !f2(e4)) if (s4 = this.canTranslate ? this.translateBlock(e4, t5) : Object.fromEntries(e4), this.options.mergeOutput) {
        if ("ifd1" === t5) continue;
        Object.assign(i4, s4);
      } else i4[t5] = s4;
      return this.makerNote && (i4.makerNote = this.makerNote), this.userComment && (i4.userComment = this.userComment), i4;
    }
    assignToOutput(e4, t5) {
      if (this.globalOptions.mergeOutput) Object.assign(e4, t5);
      else for (let [s4, i4] of Object.entries(t5)) this.assignObjectToOutput(e4, s4, i4);
    }
  };
  function ne(e4, t5, s4, i4) {
    var n4 = e4 + t5 / 60 + s4 / 3600;
    return "S" !== i4 && "W" !== i4 || (n4 *= -1), n4;
  }
  e2(ie, "type", "tiff"), e2(ie, "headerLength", 10), y2.set("tiff", ie);
  var re = Object.freeze({ __proto__: null, default: G, Exifr: H2, fileParsers: m2, segmentParsers: y2, fileReaders: b2, tagKeys: B2, tagValues: V, tagRevivers: I2, createDictionary: x2, extendDictionary: C2, fetchUrlAsArrayBuffer: S2, readBlobAsArrayBuffer: A2, chunkedProps: L2, otherSegments: T2, segments: z2, tiffBlocks: P2, segmentsAndBlocks: F2, tiffExtractables: j2, inheritables: E, allFormatters: M2, Options: R, parse: Y });
  var ae = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false };
  var he = Object.assign({}, ae, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
  var le = Object.assign({}, ae, { tiff: false, ifd1: true, mergeOutput: false });
  var de = Object.assign({}, ae, { firstChunkSize: 4e4, ifd0: [274] });
  async function ce(e4) {
    let t5 = new H2(de);
    await t5.read(e4);
    let s4 = await t5.parse();
    if (s4 && s4.ifd0) return s4.ifd0[274];
  }
  var pe = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
  var ge = true;
  var me = true;
  if ("object" == typeof navigator) {
    let e4 = navigator.userAgent;
    if (e4.includes("iPad") || e4.includes("iPhone")) {
      let t5 = e4.match(/OS (\d+)_(\d+)/);
      if (t5) {
        let [, e5, s4] = t5, i4 = Number(e5) + 0.1 * Number(s4);
        ge = i4 < 13.4, me = false;
      }
    } else if (e4.includes("OS X 10")) {
      let [, t5] = e4.match(/OS X 10[_.](\d+)/);
      ge = me = Number(t5) < 15;
    }
    if (e4.includes("Chrome/")) {
      let [, t5] = e4.match(/Chrome\/(\d+)/);
      ge = me = Number(t5) < 81;
    } else if (e4.includes("Firefox/")) {
      let [, t5] = e4.match(/Firefox\/(\d+)/);
      ge = me = Number(t5) < 77;
    }
  }
  async function ye(e4) {
    let t5 = await ce(e4);
    return Object.assign({ canvas: ge, css: me }, pe[t5]);
  }
  var be = class extends c2 {
    constructor(...t5) {
      super(...t5), e2(this, "ranges", new we()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
    }
    _tryExtend(e4, t5, s4) {
      if (0 === e4 && 0 === this.byteLength && s4) {
        let e5 = new DataView(s4.buffer || s4, s4.byteOffset, s4.byteLength);
        this._swapDataView(e5);
      } else {
        let s5 = e4 + t5;
        if (s5 > this.byteLength) {
          let { dataView: e5 } = this._extend(s5);
          this._swapDataView(e5);
        }
      }
    }
    _extend(e4) {
      let t5;
      t5 = a2 ? r2.allocUnsafe(e4) : new Uint8Array(e4);
      let s4 = new DataView(t5.buffer, t5.byteOffset, t5.byteLength);
      return t5.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t5, dataView: s4 };
    }
    subarray(e4, t5, s4 = false) {
      return t5 = t5 || this._lengthToEnd(e4), s4 && this._tryExtend(e4, t5), this.ranges.add(e4, t5), super.subarray(e4, t5);
    }
    set(e4, t5, s4 = false) {
      s4 && this._tryExtend(t5, e4.byteLength, e4);
      let i4 = super.set(e4, t5);
      return this.ranges.add(t5, i4.byteLength), i4;
    }
    async ensureChunk(e4, t5) {
      this.chunked && (this.ranges.available(e4, t5) || await this.readChunk(e4, t5));
    }
    available(e4, t5) {
      return this.ranges.available(e4, t5);
    }
  };
  var we = class {
    constructor() {
      e2(this, "list", []);
    }
    get length() {
      return this.list.length;
    }
    add(e4, t5, s4 = 0) {
      let i4 = e4 + t5, n4 = this.list.filter((t6) => ke(e4, t6.offset, i4) || ke(e4, t6.end, i4));
      if (n4.length > 0) {
        e4 = Math.min(e4, ...n4.map((e5) => e5.offset)), i4 = Math.max(i4, ...n4.map((e5) => e5.end)), t5 = i4 - e4;
        let s5 = n4.shift();
        s5.offset = e4, s5.length = t5, s5.end = i4, this.list = this.list.filter((e5) => !n4.includes(e5));
      } else this.list.push({ offset: e4, length: t5, end: i4 });
    }
    available(e4, t5) {
      let s4 = e4 + t5;
      return this.list.some((t6) => t6.offset <= e4 && s4 <= t6.end);
    }
  };
  function ke(e4, t5, s4) {
    return e4 <= t5 && t5 <= s4;
  }
  var Oe = class extends be {
    constructor(t5, s4) {
      super(0), e2(this, "chunksRead", 0), this.input = t5, this.options = s4;
    }
    async readWhole() {
      this.chunked = false, await this.readChunk(this.nextChunkOffset);
    }
    async readChunked() {
      this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
    }
    async readNextChunk(e4 = this.nextChunkOffset) {
      if (this.fullyRead) return this.chunksRead++, false;
      let t5 = this.options.chunkSize, s4 = await this.readChunk(e4, t5);
      return !!s4 && s4.byteLength === t5;
    }
    async readChunk(e4, t5) {
      if (this.chunksRead++, 0 !== (t5 = this.safeWrapAddress(e4, t5))) return this._readChunk(e4, t5);
    }
    safeWrapAddress(e4, t5) {
      return void 0 !== this.size && e4 + t5 > this.size ? Math.max(0, this.size - e4) : t5;
    }
    get nextChunkOffset() {
      if (0 !== this.ranges.list.length) return this.ranges.list[0].length;
    }
    get canReadNextChunk() {
      return this.chunksRead < this.options.chunkLimit;
    }
    get fullyRead() {
      return void 0 !== this.size && this.nextChunkOffset === this.size;
    }
    read() {
      return this.options.chunked ? this.readChunked() : this.readWhole();
    }
    close() {
    }
  };
  b2.set("blob", class extends Oe {
    async readWhole() {
      this.chunked = false;
      let e4 = await A2(this.input);
      this._swapArrayBuffer(e4);
    }
    readChunked() {
      return this.chunked = true, this.size = this.input.size, super.readChunked();
    }
    async _readChunk(e4, t5) {
      let s4 = t5 ? e4 + t5 : void 0, i4 = this.input.slice(e4, s4), n4 = await A2(i4);
      return this.set(n4, e4, true);
    }
  });

  // ../../node_modules/@uppy/thumbnail-generator/lib/locale.js
  var locale_default5 = {
    strings: {
      generatingThumbnails: "Generating thumbnails..."
    }
  };

  // ../../node_modules/@uppy/thumbnail-generator/lib/index.js
  var packageJson7 = {
    "version": "3.0.2"
  };
  function canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext("2d").getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
      }
    }
    if (canvas.toBlob) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, type, quality);
      }).then((blob) => {
        if (blob === null) {
          throw new Error("cannot read image, probably an svg with external resources");
        }
        return blob;
      });
    }
    return Promise.resolve().then(() => {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then((blob) => {
      if (blob === null) {
        throw new Error("could not extract blob, probably an old browser");
      }
      return blob;
    });
  }
  function rotateImage(image, translate) {
    let w4 = image.width;
    let h4 = image.height;
    if (translate.deg === 90 || translate.deg === 270) {
      w4 = image.height;
      h4 = image.width;
    }
    const canvas = document.createElement("canvas");
    canvas.width = w4;
    canvas.height = h4;
    const context = canvas.getContext("2d");
    context.translate(w4 / 2, h4 / 2);
    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }
    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  function protect(image) {
    const ratio = image.width / image.height;
    const maxSquare = 5e6;
    const maxSize = 4096;
    let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));
    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }
    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }
    if (image.width > maxW) {
      const canvas = document.createElement("canvas");
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext("2d").drawImage(image, 0, 0, maxW, maxH);
      return canvas;
    }
    return image;
  }
  var ThumbnailGenerator = class extends UIPlugin_default {
    constructor(uppy, opts) {
      super(uppy, opts);
      this.onFileAdded = (file) => {
        if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
          this.addToQueue(file.id);
        }
      };
      this.onCancelRequest = (file) => {
        const index = this.queue.indexOf(file.id);
        if (index !== -1) {
          this.queue.splice(index, 1);
        }
      };
      this.onFileRemoved = (file) => {
        const index = this.queue.indexOf(file.id);
        if (index !== -1) {
          this.queue.splice(index, 1);
        }
        if (file.preview && isObjectURL(file.preview)) {
          URL.revokeObjectURL(file.preview);
        }
      };
      this.onRestored = () => {
        const restoredFiles = this.uppy.getFiles().filter((file) => file.isRestored);
        restoredFiles.forEach((file) => {
          if (!file.preview || isObjectURL(file.preview)) {
            this.addToQueue(file.id);
          }
        });
      };
      this.onAllFilesRemoved = () => {
        this.queue = [];
      };
      this.waitUntilAllProcessed = (fileIDs) => {
        fileIDs.forEach((fileID) => {
          const file = this.uppy.getFile(fileID);
          this.uppy.emit("preprocess-progress", file, {
            mode: "indeterminate",
            message: this.i18n("generatingThumbnails")
          });
        });
        const emitPreprocessCompleteForAll = () => {
          fileIDs.forEach((fileID) => {
            const file = this.uppy.getFile(fileID);
            this.uppy.emit("preprocess-complete", file);
          });
        };
        return new Promise((resolve) => {
          if (this.queueProcessing) {
            this.uppy.once("thumbnail:all-generated", () => {
              emitPreprocessCompleteForAll();
              resolve();
            });
          } else {
            emitPreprocessCompleteForAll();
            resolve();
          }
        });
      };
      this.type = "modifier";
      this.id = this.opts.id || "ThumbnailGenerator";
      this.title = "Thumbnail Generator";
      this.queue = [];
      this.queueProcessing = false;
      this.defaultThumbnailDimension = 200;
      this.thumbnailType = this.opts.thumbnailType || "image/jpeg";
      this.defaultLocale = locale_default5;
      const defaultOptions4 = {
        thumbnailWidth: null,
        thumbnailHeight: null,
        waitForThumbnailsBeforeUpload: false,
        lazy: false
      };
      this.opts = {
        ...defaultOptions4,
        ...opts
      };
      this.i18nInit();
      if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) {
        throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
      }
    }
    /**
     * Create a thumbnail for the given Uppy file object.
     *
     * @param {{data: Blob}} file
     * @param {number} targetWidth
     * @param {number} targetHeight
     * @returns {Promise}
     */
    createThumbnail(file, targetWidth, targetHeight) {
      const originalUrl = URL.createObjectURL(file.data);
      const onload = new Promise((resolve, reject) => {
        const image = new Image();
        image.src = originalUrl;
        image.addEventListener("load", () => {
          URL.revokeObjectURL(originalUrl);
          resolve(image);
        });
        image.addEventListener("error", (event) => {
          URL.revokeObjectURL(originalUrl);
          reject(event.error || new Error("Could not create thumbnail"));
        });
      });
      const orientationPromise = ye(file.data).catch(() => 1);
      return Promise.all([onload, orientationPromise]).then((_ref) => {
        let [image, orientation] = _ref;
        const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
        const rotatedImage = rotateImage(image, orientation);
        const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
        return canvasToBlob(resizedImage, this.thumbnailType, 80);
      }).then((blob) => {
        return URL.createObjectURL(blob);
      });
    }
    /**
     * Get the new calculated dimensions for the given image and a target width
     * or height. If both width and height are given, only width is taken into
     * account. If neither width nor height are given, the default dimension
     * is used.
     */
    getProportionalDimensions(img, width, height, rotation) {
      let aspect = img.width / img.height;
      if (rotation === 90 || rotation === 270) {
        aspect = img.height / img.width;
      }
      if (width != null) {
        return {
          width,
          height: Math.round(width / aspect)
        };
      }
      if (height != null) {
        return {
          width: Math.round(height * aspect),
          height
        };
      }
      return {
        width: this.defaultThumbnailDimension,
        height: Math.round(this.defaultThumbnailDimension / aspect)
      };
    }
    /**
     * Resize an image to the target `width` and `height`.
     *
     * Returns a Canvas with the resized image on it.
     */
    // eslint-disable-next-line class-methods-use-this
    resizeImage(image, targetWidth, targetHeight) {
      let img = protect(image);
      let steps = Math.ceil(Math.log2(img.width / targetWidth));
      if (steps < 1) {
        steps = 1;
      }
      let sW = targetWidth * 2 ** (steps - 1);
      let sH = targetHeight * 2 ** (steps - 1);
      const x4 = 2;
      while (steps--) {
        const canvas = document.createElement("canvas");
        canvas.width = sW;
        canvas.height = sH;
        canvas.getContext("2d").drawImage(img, 0, 0, sW, sH);
        img = canvas;
        sW = Math.round(sW / x4);
        sH = Math.round(sH / x4);
      }
      return img;
    }
    /**
     * Set the preview URL for a file.
     */
    setPreviewURL(fileID, preview) {
      this.uppy.setFileState(fileID, {
        preview
      });
    }
    addToQueue(item) {
      this.queue.push(item);
      if (this.queueProcessing === false) {
        this.processQueue();
      }
    }
    processQueue() {
      this.queueProcessing = true;
      if (this.queue.length > 0) {
        const current = this.uppy.getFile(this.queue.shift());
        if (!current) {
          this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error");
          return Promise.resolve();
        }
        return this.requestThumbnail(current).catch(() => {
        }).then(() => this.processQueue());
      }
      this.queueProcessing = false;
      this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue");
      this.uppy.emit("thumbnail:all-generated");
      return Promise.resolve();
    }
    requestThumbnail(file) {
      if (isPreviewSupported(file.type) && !file.isRemote) {
        return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((preview) => {
          this.setPreviewURL(file.id, preview);
          this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
          this.uppy.emit("thumbnail:generated", this.uppy.getFile(file.id), preview);
        }).catch((err) => {
          this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, "warning");
          this.uppy.log(err, "warning");
          this.uppy.emit("thumbnail:error", this.uppy.getFile(file.id), err);
        });
      }
      return Promise.resolve();
    }
    install() {
      this.uppy.on("file-removed", this.onFileRemoved);
      this.uppy.on("cancel-all", this.onAllFilesRemoved);
      if (this.opts.lazy) {
        this.uppy.on("thumbnail:request", this.onFileAdded);
        this.uppy.on("thumbnail:cancel", this.onCancelRequest);
      } else {
        this.uppy.on("file-added", this.onFileAdded);
        this.uppy.on("restored", this.onRestored);
      }
      if (this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.addPreProcessor(this.waitUntilAllProcessed);
      }
    }
    uninstall() {
      this.uppy.off("file-removed", this.onFileRemoved);
      this.uppy.off("cancel-all", this.onAllFilesRemoved);
      if (this.opts.lazy) {
        this.uppy.off("thumbnail:request", this.onFileAdded);
        this.uppy.off("thumbnail:cancel", this.onCancelRequest);
      } else {
        this.uppy.off("file-added", this.onFileAdded);
        this.uppy.off("restored", this.onRestored);
      }
      if (this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.removePreProcessor(this.waitUntilAllProcessed);
      }
    }
  };
  ThumbnailGenerator.VERSION = packageJson7.version;

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js
  var GLOBAL_OBJ = globalThis;

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js
  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/version.js
  var SDK_VERSION = "9.2.0";

  // ../../node_modules/@sentry/core/build/esm/carrier.js
  function getMainCarrier() {
    getSentryCarrier(GLOBAL_OBJ);
    return GLOBAL_OBJ;
  }
  function getSentryCarrier(carrier) {
    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
    return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  }
  function getGlobalSingleton(name, creator, obj = GLOBAL_OBJ) {
    const __SENTRY__ = obj.__SENTRY__ = obj.__SENTRY__ || {};
    const carrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
    return carrier[name] || (carrier[name] = creator());
  }

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/logger.js
  var PREFIX = "Sentry Logger ";
  var CONSOLE_LEVELS = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
  ];
  var originalConsoleMethods = {};
  function consoleSandbox(callback) {
    if (!("console" in GLOBAL_OBJ)) {
      return callback();
    }
    const console2 = GLOBAL_OBJ.console;
    const wrappedFuncs = {};
    const wrappedLevels = Object.keys(originalConsoleMethods);
    wrappedLevels.forEach((level) => {
      const originalConsoleMethod = originalConsoleMethods[level];
      wrappedFuncs[level] = console2[level];
      console2[level] = originalConsoleMethod;
    });
    try {
      return callback();
    } finally {
      wrappedLevels.forEach((level) => {
        console2[level] = wrappedFuncs[level];
      });
    }
  }
  function makeLogger() {
    let enabled = false;
    const logger2 = {
      enable: () => {
        enabled = true;
      },
      disable: () => {
        enabled = false;
      },
      isEnabled: () => enabled
    };
    if (DEBUG_BUILD) {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = (...args) => {
          if (enabled) {
            consoleSandbox(() => {
              GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = () => void 0;
      });
    }
    return logger2;
  }
  var logger = getGlobalSingleton("logger", makeLogger);

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/is.js
  var objectToString = Object.prototype.toString;
  function isBuiltin(wat, className) {
    return objectToString.call(wat) === `[object ${className}]`;
  }
  function isPlainObject(wat) {
    return isBuiltin(wat, "Object");
  }
  function isThenable(wat) {
    return Boolean(wat?.then && typeof wat.then === "function");
  }

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/object.js
  function addNonEnumerableProperty(obj, name, value) {
    try {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value,
        writable: true,
        configurable: true
      });
    } catch (o_O) {
      DEBUG_BUILD && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
    }
  }

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/time.js
  var ONE_SECOND_IN_MS = 1e3;
  function dateTimestampInSeconds() {
    return Date.now() / ONE_SECOND_IN_MS;
  }
  function createUnixTimestampInSecondsFunc() {
    const { performance: performance2 } = GLOBAL_OBJ;
    if (!performance2?.now) {
      return dateTimestampInSeconds;
    }
    const approxStartingTimeOrigin = Date.now() - performance2.now();
    const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
    return () => {
      return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
    };
  }
  var timestampInSeconds = createUnixTimestampInSecondsFunc();

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/misc.js
  function uuid4() {
    const gbl = GLOBAL_OBJ;
    const crypto = gbl.crypto || gbl.msCrypto;
    let getRandomByte = () => Math.random() * 16;
    try {
      if (crypto?.randomUUID) {
        return crypto.randomUUID().replace(/-/g, "");
      }
      if (crypto?.getRandomValues) {
        getRandomByte = () => {
          const typedArray = new Uint8Array(1);
          crypto.getRandomValues(typedArray);
          return typedArray[0];
        };
      }
    } catch (_4) {
    }
    return ("10000000100040008000" + 1e11).replace(
      /[018]/g,
      (c4) => (
        // eslint-disable-next-line no-bitwise
        (c4 ^ (getRandomByte() & 15) >> c4 / 4).toString(16)
      )
    );
  }

  // ../../node_modules/@sentry/core/build/esm/session.js
  function updateSession(session2, context = {}) {
    if (context.user) {
      if (!session2.ipAddress && context.user.ip_address) {
        session2.ipAddress = context.user.ip_address;
      }
      if (!session2.did && !context.did) {
        session2.did = context.user.id || context.user.email || context.user.username;
      }
    }
    session2.timestamp = context.timestamp || timestampInSeconds();
    if (context.abnormal_mechanism) {
      session2.abnormal_mechanism = context.abnormal_mechanism;
    }
    if (context.ignoreDuration) {
      session2.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      session2.sid = context.sid.length === 32 ? context.sid : uuid4();
    }
    if (context.init !== void 0) {
      session2.init = context.init;
    }
    if (!session2.did && context.did) {
      session2.did = `${context.did}`;
    }
    if (typeof context.started === "number") {
      session2.started = context.started;
    }
    if (session2.ignoreDuration) {
      session2.duration = void 0;
    } else if (typeof context.duration === "number") {
      session2.duration = context.duration;
    } else {
      const duration = session2.timestamp - session2.started;
      session2.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      session2.release = context.release;
    }
    if (context.environment) {
      session2.environment = context.environment;
    }
    if (!session2.ipAddress && context.ipAddress) {
      session2.ipAddress = context.ipAddress;
    }
    if (!session2.userAgent && context.userAgent) {
      session2.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      session2.errors = context.errors;
    }
    if (context.status) {
      session2.status = context.status;
    }
  }

  // ../../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js
  function generateTraceId() {
    return uuid4();
  }

  // ../../node_modules/@sentry/core/build/esm/utils/merge.js
  function merge(initialObj, mergeObj, levels = 2) {
    if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
      return mergeObj;
    }
    if (initialObj && Object.keys(mergeObj).length === 0) {
      return initialObj;
    }
    const output = { ...initialObj };
    for (const key in mergeObj) {
      if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
        output[key] = merge(output[key], mergeObj[key], levels - 1);
      }
    }
    return output;
  }

  // ../../node_modules/@sentry/core/build/esm/utils/spanOnScope.js
  var SCOPE_SPAN_FIELD = "_sentrySpan";
  function _setSpanForScope(scope, span) {
    if (span) {
      addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
    } else {
      delete scope[SCOPE_SPAN_FIELD];
    }
  }
  function _getSpanForScope(scope) {
    return scope[SCOPE_SPAN_FIELD];
  }

  // ../../node_modules/@sentry/core/build/esm/scope.js
  var DEFAULT_MAX_BREADCRUMBS = 100;
  var Scope2 = class _Scope {
    /** Flag if notifying is happening. */
    /** Callback for client to receive scope changes. */
    /** Callback list that will be called during event processing. */
    /** Array of breadcrumbs. */
    /** User */
    /** Tags */
    /** Extra */
    /** Contexts */
    /** Attachments */
    /** Propagation Context for distributed tracing */
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    /** Fingerprint */
    /** Severity */
    /**
     * Transaction Name
     *
     * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
     * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
     */
    /** Session */
    /** The client on this scope */
    /** Contains the last event id of a captured event.  */
    // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
    constructor() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._attachments = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
      this._propagationContext = {
        traceId: generateTraceId(),
        sampleRand: Math.random()
      };
    }
    /**
     * Clone all data from this scope into a new scope.
     */
    clone() {
      const newScope = new _Scope();
      newScope._breadcrumbs = [...this._breadcrumbs];
      newScope._tags = { ...this._tags };
      newScope._extra = { ...this._extra };
      newScope._contexts = { ...this._contexts };
      if (this._contexts.flags) {
        newScope._contexts.flags = {
          values: [...this._contexts.flags.values]
        };
      }
      newScope._user = this._user;
      newScope._level = this._level;
      newScope._session = this._session;
      newScope._transactionName = this._transactionName;
      newScope._fingerprint = this._fingerprint;
      newScope._eventProcessors = [...this._eventProcessors];
      newScope._attachments = [...this._attachments];
      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
      newScope._propagationContext = { ...this._propagationContext };
      newScope._client = this._client;
      newScope._lastEventId = this._lastEventId;
      _setSpanForScope(newScope, _getSpanForScope(this));
      return newScope;
    }
    /**
     * Update the client assigned to this scope.
     * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,
     * as well as manually created scopes.
     */
    setClient(client) {
      this._client = client;
    }
    /**
     * Set the ID of the last captured error event.
     * This is generally only captured on the isolation scope.
     */
    setLastEventId(lastEventId2) {
      this._lastEventId = lastEventId2;
    }
    /**
     * Get the client assigned to this scope.
     */
    getClient() {
      return this._client;
    }
    /**
     * Get the ID of the last captured error event.
     * This is generally only available on the isolation scope.
     */
    lastEventId() {
      return this._lastEventId;
    }
    /**
     * @inheritDoc
     */
    addScopeListener(callback) {
      this._scopeListeners.push(callback);
    }
    /**
     * Add an event processor that will be called before an event is sent.
     */
    addEventProcessor(callback) {
      this._eventProcessors.push(callback);
      return this;
    }
    /**
     * Set the user for this scope.
     * Set to `null` to unset the user.
     */
    setUser(user) {
      this._user = user || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        username: void 0
      };
      if (this._session) {
        updateSession(this._session, { user });
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Get the user from this scope.
     */
    getUser() {
      return this._user;
    }
    /**
     * Set an object that will be merged into existing tags on the scope,
     * and will be sent as tags data with the event.
     */
    setTags(tags) {
      this._tags = {
        ...this._tags,
        ...tags
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Set a single tag that will be sent as tags data with the event.
     */
    setTag(key, value) {
      this._tags = { ...this._tags, [key]: value };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Set an object that will be merged into existing extra on the scope,
     * and will be sent as extra data with the event.
     */
    setExtras(extras) {
      this._extra = {
        ...this._extra,
        ...extras
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Set a single key:value extra entry that will be sent as extra data with the event.
     */
    setExtra(key, extra) {
      this._extra = { ...this._extra, [key]: extra };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the fingerprint on the scope to send with the events.
     * @param {string[]} fingerprint Fingerprint to group events in Sentry.
     */
    setFingerprint(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the level on the scope for future events.
     */
    setLevel(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the transaction name on the scope so that the name of e.g. taken server route or
     * the page location is attached to future events.
     *
     * IMPORTANT: Calling this function does NOT change the name of the currently active
     * root span. If you want to change the name of the active root span, use
     * `Sentry.updateSpanName(rootSpan, 'new name')` instead.
     *
     * By default, the SDK updates the scope's transaction name automatically on sensible
     * occasions, such as a page navigation or when handling a new request on the server.
     */
    setTransactionName(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets context data with the given name.
     * Data passed as context will be normalized. You can also pass `null` to unset the context.
     * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.
     */
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Set the session for the scope.
     */
    setSession(session2) {
      if (!session2) {
        delete this._session;
      } else {
        this._session = session2;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Get the session from the scope.
     */
    getSession() {
      return this._session;
    }
    /**
     * Updates the scope with provided data. Can work in three variations:
     * - plain object containing updatable attributes
     * - Scope instance that'll extract the attributes from
     * - callback function that'll receive the current scope as an argument and allow for modifications
     */
    update(captureContext) {
      if (!captureContext) {
        return this;
      }
      const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
      const scopeInstance = scopeToMerge instanceof _Scope ? scopeToMerge.getScopeData() : isPlainObject(scopeToMerge) ? captureContext : void 0;
      const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
      this._tags = { ...this._tags, ...tags };
      this._extra = { ...this._extra, ...extra };
      this._contexts = { ...this._contexts, ...contexts };
      if (user && Object.keys(user).length) {
        this._user = user;
      }
      if (level) {
        this._level = level;
      }
      if (fingerprint.length) {
        this._fingerprint = fingerprint;
      }
      if (propagationContext) {
        this._propagationContext = propagationContext;
      }
      return this;
    }
    /**
     * Clears the current scope and resets its properties.
     * Note: The client will not be cleared.
     */
    clear() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._session = void 0;
      _setSpanForScope(this, void 0);
      this._attachments = [];
      this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Adds a breadcrumb to the scope.
     * By default, the last 100 breadcrumbs are kept.
     */
    addBreadcrumb(breadcrumb, maxBreadcrumbs) {
      const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      const mergedBreadcrumb = {
        timestamp: dateTimestampInSeconds(),
        ...breadcrumb
      };
      this._breadcrumbs.push(mergedBreadcrumb);
      if (this._breadcrumbs.length > maxCrumbs) {
        this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
        this._client?.recordDroppedEvent("buffer_overflow", "log_item");
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Get the last breadcrumb of the scope.
     */
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    /**
     * Clear all breadcrumbs from the scope.
     */
    clearBreadcrumbs() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Add an attachment to the scope.
     */
    addAttachment(attachment) {
      this._attachments.push(attachment);
      return this;
    }
    /**
     * Clear all attachments from the scope.
     */
    clearAttachments() {
      this._attachments = [];
      return this;
    }
    /**
     * Get the data of this scope, which should be applied to an event during processing.
     */
    getScopeData() {
      return {
        breadcrumbs: this._breadcrumbs,
        attachments: this._attachments,
        contexts: this._contexts,
        tags: this._tags,
        extra: this._extra,
        user: this._user,
        level: this._level,
        fingerprint: this._fingerprint || [],
        eventProcessors: this._eventProcessors,
        propagationContext: this._propagationContext,
        sdkProcessingMetadata: this._sdkProcessingMetadata,
        transactionName: this._transactionName,
        span: _getSpanForScope(this)
      };
    }
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry.
     */
    setSDKProcessingMetadata(newData) {
      this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
      return this;
    }
    /**
     * Add propagation context to the scope, used for distributed tracing
     */
    setPropagationContext(context) {
      this._propagationContext = context;
      return this;
    }
    /**
     * Get propagation context from the scope, used for distributed tracing
     */
    getPropagationContext() {
      return this._propagationContext;
    }
    /**
     * Capture an exception for this scope.
     *
     * @returns {string} The id of the captured Sentry event.
     */
    captureException(exception, hint) {
      const eventId = hint?.event_id || uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture exception!");
        return eventId;
      }
      const syntheticException = new Error("Sentry syntheticException");
      this._client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Capture a message for this scope.
     *
     * @returns {string} The id of the captured message.
     */
    captureMessage(message, level, hint) {
      const eventId = hint?.event_id || uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture message!");
        return eventId;
      }
      const syntheticException = new Error(message);
      this._client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Capture a Sentry event for this scope.
     *
     * @returns {string} The id of the captured event.
     */
    captureEvent(event, hint) {
      const eventId = hint?.event_id || uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture event!");
        return eventId;
      }
      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
      return eventId;
    }
    /**
     * This will be called on every set call.
     */
    _notifyScopeListeners() {
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach((callback) => {
          callback(this);
        });
        this._notifyingListeners = false;
      }
    }
  };

  // ../../node_modules/@sentry/core/build/esm/defaultScopes.js
  function getDefaultCurrentScope() {
    return getGlobalSingleton("defaultCurrentScope", () => new Scope2());
  }
  function getDefaultIsolationScope() {
    return getGlobalSingleton("defaultIsolationScope", () => new Scope2());
  }

  // ../../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
  var AsyncContextStack = class {
    constructor(scope, isolationScope) {
      let assignedScope;
      if (!scope) {
        assignedScope = new Scope2();
      } else {
        assignedScope = scope;
      }
      let assignedIsolationScope;
      if (!isolationScope) {
        assignedIsolationScope = new Scope2();
      } else {
        assignedIsolationScope = isolationScope;
      }
      this._stack = [{ scope: assignedScope }];
      this._isolationScope = assignedIsolationScope;
    }
    /**
     * Fork a scope for the stack.
     */
    withScope(callback) {
      const scope = this._pushScope();
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(scope);
      } catch (e4) {
        this._popScope();
        throw e4;
      }
      if (isThenable(maybePromiseResult)) {
        return maybePromiseResult.then(
          (res) => {
            this._popScope();
            return res;
          },
          (e4) => {
            this._popScope();
            throw e4;
          }
        );
      }
      this._popScope();
      return maybePromiseResult;
    }
    /**
     * Get the client of the stack.
     */
    getClient() {
      return this.getStackTop().client;
    }
    /**
     * Returns the scope of the top stack.
     */
    getScope() {
      return this.getStackTop().scope;
    }
    /**
     * Get the isolation scope for the stack.
     */
    getIsolationScope() {
      return this._isolationScope;
    }
    /**
     * Returns the topmost scope layer in the order domain > local > process.
     */
    getStackTop() {
      return this._stack[this._stack.length - 1];
    }
    /**
     * Push a scope to the stack.
     */
    _pushScope() {
      const scope = this.getScope().clone();
      this._stack.push({
        client: this.getClient(),
        scope
      });
      return scope;
    }
    /**
     * Pop a scope from the stack.
     */
    _popScope() {
      if (this._stack.length <= 1) return false;
      return !!this._stack.pop();
    }
  };
  function getAsyncContextStack() {
    const registry = getMainCarrier();
    const sentry = getSentryCarrier(registry);
    return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
  }
  function withScope(callback) {
    return getAsyncContextStack().withScope(callback);
  }
  function withSetScope(scope, callback) {
    const stack = getAsyncContextStack();
    return stack.withScope(() => {
      stack.getStackTop().scope = scope;
      return callback(scope);
    });
  }
  function withIsolationScope(callback) {
    return getAsyncContextStack().withScope(() => {
      return callback(getAsyncContextStack().getIsolationScope());
    });
  }
  function getStackAsyncContextStrategy() {
    return {
      withIsolationScope,
      withScope,
      withSetScope,
      withSetIsolationScope: (_isolationScope, callback) => {
        return withIsolationScope(callback);
      },
      getCurrentScope: () => getAsyncContextStack().getScope(),
      getIsolationScope: () => getAsyncContextStack().getIsolationScope()
    };
  }

  // ../../node_modules/@sentry/core/build/esm/asyncContext/index.js
  function getAsyncContextStrategy(carrier) {
    const sentry = getSentryCarrier(carrier);
    if (sentry.acs) {
      return sentry.acs;
    }
    return getStackAsyncContextStrategy();
  }

  // ../../node_modules/@sentry/core/build/esm/currentScopes.js
  function getCurrentScope() {
    const carrier = getMainCarrier();
    const acs = getAsyncContextStrategy(carrier);
    return acs.getCurrentScope();
  }

  // ../../node_modules/@sentry/core/build/esm/exports.js
  function captureMessage(message, captureContext) {
    const level = typeof captureContext === "string" ? captureContext : void 0;
    const context = typeof captureContext !== "string" ? { captureContext } : void 0;
    return getCurrentScope().captureMessage(message, level, context);
  }

  // controllers/multi_upload_controller.js
  var multi_upload_controller_default = class extends Controller {
    static targets = ["cocoonAddFields", "uppyInput", "progressContainer", "progressBar"];
    static values = {
      inputName: String,
      presignEndpoint: String,
      permittedFileTypes: Array,
      buttonHint: { type: String, default: "Upload a File" },
      buttonIcon: { type: String, default: "" },
      maxFilesCount: { type: Number, default: 0 },
      maxFileSize: { type: Number, default: 5e7 },
      autosave: { type: Boolean, default: false },
      uploading: { type: Boolean, default: false }
    };
    connect() {
      let form = this.element.closest("form");
      let presignEndpoint = this.presignEndpointValue;
      let cocoon_count = 0;
      let upload_count = 0;
      this.uppyInputTarget.innerHTML = "";
      this.uppy = new Uppy_default({
        autoProceed: true,
        infoTimeout: 604800,
        // length of time to show the informer error for (1 week)
        restrictions: {
          maxFileSize: this.maxFileSizeValue,
          allowedFileTypes: this.permittedFileTypesValue.length == 0 ? null : this.permittedFileTypesValue,
          maxNumberOfFiles: this.maxFilesCountValue
        }
      }).use(DragDrop, {
        inputName: this.inputNameValue,
        target: this.uppyInputTarget,
        note: this.buttonHintValue,
        onDragOver: (event) => {
          this.uppyInputTarget.classList.add("uppy-input--onDragOver");
        },
        onDragLeave: (event) => {
          this.uppyInputTarget.classList.remove("uppy-input--onDragOver");
        },
        onDrop: (event) => {
          this.uppyInputTarget.classList.remove("uppy-input--onDragOver");
        },
        locale: {
          strings: {
            dropHereOr: "Multi-upload files by clicking, or drag & drop"
          }
        }
      }).use(Informer, {
        target: ".uppy-Informer-errors"
      }).use(AwsS3, {
        companionUrl: "/",
        limit: 5,
        // default: 5
        timeout: 45 * 1e3,
        // default: 30000
        getUploadParameters(file) {
          return fetch(`${presignEndpoint}?filename=${file.name}&type=${file.type}`, {
            method: "get",
            headers: {
              accept: "application/json",
              "content-type": "application/json"
            }
          }).then((response) => {
            return response.json();
          }).then((data) => {
            return {
              method: data.method,
              url: data.url,
              fields: data.fields
            };
          }).catch((err) => {
            captureMessage("Multi-Upload JS Controller Failed to Complete AWS Request", { extra: { err, params: file } });
          });
        }
      }).use(Compressor, {
        quality: 0.6,
        // default: 0.6
        limit: 10
        // default: 10
      }).use(ThumbnailGenerator, {
        thumbnailWidth: 300,
        thumbnailHeight: 300
      }).on("file-added", (file) => {
        $(document).on("cocoon:before-insert", (event, added_fields) => {
          $(document).off("cocoon:before-insert");
          file.currentTarget = added_fields[0];
          file.currentTarget.querySelector(".nested-field__name").innerText = file.name;
          if (file.currentTarget.classList.contains("cocoon-watch")) {
            cocoon_count++;
            let cocoonIdField = file.currentTarget.querySelector("#cocoon_id");
            if (cocoonIdField != null) {
              file.currentTarget.id = file.currentTarget.id + "_" + cocoon_count;
              cocoonIdField.value = file.currentTarget.id;
            }
          }
        });
        $(document).on("cocoon:after-insert", (event, added_fields) => {
          $(document).off("cocoon:after-insert");
        });
        this.cocoonAddFieldsTarget.click();
      }).on("upload-progress", (file, progress) => {
        let current_progress = Math.round(progress.bytesUploaded / progress.bytesTotal * 100);
        let progress_text = file.currentTarget.querySelector(".progress-text");
        if (progress_text != null) {
          progress_text.innerText = current_progress.toString() + "%";
        }
      }).on("upload", (data) => {
        this.progressContainerTarget.classList.remove("display--none");
        upload_count++;
        this.uploadingValue = true;
        if (this.autosaveValue != true) {
          form.querySelectorAll('input[type="submit"], button[type="submit"]').forEach((submit) => {
            submit.disabled = true;
          });
        }
      }).on("progress", (progress) => {
        this.progressBarTarget.style.width = progress.toString() + "%";
      }).on("upload-success", (file) => {
        let uploadedFileData = JSON.stringify({
          id: file.meta["key"].match(/^cache\/(.+)/)[1],
          // object key without prefix
          storage: "cache",
          metadata: {
            size: file.size,
            filename: file.name,
            mime_type: file.type
          }
        });
        let file_input = file.currentTarget.querySelector('input[data-name="file"]');
        if (file_input) file_input.value = uploadedFileData;
        let progressTracker = file.currentTarget.querySelector(".existing-file__progress");
        if (progressTracker) progressTracker.classList.add("display--none");
        if (this.autosaveValue == true) file.currentTarget.querySelector(".nested-field__autosave").click();
      }).on("thumbnail:generated", (file, preview) => {
        let blobField = file.currentTarget.querySelector(".blob");
        if (blobField) {
          file.currentTarget.querySelector(".existing-file__preview").style.backgroundImage = `url("${preview}")`;
          blobField.value = preview;
        }
      }).on("complete", () => {
        this.progressContainerTarget.classList.add("display--none");
        upload_count--;
        this.uploadingValue = false;
        if (form && form.querySelectorAll('div[data-controller="upload"][data-upload-uploading-value="true"]').length === 0 && upload_count == 0) {
          form.querySelectorAll('input[type="submit"], button[type="submit"]').forEach((submit) => {
            submit.disabled = false;
          });
        }
      }).on("error", (error2) => {
        captureMessage("Multi-Upload JS Controller Error", { extra: { error: error2 } });
      }).on("upload-error", (file, error2, response) => {
        captureMessage("Multi-Upload JS Controller Upload Error", { extra: { file, error: error2, response } });
      });
      if (this.buttonIconValue.length > 0) {
        this.uppyInputTarget.querySelector(".uppy-DragDrop-label").insertAdjacentHTML("beforebegin", `${this.buttonIconValue}`);
      }
      $(document).on("cocoon:before-remove", (event, removed_field) => {
        if (this.element.contains(removed_field[0])) {
          let removed_filename = removed_field[0].querySelector(".nested-field__name").innerText;
          Object.values(this.uppy.store.state.files).forEach((file) => {
            if (file.name == removed_filename) {
              this.uppy.removeFile(file.id);
            }
          });
        }
      });
    }
    disconnect() {
      this.uppy.close();
    }
  };

  // controllers/scroll_controller.js
  var scroll_controller_exports = {};
  __export(scroll_controller_exports, {
    default: () => scroll_controller_default
  });
  var scroll_controller_default = class extends Controller {
    static targets = ["scrollEnd", "smoothScrollEnd"];
    scrollEndTargetConnected(target) {
      target.scrollIntoView();
    }
    smoothScrollEndTargetConnected(target) {
      target.scrollIntoView({
        behavior: "smooth"
      });
    }
  };

  // controllers/select2_controller.js
  var select2_controller_exports = {};
  __export(select2_controller_exports, {
    default: () => select2_controller_default
  });
  require_select2()();
  var select2_controller_default = class extends Controller {
    static targets = ["single", "multi"];
    singleTargetConnected(target) {
      $(target).select2({
        theme: "flat",
        placeholder: "Type to search...",
        width: "100%",
        allowClear: true
      }).on("select2:open", () => {
        $(".select2-container--open .select2-search__field").last().get(0).focus();
      });
    }
    singleTargetDisconnected(target) {
      $(target).select2("destroy");
    }
    multiTargetConnected(target) {
      $(target).select2({
        theme: "flat",
        placeholder: "Type to search...",
        width: "100%",
        dropdownCssClass: "select2--dynamic"
      });
    }
    multiTargetDisconnected(target) {
      $(target).select2("destroy");
    }
  };

  // controllers/show_hide_controller.js
  var show_hide_controller_exports = {};
  __export(show_hide_controller_exports, {
    default: () => show_hide_controller_default
  });
  var show_hide_controller_default = class extends Controller {
    static targets = ["replaceable", "toggleable", "boolean", "booleanable", "radio", "radioable", "option", "optionable", "classable", "timed"];
    connect() {
      if (this.hasToggleTarget) {
        this.toggleObjects();
      }
      if (this.hasBooleanTarget) {
        this.toggleByBoolean();
      }
      if (this.hasRadioTarget) {
        this.toggleByRadio();
      }
      if (this.hasOptionTarget) {
        this.toggleByOption();
      }
      if (this.hasTimedTarget) {
        this.toggleWithTimer();
      }
    }
    // hides the actionable and shows another target to "take it's place"
    replaceObject(event) {
      let parentId = event.currentTarget.dataset.parentId;
      event.currentTarget.classList.add("display--none");
      this.replaceableTargets.filter((t5) => t5.dataset.childId === parentId).forEach((object) => {
        object.classList.remove("display--none");
      });
    }
    // hides and shows targets when an actionable target is clicked
    // this can be used with multiple toggleable objects in a html controller by specifying data-toggle-id and data-toggleable-id
    toggleObjects(event) {
      let parentId = event.currentTarget.dataset.parentId;
      if (parentId !== void 0) {
        this.toggleableTargets.filter((t5) => t5.dataset.childId === parentId).forEach((object) => {
          object.classList.toggle("display--none");
        });
      } else {
        this.toggleableTargets.forEach((object) => {
          object.classList.toggle("display--none");
        });
      }
    }
    // hides and shows targets when a boolean target is (un)checked
    toggleByBoolean() {
      let parentId = this.booleanTarget.dataset.parentId;
      if (parentId !== void 0) {
        let targets = this.booleanableTargets.filter((t5) => t5.dataset.childId === parentId);
        if (this.booleanTarget.checked) {
          targets.forEach((object) => {
            object.classList.remove("display--none");
          });
        } else {
          targets.forEach((object) => {
            object.classList.add("display--none");
          });
        }
      } else {
        if (this.booleanTarget.checked) {
          this.booleanableTargets.forEach((object) => {
            object.classList.remove("display--none");
          });
        } else {
          this.booleanableTargets.forEach((object) => {
            object.classList.add("display--none");
          });
        }
      }
    }
    // hides and shows targets when a radio's options is (un)checked
    toggleByRadio() {
      let selectedRadio = this.radioTarget.querySelector('input[type="radio"]:checked');
      if (selectedRadio !== null) {
        this.radioableTargets.forEach((element) => {
          let optionsArray = element.dataset.options.split(",");
          if (optionsArray.includes(selectedRadio.value)) {
            element.classList.remove("display--none");
          } else {
            element.classList.add("display--none");
          }
        });
      }
    }
    // hides and shows targets when a select's options is (un)selected
    toggleByOption() {
      let selected = this.optionTarget.selectedOptions[0].value;
      this.optionableTargets.forEach((object) => {
        let optionsArray = object.dataset.options.split(",");
        if (optionsArray.includes(selected)) {
          object.classList.remove("display--none");
        } else {
          object.classList.add("display--none");
        }
      });
    }
    // add and remove a class to classable targets which can then affect them and their children
    toggleWithClass(event) {
      let toggleClass = event.currentTarget.dataset.class;
      let parentId = event.currentTarget.dataset.parentId;
      if (parentId !== void 0) {
        this.classableTargets.filter((t5) => t5.dataset.childId === parentId).forEach((object) => {
          object.classList.toggle(`${toggleClass}`);
        });
      } else {
        this.classableTargets.forEach((object) => {
          object.classList.toggle(`${toggleClass}`);
        });
      }
    }
    // remove the switching class from all targets, then apply it to the originally clicked target
    // commonly used for tab clicking to remove the active link from any tabs and place it on the clicked tab
    switchClass(event) {
      let switchClass = event.currentTarget.dataset.class;
      let switchId = event.currentTarget.dataset.switchId;
      this.classableTargets.filter((t5) => t5.dataset.switchId === switchId).forEach((object) => {
        object.classList.remove(switchClass);
      });
      event.currentTarget.classList.add(switchClass);
    }
    toggleWithTimer() {
      this.timedTargets.forEach((object) => {
        setTimeout(() => {
          object.classList.toggle("display--none");
        }, object.dataset.timeout || 1e4);
      });
    }
  };

  // controllers/single_upload_controller.js
  var single_upload_controller_exports = {};
  __export(single_upload_controller_exports, {
    default: () => single_upload_controller_default
  });
  var single_upload_controller_default = class extends Controller {
    static targets = [
      "previewContainer",
      "preview",
      "inputContainer",
      "uppyInput",
      "formInput",
      // actual form field that gets submitted
      "progressContainer",
      "progressBar",
      "fileName",
      "errorContainer",
      "errorInformer",
      "successHint"
    ];
    static values = {
      inputName: String,
      presignEndpoint: String,
      permittedFileTypes: Array,
      buttonHint: { type: String, default: "Upload a File" },
      buttonIcon: { type: String, default: "" },
      maxFileSize: { type: Number, default: 5e7 },
      uploading: { type: Boolean, default: false }
    };
    connect() {
      let form = this.element.closest("form");
      let presignEndpoint = this.presignEndpointValue;
      let upload_count = 0;
      this.uppyInputTarget.innerHTML = "";
      this.uppy = new Uppy_default({
        autoProceed: true,
        infoTimeout: 604800,
        // length of time to show the informer error for (1 week)
        restrictions: {
          maxFileSize: this.maxFileSizeValue,
          allowedFileTypes: this.permittedFileTypesValue.length == 0 ? null : this.permittedFileTypesValue,
          maxNumberOfFiles: 1
        }
      }).use(DragDrop, {
        inputName: this.inputNameValue,
        target: this.uppyInputTarget,
        note: this.buttonHintValue,
        onDragOver: (event) => {
          this.uppyInputTarget.classList.add("uppy-input--onDragOver");
        },
        onDragLeave: (event) => {
          this.uppyInputTarget.classList.remove("uppy-input--onDragOver");
        },
        onDrop: (event) => {
          this.uppyInputTarget.classList.remove("uppy-input--onDragOver");
        },
        locale: {
          strings: {
            dropHereOr: "Upload a file by clicking, or drag & drop"
          }
        }
      }).use(Informer, {
        target: ".uppy-Informer-errors"
      }).use(AwsS3, {
        companionUrl: "/",
        limit: 5,
        // default: 5
        timeout: 45 * 1e3,
        // default: 30000
        getUploadParameters(file) {
          return fetch(`${presignEndpoint}?filename=${file.name}&type=${file.type}`, {
            method: "get",
            headers: {
              accept: "application/json",
              "content-type": "application/json"
            }
          }).then((response) => {
            return response.json();
          }).then((data) => {
            return {
              method: data.method,
              url: data.url,
              fields: data.fields
            };
          }).catch((err) => {
            captureMessage("Single-Upload JS Controller Failed to Complete AWS Request", { extra: { err, params: file } });
          });
        }
      }).use(Compressor, {
        quality: 0.6,
        // default: 0.6
        limit: 10
        // default: 10
      }).use(ThumbnailGenerator, {
        thumbnailWidth: 300,
        thumbnailHeight: 300,
        thumbnailType: "image/jpeg",
        waitForThumbnailsBeforeUpload: false
      }).on("thumbnail:generated", (file, preview) => {
        this.previewTarget.style.backgroundImage = `url("${preview}")`;
      }).on("file-added", (file) => {
        this.uploadingValue = true;
        form.querySelectorAll('input[type="submit"], button[type="submit"]').forEach((submit) => {
          submit.disabled = true;
        });
        this.previewTarget.style.backgroundImage = null;
        this.fileNameTargets[0].innerText = file.name;
        this.fileNameTargets[1].innerText = file.name;
      }).on("upload", (data) => {
        this.progressContainerTarget.classList.remove("display--none");
      }).on("progress", (progress) => {
        this.progressBarTarget.style.width = progress.toString() + "%";
      }).on("upload-success", (file) => {
        let uploadedFileData = JSON.stringify({
          id: file.meta["key"].match(/^cache\/(.+)/)[1],
          // object key without prefix
          storage: "cache",
          metadata: {
            size: file.size,
            filename: file.name,
            mime_type: file.type
          }
        });
        if (!["image/jpeg", "image/png", "image/gif"].includes(file.type)) {
          this.previewTarget.innerHTML = this.file_icon(file.type);
        }
        this.formInputTarget.value = uploadedFileData;
        this.previewContainerTarget.classList.remove("display--none");
        this.inputContainerTarget.classList.add("display--none");
        this.uploadingValue = false;
        if (form.querySelectorAll('div[data-controller="single-upload"][data-upload-uploading-value="true"]').length === 0) {
          form.querySelectorAll('input[type="submit"], button[type="submit"]').forEach((submit) => {
            submit.disabled = false;
          });
        }
        this.errorContainerTarget.classList.add("display--none");
        this.successHintTarget.classList.remove("display--none");
        this.element.classList.remove("field--errors");
      }).on("upload-error", (file, error2, response) => {
        this.uploadingValue = false;
        if (form.querySelectorAll('div[data-controller="single-upload"][data-upload-uploading-value="true"]').length === 0) {
          form.querySelectorAll('input[type="submit"], button[type="submit"]').forEach((submit) => {
            submit.disabled = false;
          });
        }
        this.errorContainerTarget.classList.remove("display--none");
        captureMessage("Upload JS Controller Upload Error", { extra: { file, error: error2, response } });
        this.uppy.removeFile(file.id);
      });
      if (this.buttonIconValue.length > 0) {
        this.uppyInputTarget.querySelector(".uppy-DragDrop-label").insertAdjacentHTML("beforebegin", `${this.buttonIconValue}`);
      }
      $(document).on("cocoon:before-remove", (event, removed_field) => {
        if (this.element.contains(removed_field[0])) {
          let removed_filename = removed_field[0].querySelector(".nested-field__name").innerText;
          Object.values(this.uppy.store.state.files).forEach((file) => {
            if (file.name == removed_filename) {
              this.uppy.removeFile(file.id);
            }
          });
        }
      });
    }
    file_icon(file_type) {
      let preview = '<div class="h--100pc display--flex justify-content--center align-items--center">';
      switch (file_type) {
        case "application/msword":
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
          preview += '<i class="fa-regular fa-2x fa-file-word"></i>';
          break;
        case "application/vnd.ms-excel":
        case "application/xls":
        case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
          preview += '<i class="fa-regular fa-2x fa-file-excel"></i>';
          break;
        case "application/pdf":
          preview += '<i class="fa-regular fa-2x fa-file-pdf"></i>';
          break;
        case "application/vnd.ms-powerpoint":
        case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
          preview += '<i class="fa-regular fa-2x fa-file-powerpoint"></i>';
          break;
        case "text/csv":
          preview += '<i class="fa-regular fa-2x fa-file-csv"></i>';
          break;
        case "application/octet-stream":
          preview += '<i class="fa-regular fa-2x fa-cube"></i>';
          break;
        default:
          preview += '<i class="fa-regular fa-2x fa-file"></i>';
          break;
      }
      return preview += "</div>";
    }
    disconnect() {
      this.uppy.close();
    }
    // when user clicks Replace, show the input field
    replaceFile() {
      this.previewContainerTarget.classList.add("display--none");
      this.inputContainerTarget.classList.remove("display--none");
      this.progressContainerTarget.classList.add("display--none");
      this.formInputTarget.value = null;
      this.previewTarget.innerHTML = null;
      if (this.uppy.getFiles().length > 0) {
        this.uppy.removeFile(this.uppy.getFiles()[0].id);
      }
    }
    // show a tooltip on the submit actions when a file is uploading
    disabledSubmitTooltip(form) {
      let action_containers = form.querySelectorAll(".form__actions, .form__actions--section, .modal__bottom");
      action_containers.forEach((action_container) => {
        this.tippy = tippy(action_container, {
          allowHTML: true,
          content: "Waiting for files to upload before you can submit the form",
          placement: "top-end",
          animation: "fade",
          arrow: false,
          delay: [200, 50],
          onShow: (instance) => {
            return !!action_container.querySelector('input[type="submit"]').disabled;
          }
        });
      });
    }
  };

  // controllers/slider_range_controller.js
  var slider_range_controller_exports = {};
  __export(slider_range_controller_exports, {
    default: () => slider_range_controller_default
  });
  var import_pluralize = __toESM(require_pluralize());
  var slider_range_controller_default = class extends Controller {
    static targets = [
      "rangeMin",
      "rangeMax",
      // actual type="range" inputs
      "valueFrom",
      "valueTo",
      // elements that display the current values
      "valueFromWord",
      "valueToWord"
      // used to pluralize the words (e.g. "1 night" vs "2 nights")
    ];
    rangeMinTargetConnected(target) {
      this.element.style.setProperty("--min", `${(target.value - target.min) / (target.max - target.min) * 100}%`);
    }
    rangeMaxTargetConnected(target) {
      this.element.style.setProperty("--max", `${(target.value - target.min) / (target.max - target.min) * 100}%`);
    }
    valueFromWordTargetConnected(target) {
      target.innerText = (0, import_pluralize.default)(target.innerText, this.valueFromTarget.innerText);
    }
    valueToWordTargetConnected(target) {
      target.innerText = (0, import_pluralize.default)(target.innerText, this.valueToTarget.innerText);
    }
    // update the current value of the "from" range input
    updateFromValue(event) {
      this.element.style.setProperty("--min", this.calculatePercentOffset(event));
      let new_value = parseFloat(event.currentTarget.value);
      let to_value = parseFloat(this.rangeMaxTarget.value);
      if (new_value >= to_value) {
        this.rangeMaxTarget.value = new_value;
        this.valueToTarget.innerText = new_value;
        this.element.style.setProperty("--max", this.calculatePercentOffset(event));
      }
      this.valueFromTarget.innerText = new_value.toLocaleString();
      if (this.hasValueFromWordTarget) {
        this.valueFromWordTarget.innerText = (0, import_pluralize.default)(this.valueFromWordTarget.innerText, new_value);
      }
    }
    // update the current value of the "to" range input
    updateToValue(event) {
      this.element.style.setProperty("--max", this.calculatePercentOffset(event));
      let new_value = parseFloat(event.currentTarget.value);
      let from_value = parseFloat(this.rangeMinTarget.value);
      if (new_value <= from_value) {
        this.rangeMinTarget.value = new_value;
        this.valueFromTarget.innerText = new_value;
        this.element.style.setProperty("--min", this.calculatePercentOffset(event));
      }
      this.valueToTarget.innerText = new_value.toLocaleString();
      if (this.hasValueToWordTarget) {
        this.valueToWordTarget.innerText = (0, import_pluralize.default)(this.valueToWordTarget.innerText, new_value);
      }
    }
    // calculate the percent offset of the current value
    calculatePercentOffset(event) {
      return `${(event.currentTarget.value - event.currentTarget.min) / (event.currentTarget.max - event.currentTarget.min) * 100}%`;
    }
  };

  // controllers/tabs_controller.js
  var tabs_controller_exports = {};
  __export(tabs_controller_exports, {
    default: () => tabs_controller_default
  });
  var tabs_controller_default = class extends Controller {
    static targets = ["tab", "body"];
    // show correct tab section
    showSection(event) {
      this.tabTargets.forEach((link) => {
        link.classList.remove("tab--active");
      });
      let clickedTab = this.tabTargets.find((link) => {
        return link.dataset.tabId === event.currentTarget.dataset.tabId;
      });
      clickedTab.classList.add("tab--active");
      this.bodyTargets.forEach((body) => {
        if (clickedTab.dataset.tabId == body.id) {
          body.classList.remove("hidden");
        } else {
          body.classList.add("hidden");
        }
      });
    }
  };

  // controllers/timezone_controller.js
  var timezone_controller_exports = {};
  __export(timezone_controller_exports, {
    default: () => timezone_controller_default
  });
  var import_jstimezonedetect = __toESM(require_jstz_min());
  var timezone_controller_default = class extends Controller {
    connect() {
      this.element.value = import_jstimezonedetect.default.determine().name();
    }
  };

  // controllers/toast_controller.js
  var toast_controller_exports = {};
  __export(toast_controller_exports, {
    default: () => toast_controller_default
  });
  var toast_controller_default = class extends Controller {
    static values = { timeout: Number };
    connect() {
      if (this.timeoutValue > 0) {
        setTimeout(() => {
          this.remove();
        }, this.timeoutValue);
      }
    }
    remove() {
      this.element.remove();
    }
  };

  // controllers/tooltip_controller.js
  var tooltip_controller_exports = {};
  __export(tooltip_controller_exports, {
    default: () => tooltip_controller_default
  });
  var tooltip_controller_default = class extends Controller {
    static values = {
      content: String,
      placement: {
        type: String,
        default: "top"
      }
    };
    connect() {
      this.tippy = tippy_esm_default(this.element, {
        content: this.contentValue,
        placement: this.placementValue,
        delay: [200, 50],
        animation: "fade"
      });
    }
    disconnect() {
      this.tippy.destroy();
    }
  };

  // controllers/turbo_confirm_controller.js
  var turbo_confirm_controller_exports = {};
  __export(turbo_confirm_controller_exports, {
    default: () => turbo_confirm_controller_default
  });
  var turbo_confirm_controller_default = class extends Controller {
    static values = {
      title: String,
      body: String,
      buttonText: String,
      alertStyle: { type: String, default: "danger" }
    };
    connect() {
      this.generateDialog();
      this.setupDialog();
    }
    generateDialog() {
      const alert_icon = this.alertStyleValue === "danger" ? `<i class="fa-regular fa-exclamation-triangle fa-2x color--danger-dark p--3 mb--5px"></i>` : this.alertStyleValue === "success" ? `<i class="fa-regular fa-check fa-2x color--success-dark p--3"></i>` : this.alertStyleValue === "info" ? `<i class="fa-regular fa-circle-exclamation fa-2x color--information-dark p--3"></i>` : null;
      const dialogHTML = `<dialog id="turbo-confirm-dialog-${this.element.dataset.turboConfirm}">
                          <div class="alert-screen" aria-dialog tabindex="-1">
                              <div class="alert-bg"></div>
                              <form method="dialog" class="alert-modal">
                                <div class="alert__main">
                                  <i data-behaviour="close" class="alert__close fa-regular fa-times"></i>

                                  <div class="display--flex align-items--center justify-content--center mb--5">
                                    <div class="alert__icon alert__icon--${this.alertStyleValue}">${alert_icon}</div>
                                  </div>
                                  <div class="text--center font-size--1">${this.titleValue}</div>
                                  <div class="text--center color--light">${this.bodyValue}</div>
                                </div>
                                <div class="alert__actions">
                                  <button value="close" class="button button--grey button--stroke">Cancel</button>
                                  <button value="confirm" class="button button--${this.alertStyleValue}">${this.buttonTextValue}</button>
                                </div>
                              </form>
                            </div>
                          </dialog>`;
      document.body.insertAdjacentHTML("beforeend", dialogHTML);
      this.dialogElement = document.getElementById(`turbo-confirm-dialog-${this.element.dataset.turboConfirm}`);
      this.dialogElement.querySelector('[data-behaviour="close"]').addEventListener("click", (event) => {
        this.dialogElement.close("cancel");
      });
      this.dialogElement.addEventListener("keyup", (event) => {
        if (event.key === "Escape") {
          this.dialogElement.close("cancel");
        } else if (event.key === "Enter") {
          this.dialogElement.returnValue = "confirm";
          this.dialogElement.close("cancel");
        }
      });
    }
    setupDialog() {
      const originalConfirm = Turbo.config.forms.confirm;
      Turbo.config.forms.confirm = (element) => {
        if (element === this.element.dataset.turboConfirm) {
          this.dialogElement.showModal();
          return new Promise((resolve) => {
            this.dialogElement.addEventListener(
              "close",
              () => {
                resolve(this.dialogElement.returnValue === "confirm");
              },
              { once: true }
            );
          });
        }
        return originalConfirm?.(element);
      };
      this.dialogElement.focus();
    }
  };

  // rails:/Users/fabiosantos/dvl/aurelius-rails/app/javascript/controllers/**/*_controller.js
  var modules = [{ name: "copy", module: copy_controller_exports, filename: "copy_controller.js" }, { name: "datepicker", module: datepicker_controller_exports, filename: "datepicker_controller.js" }, { name: "filter", module: filter_controller_exports, filename: "filter_controller.js" }, { name: "form", module: form_controller_exports, filename: "form_controller.js" }, { name: "menu", module: menu_controller_exports, filename: "menu_controller.js" }, { name: "modal", module: modal_controller_exports, filename: "modal_controller.js" }, { name: "multi-upload", module: multi_upload_controller_exports, filename: "multi_upload_controller.js" }, { name: "scroll", module: scroll_controller_exports, filename: "scroll_controller.js" }, { name: "select2", module: select2_controller_exports, filename: "select2_controller.js" }, { name: "show-hide", module: show_hide_controller_exports, filename: "show_hide_controller.js" }, { name: "single-upload", module: single_upload_controller_exports, filename: "single_upload_controller.js" }, { name: "slider-range", module: slider_range_controller_exports, filename: "slider_range_controller.js" }, { name: "tabs", module: tabs_controller_exports, filename: "tabs_controller.js" }, { name: "timezone", module: timezone_controller_exports, filename: "timezone_controller.js" }, { name: "toast", module: toast_controller_exports, filename: "toast_controller.js" }, { name: "tooltip", module: tooltip_controller_exports, filename: "tooltip_controller.js" }, { name: "turbo-confirm", module: turbo_confirm_controller_exports, filename: "turbo_confirm_controller.js" }];
  var controller_default = modules;

  // controllers/index.js
  controller_default.forEach((controller) => {
    application.register(controller.name, controller.module.default);
  });

  // ../../node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    config: () => config,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start3,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter2) {
      if (submitter2) {
        validateSubmitter(submitter2, this);
        submitter2.click();
      } else {
        submitter2 = document.createElement("input");
        submitter2.type = "submit";
        submitter2.hidden = true;
        this.appendChild(submitter2);
        submitter2.click();
        this.removeChild(submitter2);
      }
    };
    function validateSubmitter(submitter2, form) {
      submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter2.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter2 = findSubmitterFromClickTarget(event.target);
    if (submitter2 && submitter2.form) {
      submittersByForm.set(submitter2.form, submitter2);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else if (name == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    get shouldReloadWithMorph() {
      return this.src && this.refresh === "morph";
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  var drive = {
    enabled: true,
    progressBarDelay: 500,
    unvisitableExtensions: /* @__PURE__ */ new Set(
      [
        ".7z",
        ".aac",
        ".apk",
        ".avi",
        ".bmp",
        ".bz2",
        ".css",
        ".csv",
        ".deb",
        ".dmg",
        ".doc",
        ".docx",
        ".exe",
        ".gif",
        ".gz",
        ".heic",
        ".heif",
        ".ico",
        ".iso",
        ".jpeg",
        ".jpg",
        ".js",
        ".json",
        ".m4a",
        ".mkv",
        ".mov",
        ".mp3",
        ".mp4",
        ".mpeg",
        ".mpg",
        ".msi",
        ".ogg",
        ".ogv",
        ".pdf",
        ".pkg",
        ".png",
        ".ppt",
        ".pptx",
        ".rar",
        ".rtf",
        ".svg",
        ".tar",
        ".tif",
        ".tiff",
        ".txt",
        ".wav",
        ".webm",
        ".webp",
        ".wma",
        ".wmv",
        ".xls",
        ".xlsx",
        ".xml",
        ".zip"
      ]
    )
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getCspNonce();
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function cancelEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate2(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate2(strings, values) {
    return strings.reduce((result, string, i4) => {
      const value = values[i4] == void 0 ? "" : values[i4];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_4, i4) => {
      if (i4 == 8 || i4 == 13 || i4 == 18 || i4 == 23) {
        return "-";
      } else if (i4 == 14) {
        return "4";
      } else if (i4 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string") return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function getCspNonce() {
    const element = getMetaElement("csp-nonce");
    if (element) {
      const { nonce, content } = element;
      return nonce == "" ? content : nonce;
    }
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  function doesNotTargetIFrame(name) {
    if (name === "_blank") {
      return false;
    } else if (name) {
      for (const element of document.getElementsByName(name)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  function debounce5(fn4, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn4.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var submitter = {
    "aria-disabled": {
      beforeSubmit: (submitter2) => {
        submitter2.setAttribute("aria-disabled", "true");
        submitter2.addEventListener("click", cancelEvent);
      },
      afterSubmit: (submitter2) => {
        submitter2.removeAttribute("aria-disabled");
        submitter2.removeEventListener("click", cancelEvent);
      }
    },
    "disabled": {
      beforeSubmit: (submitter2) => submitter2.disabled = true,
      afterSubmit: (submitter2) => submitter2.disabled = false
    }
  };
  var Config = class {
    #submitter = null;
    constructor(config2) {
      Object.assign(this, config2);
    }
    get submitter() {
      return this.#submitter;
    }
    set submitter(value) {
      this.#submitter = submitter[value] || value;
    }
  };
  var forms = new Config({
    mode: "on",
    submitter: "disabled"
  });
  var config = {
    drive,
    forms
  };
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter2) {
    const action = submitter2?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left3, right3) {
    return expandURL(left3).href == expandURL(right3).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method: method.toUpperCase(),
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod.toUpperCase();
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error2)) {
            this.delegate.requestErrored(this, error2);
          }
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented) await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error2) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error2 }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File) continue;
      else entries.push([name, value]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    state = FormSubmissionState.initialized;
    static confirmMethod(message) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter2, mustRedirect = false) {
      const method = getMethod(formElement, submitter2);
      const action = getAction(getFormAction(formElement, submitter2), method);
      const body = buildFormData(formElement, submitter2);
      const enctype = getEnctype(formElement, submitter2);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter2;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
        const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request3) {
      this.state = FormSubmissionState.waiting;
      if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request3) {
      this.state = FormSubmissionState.stopped;
      if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter2) {
    const formData = new FormData(formElement);
    const name = submitter2?.getAttribute("name");
    const value = submitter2?.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter2) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter2?.hasAttribute("formaction")) {
      return submitter2.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter2) {
    return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id14) {
      return getPermanentElementById(this.element, id14);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id: id14 } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id14);
        if (newPermanentElement) {
          permanentElementMap[id14] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id14) {
    return node.querySelector(`#${id14}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter2 = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter2);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter2) {
    const target = submitter2?.getAttribute("formtarget") || form.getAttribute("target");
    return doesNotTargetIFrame(target);
  }
  var View = class {
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x4, y: y4 }) {
      this.scrollRoot.scrollTo(x4, y4);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender) await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.clickEventIsSignificant(event)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.clickEventIsSignificant(event)) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    clickEventIsSignificant(event) {
      const target = event.composed ? event.target?.parentElement : event.target;
      const element = findLinkFromClickTarget(target) || target;
      return element instanceof Element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link.target)) {
          const location2 = getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id14 in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id14];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id14 in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id14];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id14) {
      return this.placeholders.find((element) => element.content == id14);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    #activeElement = null;
    static renderElement(currentElement, newElement) {
    }
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = this.constructor.renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get shouldAutofocus() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      if (this.shouldAutofocus) {
        const element = this.connectedSnapshot.firstAutofocusableElement;
        if (element) {
          element.focus();
        }
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config2 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config2);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren2(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    function ignoreAttribute(attr, to2, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to2 === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to2, updateType) === false;
    }
    function syncNodeFrom(from, to2, ctx) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to2.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to2, "update", ctx)) {
            continue;
          }
          if (to2.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to2.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i4 = toAttributes.length - 1; 0 <= i4; i4--) {
          const toAttribute = toAttributes[i4];
          if (ignoreAttribute(toAttribute.name, to2, "remove", ctx)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to2.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to2.nodeValue !== from.nodeValue) {
          to2.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to2, ctx)) {
        syncInputValue(from, to2, ctx);
      }
    }
    function syncBooleanAttribute(from, to2, attributeName, ctx) {
      if (from[attributeName] !== to2[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to2, "update", ctx);
        if (!ignoreUpdate) {
          to2[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to2.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to2, "remove", ctx)) {
            to2.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to2, ctx) {
      if (from instanceof HTMLInputElement && to2 instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to2.value;
        syncBooleanAttribute(from, to2, "checked", ctx);
        syncBooleanAttribute(from, to2, "disabled", ctx);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to2, "remove", ctx)) {
            to2.value = "";
            to2.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to2, "update", ctx)) {
            to2.setAttribute("value", fromValue);
            to2.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to2, "selected", ctx);
      } else if (from instanceof HTMLTextAreaElement && to2 instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to2.value;
        if (ignoreAttribute("value", to2, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue) {
          to2.value = fromValue;
        }
        if (to2.firstChild && to2.firstChild.nodeValue !== fromValue) {
          to2.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults(config2) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults.callbacks);
      Object.assign(finalConfig.callbacks, config2.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults.head);
      Object.assign(finalConfig.head, config2.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config2) {
      config2 = mergeDefaults(config2);
      return {
        target: oldNode,
        newContent,
        config: config2,
        morphStyle: config2.morphStyle,
        ignoreActive: config2.ignoreActive,
        ignoreActiveValue: config2.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config2.callbacks,
        head: config2.head
      };
    }
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx, id14) {
      return !ctx.deadIds.has(id14);
    }
    function idIsWithinNode(ctx, id14, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id14);
    }
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id14 of idSet) {
        ctx.deadIds.add(id14);
      }
    }
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id14 of sourceSet) {
        if (isIdInConsideration(ctx, id14) && idIsWithinNode(ctx, id14, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults
    };
  }();
  function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
    Idiomorph.morph(currentElement, newElement, {
      ...options,
      callbacks: new DefaultIdiomorphCallbacks(callbacks)
    });
  }
  function morphChildren(currentElement, newElement) {
    morphElements(currentElement, newElement.children, {
      morphStyle: "innerHTML"
    });
  }
  var DefaultIdiomorphCallbacks = class {
    #beforeNodeMorphed;
    constructor({ beforeNodeMorphed } = {}) {
      this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
    }
    beforeNodeAdded = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    beforeNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: currentElement,
            detail: { currentElement, newElement }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    beforeAttributeUpdated = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", {
        cancelable: true,
        target,
        detail: { attributeName, mutationType }
      });
      return !event.defaultPrevented;
    };
    beforeNodeRemoved = (node) => {
      return this.beforeNodeMorphed(node);
    };
    afterNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        dispatch("turbo:morph-element", {
          target: currentElement,
          detail: { currentElement, newElement }
        });
      }
    };
  };
  var MorphingFrameRenderer = class extends FrameRenderer {
    static renderElement(currentElement, newElement) {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      morphChildren(currentElement, newElement);
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
  };
  var ProgressBar = class _ProgressBar {
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      const cspNonce = getCspNonce();
      if (cspNonce) {
        element.nonce = cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  var HeadSnapshot = class extends Snapshot {
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions) option.selected = false;
        for (const option of source.selectedOptions) clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root = this.getSetting("root") ?? "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var ViewTransitioner = class {
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render2).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render2);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions3 = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions3,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request3, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request3, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.#findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      const frame = this.#findFrameElement(element, submitter2);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter2);
      }
    }
    #shouldSubmit(form, submitter2) {
      const action = getAction$1(form, submitter2);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter2) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.#findFrameElement(element, submitter2);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter2) {
      const id14 = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id14 && id14 != "_top") {
        const frame = this.element.querySelector(`#${id14}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false") return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link = target;
        const location2 = getLocationForLink(link);
        if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
          this.#prefetchedLink = link;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link) {
      const href = link.getAttribute("href");
      if (!href) return false;
      if (unfetchableLink(link)) return false;
      if (linkToTheSamePage(link)) return false;
      if (linkOptsOut(link)) return false;
      if (nonSafeLink(link)) return false;
      if (eventPrevented(link)) return false;
      return true;
    }
  };
  var unfetchableLink = (link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  };
  var linkToTheSamePage = (link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  };
  var linkOptsOut = (link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link)) return true;
    if (link.hasAttribute("data-turbo-confirm")) return true;
    if (link.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  };
  var eventPrevented = (link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter2) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter2, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
      delete this.currentVisit;
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter: submitter2, formElement } = formSubmission;
      return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id: id14 } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id14);
        if (elementInStream) {
          permanentElementMap[id14] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var StreamObserver = class {
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphingPageRenderer = class extends PageRenderer {
    static renderElement(currentElement, newElement) {
      morphElements(currentElement, newElement, {
        callbacks: {
          beforeNodeMorphed: (element) => !canRefreshFrame(element)
        }
      });
      for (const frame of currentElement.querySelectorAll("turbo-frame")) {
        if (canRefreshFrame(frame)) frame.reload();
      }
      dispatch("turbo:morph", { detail: { currentElement, newElement } });
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
    get renderMethod() {
      return "morph";
    }
    get shouldAutofocus() {
      return false;
    }
  };
  function canRefreshFrame(frame) {
    return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
  }
  var SnapshotCache = class {
    keys = [];
    snapshots = {};
    constructor(size) {
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1) this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_4) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var Session = class {
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    enabled = true;
    started = false;
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest && !this.navigator.currentVisit) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      console.warn(
        "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
      );
      this.progressBarDelay = delay;
    }
    set progressBarDelay(delay) {
      config.drive.progressBarDelay = delay;
    }
    get progressBarDelay() {
      return config.drive.progressBarDelay;
    }
    set drive(value) {
      config.drive.enabled = value;
    }
    get drive() {
      return config.drive.enabled;
    }
    set formMode(value) {
      config.forms.mode = value;
    }
    get formMode() {
      return config.forms.mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce5(this.debouncedRefresh.bind(this), value);
      this.#pageRefreshDebouncePeriod = value;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter2) {
      this.navigator.submitForm(form, submitter2);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter2) {
      if (config.forms.mode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
        if (config.forms.mode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (config.drive.enabled || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start3() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    console.warn(
      "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.drive.progressBarDelay = delay;
  }
  function setConfirmMethod(confirmMethod) {
    console.warn(
      "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.confirm = confirmMethod;
  }
  function setFormMode(mode) {
    console.warn(
      "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.mode = mode;
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    config,
    start: start3,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    #shouldMorphFrame = false;
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { refresh, src } = this.element;
      this.#shouldMorphFrame = src && refresh === "morph";
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.#shouldMorphFrame = false;
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return this.#shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.#findFrameElement(link);
      if (frame) form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter2);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request3) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request3, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.#resolveVisitPromise();
    }
    requestFinished(_request3) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
        if (this.view.renderPromise) await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter2) {
      const frame = this.#findFrameElement(element, submitter2);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
      this.#withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter2) {
      const id14 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      return getFrameElementById(id14) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id14 = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id14}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id14}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error2) {
        console.error(error2);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter2) {
      const id14 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
        return false;
      }
      if (!this.enabled || id14 == "_top") {
        return false;
      }
      if (id14) {
        const frameElement = getFrameElementById(id14);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter2 && !session.elementIsNavigatable(submitter2)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = meta?.content ?? "/";
      return expandURL(root);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id14) {
    if (id14 != null) {
      const element = document.getElementById(id14);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e4) => e4.parentElement?.insertBefore(this.templateContent, e4.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e4) => e4.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e4) => e4.parentElement?.insertBefore(this.templateContent, e4));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e4) => e4.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e4) => e4.remove());
    },
    replace() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphElements(targetElement, this.templateContent);
        } else {
          targetElement.replaceWith(this.templateContent);
        }
      });
    },
    update() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphChildren(targetElement, this.templateContent);
        } else {
          targetElement.innerHTML = "";
          targetElement.append(this.templateContent);
        }
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c4) => c4.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e4) => [...e4.children]).filter((c4) => !!c4.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c4) => !!c4.id).map((c4) => c4.id);
      return existingChildren.filter((c4) => newChildrenIds.includes(c4.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo2, StreamActions };
  start3();

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object") return obj;
    if (obj instanceof Date || obj instanceof RegExp) return obj;
    if (Array.isArray(obj)) return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m4, x4) {
        return "_" + x4.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    static observedAttributes = ["channel", "signed-stream-name"];
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription) this.subscription.unsubscribe();
      this.subscriptionDisconnected();
    }
    attributeChangedCallback() {
      if (this.subscription) {
        this.disconnectedCallback();
        this.connectedCallback();
      }
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter2, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter2, body, form) {
    const formMethod = determineFormMethod(submitter2);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter2) {
    if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
      if (submitter2.name === "_method") {
        return submitter2.value;
      } else if (submitter2.hasAttribute("formmethod")) {
        return submitter2.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // ../../node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // vendor/jquery.js
  var import_jquery = __toESM(require_jquery());
  window.jQuery = import_jquery.default;
  window.$ = import_jquery.default;

  // vendor/cocoon.js
  (function($5) {
    var cocoon_element_counter = 0;
    var create_new_id = function() {
      return (/* @__PURE__ */ new Date()).getTime() + cocoon_element_counter++;
    };
    var newcontent_braced = function(id14) {
      return "[" + id14 + "]$1";
    };
    var newcontent_underscord = function(id14) {
      return "_" + id14 + "_$1";
    };
    var getInsertionNodeElem = function(insertionNode, insertionTraversal, $this) {
      if (!insertionNode) {
        return $this.parent();
      }
      if (typeof insertionNode == "function") {
        if (insertionTraversal) {
          console.warn("association-insertion-traversal is ignored, because association-insertion-node is given as a function.");
        }
        return insertionNode($this);
      }
      if (typeof insertionNode == "string") {
        if (insertionTraversal) {
          return $this[insertionTraversal](insertionNode);
        } else {
          return insertionNode == "this" ? $this : $5(insertionNode);
        }
      }
    };
    $5(document).on("click", ".add_fields", function(e4) {
      e4.preventDefault();
      e4.stopPropagation();
      var $this = $5(this), assoc = $this.data("association"), assocs = $this.data("associations"), content = $this.data("association-insertion-template"), insertionMethod = $this.data("association-insertion-method") || $this.data("association-insertion-position") || "before", insertionNode = $this.data("association-insertion-node"), insertionTraversal = $this.data("association-insertion-traversal"), count = parseInt($this.data("count"), 10), regexp_braced = new RegExp("\\[new_" + assoc + "\\](.*?\\s)", "g"), regexp_underscord = new RegExp("_new_" + assoc + "_(\\w*)", "g"), new_id = create_new_id(), new_content = content.replace(regexp_braced, newcontent_braced(new_id)), new_contents = [], originalEvent = e4;
      if (new_content == content) {
        regexp_braced = new RegExp("\\[new_" + assocs + "\\](.*?\\s)", "g");
        regexp_underscord = new RegExp("_new_" + assocs + "_(\\w*)", "g");
        new_content = content.replace(regexp_braced, newcontent_braced(new_id));
      }
      new_content = new_content.replace(regexp_underscord, newcontent_underscord(new_id));
      new_contents = [new_content];
      count = isNaN(count) ? 1 : Math.max(count, 1);
      count -= 1;
      while (count) {
        new_id = create_new_id();
        new_content = content.replace(regexp_braced, newcontent_braced(new_id));
        new_content = new_content.replace(regexp_underscord, newcontent_underscord(new_id));
        new_contents.push(new_content);
        count -= 1;
      }
      var insertionNodeElem = getInsertionNodeElem(insertionNode, insertionTraversal, $this);
      if (!insertionNodeElem || insertionNodeElem.length == 0) {
        console.warn("Couldn't find the element to insert the template. Make sure your `data-association-insertion-*` on `link_to_add_association` is correct.");
      }
      $5.each(new_contents, function(i4, node) {
        var contentNode = $5(node);
        var before_insert = jQuery.Event("cocoon:before-insert");
        insertionNodeElem.trigger(before_insert, [contentNode, originalEvent]);
        if (!before_insert.isDefaultPrevented()) {
          var addedContent = insertionNodeElem[insertionMethod](contentNode);
          insertionNodeElem.trigger("cocoon:after-insert", [contentNode, originalEvent]);
        }
      });
    });
    $5(document).on("click", ".remove_fields.dynamic, .remove_fields.existing", function(e4) {
      var $this = $5(this), wrapper_class = $this.data("wrapper-class") || "nested-fields", node_to_delete = $this.closest("." + wrapper_class), trigger_node = node_to_delete.parent(), originalEvent = e4;
      e4.preventDefault();
      e4.stopPropagation();
      var before_remove = jQuery.Event("cocoon:before-remove");
      trigger_node.trigger(before_remove, [node_to_delete, originalEvent]);
      if (!before_remove.isDefaultPrevented()) {
        var timeout = trigger_node.data("remove-timeout") || 0;
        setTimeout(function() {
          if ($this.hasClass("dynamic")) {
            node_to_delete.detach();
          } else {
            $this.prev("input[type=hidden]").val("1");
            node_to_delete.hide();
          }
          trigger_node.trigger("cocoon:after-remove", [node_to_delete, originalEvent]);
        }, timeout);
      }
    });
    var hideRemoveFields = function() {
      $5(".remove_fields.existing.destroyed").each(function(i4, obj) {
        var $this = $5(this), wrapper_class = $this.data("wrapper-class") || "nested-fields";
        $this.closest("." + wrapper_class).hide();
      });
    };
    $5(function() {
      hideRemoveFields();
      $5(document).on("page:load turbolinks:load turbo:load", hideRemoveFields);
    });
  })(jQuery);

  // ../../node_modules/trix/dist/trix.esm.min.js
  var t3 = "2.1.15";
  var e3 = "[data-trix-attachment]";
  var i3 = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
  var n3 = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t5) {
    return r3(t5.parentNode) === n3[this.listAttribute].tagName;
  } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t5) {
    return r3(t5.parentNode) === n3[this.listAttribute].tagName;
  } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
  var r3 = (t5) => {
    var e4;
    return null == t5 || null === (e4 = t5.tagName) || void 0 === e4 ? void 0 : e4.toLowerCase();
  };
  var o3 = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i);
  var s3 = o3 && parseInt(o3[1]);
  var a3 = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s3 && s3 > 12, samsungAndroid: s3 && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: "undefined" != typeof InputEvent && ["data", "getTargetRanges", "inputType"].every((t5) => t5 in InputEvent.prototype) };
  var l3 = { ADD_ATTR: ["language"], SAFE_FOR_XML: false, RETURN_DOM: true };
  var c3 = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
  var u3 = [c3.bytes, c3.KB, c3.MB, c3.GB, c3.TB, c3.PB];
  var h3 = { prefix: "IEC", precision: 2, formatter(t5) {
    switch (t5) {
      case 0:
        return "0 ".concat(c3.bytes);
      case 1:
        return "1 ".concat(c3.byte);
      default:
        let e4;
        "SI" === this.prefix ? e4 = 1e3 : "IEC" === this.prefix && (e4 = 1024);
        const i4 = Math.floor(Math.log(t5) / Math.log(e4)), n4 = (t5 / Math.pow(e4, i4)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
        return "".concat(n4, " ").concat(u3[i4]);
    }
  } };
  var d3 = "\uFEFF";
  var g3 = "\xA0";
  var m3 = function(t5) {
    for (const e4 in t5) {
      const i4 = t5[e4];
      this[e4] = i4;
    }
    return this;
  };
  var p3 = document.documentElement;
  var f3 = p3.matches;
  var b3 = function(t5) {
    let { onElement: e4, matchingSelector: i4, withCallback: n4, inPhase: r4, preventDefault: o4, times: s4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const a4 = e4 || p3, l4 = i4, c4 = "capturing" === r4, u4 = function(t6) {
      null != s4 && 0 == --s4 && u4.destroy();
      const e5 = y3(t6.target, { matchingSelector: l4 });
      null != e5 && (null == n4 || n4.call(e5, t6, e5), o4 && t6.preventDefault());
    };
    return u4.destroy = () => a4.removeEventListener(t5, u4, c4), a4.addEventListener(t5, u4, c4), u4;
  };
  var v3 = function(t5) {
    let { onElement: e4, bubbles: i4, cancelable: n4, attributes: r4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const o4 = null != e4 ? e4 : p3;
    i4 = false !== i4, n4 = false !== n4;
    const s4 = document.createEvent("Events");
    return s4.initEvent(t5, i4, n4), null != r4 && m3.call(s4, r4), o4.dispatchEvent(s4);
  };
  var A3 = function(t5, e4) {
    if (1 === (null == t5 ? void 0 : t5.nodeType)) return f3.call(t5, e4);
  };
  var y3 = function(t5) {
    let { matchingSelector: e4, untilNode: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (; t5 && t5.nodeType !== Node.ELEMENT_NODE; ) t5 = t5.parentNode;
    if (null != t5) {
      if (null == e4) return t5;
      if (t5.closest && null == i4) return t5.closest(e4);
      for (; t5 && t5 !== i4; ) {
        if (A3(t5, e4)) return t5;
        t5 = t5.parentNode;
      }
    }
  };
  var x3 = (t5) => document.activeElement !== t5 && C3(t5, document.activeElement);
  var C3 = function(t5, e4) {
    if (t5 && e4) for (; e4; ) {
      if (e4 === t5) return true;
      e4 = e4.parentNode;
    }
  };
  var E2 = function(t5) {
    var e4;
    if (null === (e4 = t5) || void 0 === e4 || !e4.parentNode) return;
    let i4 = 0;
    for (t5 = t5.previousSibling; t5; ) i4++, t5 = t5.previousSibling;
    return i4;
  };
  var S3 = (t5) => {
    var e4;
    return null == t5 || null === (e4 = t5.parentNode) || void 0 === e4 ? void 0 : e4.removeChild(t5);
  };
  var R2 = function(t5) {
    let { onlyNodesOfType: e4, usingFilter: i4, expandEntityReferences: n4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r4 = (() => {
      switch (e4) {
        case "element":
          return NodeFilter.SHOW_ELEMENT;
        case "text":
          return NodeFilter.SHOW_TEXT;
        case "comment":
          return NodeFilter.SHOW_COMMENT;
        default:
          return NodeFilter.SHOW_ALL;
      }
    })();
    return document.createTreeWalker(t5, r4, null != i4 ? i4 : null, true === n4);
  };
  var k3 = (t5) => {
    var e4;
    return null == t5 || null === (e4 = t5.tagName) || void 0 === e4 ? void 0 : e4.toLowerCase();
  };
  var T3 = function(t5) {
    let e4, i4, n4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    "object" == typeof t5 ? (n4 = t5, t5 = n4.tagName) : n4 = { attributes: n4 };
    const r4 = document.createElement(t5);
    if (null != n4.editable && (null == n4.attributes && (n4.attributes = {}), n4.attributes.contenteditable = n4.editable), n4.attributes) for (e4 in n4.attributes) i4 = n4.attributes[e4], r4.setAttribute(e4, i4);
    if (n4.style) for (e4 in n4.style) i4 = n4.style[e4], r4.style[e4] = i4;
    if (n4.data) for (e4 in n4.data) i4 = n4.data[e4], r4.dataset[e4] = i4;
    return n4.className && n4.className.split(" ").forEach((t6) => {
      r4.classList.add(t6);
    }), n4.textContent && (r4.textContent = n4.textContent), n4.childNodes && [].concat(n4.childNodes).forEach((t6) => {
      r4.appendChild(t6);
    }), r4;
  };
  var w3;
  var L3 = function() {
    if (null != w3) return w3;
    w3 = [];
    for (const t5 in n3) {
      const e4 = n3[t5];
      e4.tagName && w3.push(e4.tagName);
    }
    return w3;
  };
  var D3 = (t5) => I3(null == t5 ? void 0 : t5.firstChild);
  var N3 = function(t5) {
    let { strict: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { strict: true };
    return e4 ? I3(t5) : I3(t5) || !I3(t5.firstChild) && function(t6) {
      return L3().includes(k3(t6)) && !L3().includes(k3(t6.firstChild));
    }(t5);
  };
  var I3 = (t5) => O3(t5) && "block" === (null == t5 ? void 0 : t5.data);
  var O3 = (t5) => (null == t5 ? void 0 : t5.nodeType) === Node.COMMENT_NODE;
  var F3 = function(t5) {
    let { name: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t5) return B3(t5) ? t5.data === d3 ? !e4 || t5.parentNode.dataset.trixCursorTarget === e4 : void 0 : F3(t5.firstChild);
  };
  var P3 = (t5) => A3(t5, e3);
  var M3 = (t5) => B3(t5) && "" === (null == t5 ? void 0 : t5.data);
  var B3 = (t5) => (null == t5 ? void 0 : t5.nodeType) === Node.TEXT_NODE;
  var _3 = { level2Enabled: true, getLevel() {
    return this.level2Enabled && a3.supportsInputEvents ? 2 : 0;
  }, pickFiles(t5) {
    const e4 = T3("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
    e4.addEventListener("change", () => {
      t5(e4.files), S3(e4);
    }), S3(document.getElementById(this.fileInputId)), document.body.appendChild(e4), e4.click();
  } };
  var j3 = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: "\n" };
  var W2 = { bold: { tagName: "strong", inheritable: true, parser(t5) {
    const e4 = window.getComputedStyle(t5);
    return "bold" === e4.fontWeight || e4.fontWeight >= 600;
  } }, italic: { tagName: "em", inheritable: true, parser: (t5) => "italic" === window.getComputedStyle(t5).fontStyle }, href: { groupTagName: "a", parser(t5) {
    const i4 = "a:not(".concat(e3, ")"), n4 = t5.closest(i4);
    if (n4) return n4.getAttribute("href");
  } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
  var U2 = { getDefaultHTML: () => '<div class="trix-button-row">\n      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="'.concat(c3.bold, '" tabindex="-1">').concat(c3.bold, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="').concat(c3.italic, '" tabindex="-1">').concat(c3.italic, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="').concat(c3.strike, '" tabindex="-1">').concat(c3.strike, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="').concat(c3.link, '" tabindex="-1">').concat(c3.link, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="').concat(c3.heading1, '" tabindex="-1">').concat(c3.heading1, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="').concat(c3.quote, '" tabindex="-1">').concat(c3.quote, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="').concat(c3.code, '" tabindex="-1">').concat(c3.code, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="').concat(c3.bullets, '" tabindex="-1">').concat(c3.bullets, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="').concat(c3.numbers, '" tabindex="-1">').concat(c3.numbers, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="').concat(c3.outdent, '" tabindex="-1">').concat(c3.outdent, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="').concat(c3.indent, '" tabindex="-1">').concat(c3.indent, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="').concat(c3.attachFiles, '" tabindex="-1">').concat(c3.attachFiles, '</button>\n      </span>\n\n      <span class="trix-button-group-spacer"></span>\n\n      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="').concat(c3.undo, '" tabindex="-1">').concat(c3.undo, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="').concat(c3.redo, '" tabindex="-1">').concat(c3.redo, '</button>\n      </span>\n    </div>\n\n    <div class="trix-dialogs" data-trix-dialogs>\n      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n        <div class="trix-dialog__link-fields">\n          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="').concat(c3.urlPlaceholder, '" aria-label="').concat(c3.url, '" data-trix-validate-href required data-trix-input>\n          <div class="trix-button-group">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c3.link, '" data-trix-method="setAttribute">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c3.unlink, '" data-trix-method="removeAttribute">\n          </div>\n        </div>\n      </div>\n    </div>') };
  var V2 = { interval: 5e3 };
  var z3 = Object.freeze({ __proto__: null, attachments: i3, blockAttributes: n3, browser: a3, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, dompurify: l3, fileSize: h3, input: _3, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: c3, parser: j3, textAttributes: W2, toolbar: U2, undo: V2 });
  var q3 = class {
    static proxyMethod(t5) {
      const { name: e4, toMethod: i4, toProperty: n4, optional: r4 } = H3(t5);
      this.prototype[e4] = function() {
        let t6, o4;
        var s4, a4;
        i4 ? o4 = r4 ? null === (s4 = this[i4]) || void 0 === s4 ? void 0 : s4.call(this) : this[i4]() : n4 && (o4 = this[n4]);
        return r4 ? (t6 = null === (a4 = o4) || void 0 === a4 ? void 0 : a4[e4], t6 ? J2.call(t6, o4, arguments) : void 0) : (t6 = o4[e4], J2.call(t6, o4, arguments));
      };
    }
  };
  var H3 = function(t5) {
    const e4 = t5.match(K2);
    if (!e4) throw new Error("can't parse @proxyMethod expression: ".concat(t5));
    const i4 = { name: e4[4] };
    return null != e4[2] ? i4.toMethod = e4[1] : i4.toProperty = e4[1], null != e4[3] && (i4.optional = true), i4;
  };
  var { apply: J2 } = Function.prototype;
  var K2 = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
  var G2;
  var Y2;
  var X2;
  var $4 = class extends q3 {
    static box() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      return t5 instanceof this ? t5 : this.fromUCS2String(null == t5 ? void 0 : t5.toString());
    }
    static fromUCS2String(t5) {
      return new this(t5, et(t5));
    }
    static fromCodepoints(t5) {
      return new this(it(t5), t5);
    }
    constructor(t5, e4) {
      super(...arguments), this.ucs2String = t5, this.codepoints = e4, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
    }
    offsetToUCS2Offset(t5) {
      return it(this.codepoints.slice(0, Math.max(0, t5))).length;
    }
    offsetFromUCS2Offset(t5) {
      return et(this.ucs2String.slice(0, Math.max(0, t5))).length;
    }
    slice() {
      return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
    }
    charAt(t5) {
      return this.slice(t5, t5 + 1);
    }
    isEqualTo(t5) {
      return this.constructor.box(t5).ucs2String === this.ucs2String;
    }
    toJSON() {
      return this.ucs2String;
    }
    getCacheKey() {
      return this.ucs2String;
    }
    toString() {
      return this.ucs2String;
    }
  };
  var Z2 = 1 === (null === (G2 = Array.from) || void 0 === G2 ? void 0 : G2.call(Array, "\u{1F47C}").length);
  var Q2 = null != (null === (Y2 = " ".codePointAt) || void 0 === Y2 ? void 0 : Y2.call(" ", 0));
  var tt = " \u{1F47C}" === (null === (X2 = String.fromCodePoint) || void 0 === X2 ? void 0 : X2.call(String, 32, 128124));
  var et;
  var it;
  et = Z2 && Q2 ? (t5) => Array.from(t5).map((t6) => t6.codePointAt(0)) : function(t5) {
    const e4 = [];
    let i4 = 0;
    const { length: n4 } = t5;
    for (; i4 < n4; ) {
      let r4 = t5.charCodeAt(i4++);
      if (55296 <= r4 && r4 <= 56319 && i4 < n4) {
        const e5 = t5.charCodeAt(i4++);
        56320 == (64512 & e5) ? r4 = ((1023 & r4) << 10) + (1023 & e5) + 65536 : i4--;
      }
      e4.push(r4);
    }
    return e4;
  }, it = tt ? (t5) => String.fromCodePoint(...Array.from(t5 || [])) : function(t5) {
    return (() => {
      const e4 = [];
      return Array.from(t5).forEach((t6) => {
        let i4 = "";
        t6 > 65535 && (t6 -= 65536, i4 += String.fromCharCode(t6 >>> 10 & 1023 | 55296), t6 = 56320 | 1023 & t6), e4.push(i4 + String.fromCharCode(t6));
      }), e4;
    })().join("");
  };
  var nt = 0;
  var rt = class extends q3 {
    static fromJSONString(t5) {
      return this.fromJSON(JSON.parse(t5));
    }
    constructor() {
      super(...arguments), this.id = ++nt;
    }
    hasSameConstructorAs(t5) {
      return this.constructor === (null == t5 ? void 0 : t5.constructor);
    }
    isEqualTo(t5) {
      return this === t5;
    }
    inspect() {
      const t5 = [], e4 = this.contentsForInspection() || {};
      for (const i4 in e4) {
        const n4 = e4[i4];
        t5.push("".concat(i4, "=").concat(n4));
      }
      return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t5.length ? " ".concat(t5.join(", ")) : "", ">");
    }
    contentsForInspection() {
    }
    toJSONString() {
      return JSON.stringify(this);
    }
    toUTF16String() {
      return $4.box(this);
    }
    getCacheKey() {
      return this.id.toString();
    }
  };
  var ot = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t5.length !== e4.length) return false;
    for (let i4 = 0; i4 < t5.length; i4++) {
      if (t5[i4] !== e4[i4]) return false;
    }
    return true;
  };
  var st = function(t5) {
    const e4 = t5.slice(0);
    for (var i4 = arguments.length, n4 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1; r4 < i4; r4++) n4[r4 - 1] = arguments[r4];
    return e4.splice(...n4), e4;
  };
  var at = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/;
  var lt = function() {
    const t5 = T3("input", { dir: "auto", name: "x", dirName: "x.dir" }), e4 = T3("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i4 = T3("form");
    i4.appendChild(t5), i4.appendChild(e4);
    const n4 = function() {
      try {
        return new FormData(i4).has(e4.dirName);
      } catch (t6) {
        return false;
      }
    }(), r4 = function() {
      try {
        return t5.matches(":dir(ltr),:dir(rtl)");
      } catch (t6) {
        return false;
      }
    }();
    return n4 ? function(t6) {
      return e4.value = t6, new FormData(i4).get(e4.dirName);
    } : r4 ? function(e5) {
      return t5.value = e5, t5.matches(":dir(rtl)") ? "rtl" : "ltr";
    } : function(t6) {
      const e5 = t6.trim().charAt(0);
      return at.test(e5) ? "rtl" : "ltr";
    };
  }();
  var ct = null;
  var ut = null;
  var ht = null;
  var dt = null;
  var gt = () => (ct || (ct = bt().concat(pt())), ct);
  var mt = (t5) => n3[t5];
  var pt = () => (ut || (ut = Object.keys(n3)), ut);
  var ft = (t5) => W2[t5];
  var bt = () => (ht || (ht = Object.keys(W2)), ht);
  var vt = function(t5, e4) {
    At(t5).textContent = e4.replace(/%t/g, t5);
  };
  var At = function(t5) {
    const e4 = document.createElement("style");
    e4.setAttribute("type", "text/css"), e4.setAttribute("data-tag-name", t5.toLowerCase());
    const i4 = yt();
    return i4 && e4.setAttribute("nonce", i4), document.head.insertBefore(e4, document.head.firstChild), e4;
  };
  var yt = function() {
    const t5 = xt("trix-csp-nonce") || xt("csp-nonce");
    if (t5) {
      const { nonce: e4, content: i4 } = t5;
      return "" == e4 ? i4 : e4;
    }
  };
  var xt = (t5) => document.head.querySelector("meta[name=".concat(t5, "]"));
  var Ct = { "application/x-trix-feature-detection": "test" };
  var Et = function(t5) {
    const e4 = t5.getData("text/plain"), i4 = t5.getData("text/html");
    if (!e4 || !i4) return null == e4 ? void 0 : e4.length;
    {
      const { body: t6 } = new DOMParser().parseFromString(i4, "text/html");
      if (t6.textContent === e4) return !t6.querySelector("*");
    }
  };
  var St = /Mac|^iP/.test(navigator.platform) ? (t5) => t5.metaKey : (t5) => t5.ctrlKey;
  var Rt = (t5) => setTimeout(t5, 1);
  var kt = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const e4 = {};
    for (const i4 in t5) {
      const n4 = t5[i4];
      e4[i4] = n4;
    }
    return e4;
  };
  var Tt = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (Object.keys(t5).length !== Object.keys(e4).length) return false;
    for (const i4 in t5) {
      if (t5[i4] !== e4[i4]) return false;
    }
    return true;
  };
  var wt = function(t5) {
    if (null != t5) return Array.isArray(t5) || (t5 = [t5, t5]), [Nt(t5[0]), Nt(null != t5[1] ? t5[1] : t5[0])];
  };
  var Lt = function(t5) {
    if (null == t5) return;
    const [e4, i4] = wt(t5);
    return It(e4, i4);
  };
  var Dt = function(t5, e4) {
    if (null == t5 || null == e4) return;
    const [i4, n4] = wt(t5), [r4, o4] = wt(e4);
    return It(i4, r4) && It(n4, o4);
  };
  var Nt = function(t5) {
    return "number" == typeof t5 ? t5 : kt(t5);
  };
  var It = function(t5, e4) {
    return "number" == typeof t5 ? t5 === e4 : Tt(t5, e4);
  };
  var Ot = class extends q3 {
    constructor() {
      super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
    }
    start() {
      this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
    }
    stop() {
      if (this.started) return this.started = false, document.removeEventListener("selectionchange", this.update, true);
    }
    registerSelectionManager(t5) {
      if (!this.selectionManagers.includes(t5)) return this.selectionManagers.push(t5), this.start();
    }
    unregisterSelectionManager(t5) {
      if (this.selectionManagers = this.selectionManagers.filter((e4) => e4 !== t5), 0 === this.selectionManagers.length) return this.stop();
    }
    notifySelectionManagersOfSelectionChange() {
      return this.selectionManagers.map((t5) => t5.selectionDidChange());
    }
    update() {
      this.notifySelectionManagersOfSelectionChange();
    }
    reset() {
      this.update();
    }
  };
  var Ft = new Ot();
  var Pt = function() {
    const t5 = window.getSelection();
    if (t5.rangeCount > 0) return t5;
  };
  var Mt = function() {
    var t5;
    const e4 = null === (t5 = Pt()) || void 0 === t5 ? void 0 : t5.getRangeAt(0);
    if (e4 && !_t(e4)) return e4;
  };
  var Bt = function(t5) {
    const e4 = window.getSelection();
    return e4.removeAllRanges(), e4.addRange(t5), Ft.update();
  };
  var _t = (t5) => jt(t5.startContainer) || jt(t5.endContainer);
  var jt = (t5) => !Object.getPrototypeOf(t5);
  var Wt = (t5) => t5.replace(new RegExp("".concat(d3), "g"), "").replace(new RegExp("".concat(g3), "g"), " ");
  var Ut = new RegExp("[^\\S".concat(g3, "]"));
  var Vt = (t5) => t5.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " ");
  var zt = function(t5, e4) {
    if (t5.isEqualTo(e4)) return ["", ""];
    const i4 = qt(t5, e4), { length: n4 } = i4.utf16String;
    let r4;
    if (n4) {
      const { offset: o4 } = i4, s4 = t5.codepoints.slice(0, o4).concat(t5.codepoints.slice(o4 + n4));
      r4 = qt(e4, $4.fromCodepoints(s4));
    } else r4 = qt(e4, t5);
    return [i4.utf16String.toString(), r4.utf16String.toString()];
  };
  var qt = function(t5, e4) {
    let i4 = 0, n4 = t5.length, r4 = e4.length;
    for (; i4 < n4 && t5.charAt(i4).isEqualTo(e4.charAt(i4)); ) i4++;
    for (; n4 > i4 + 1 && t5.charAt(n4 - 1).isEqualTo(e4.charAt(r4 - 1)); ) n4--, r4--;
    return { utf16String: t5.slice(i4, n4), offset: i4 };
  };
  var Ht = class _Ht extends rt {
    static fromCommonAttributesOfObjects() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      if (!t5.length) return new this();
      let e4 = Yt(t5[0]), i4 = e4.getKeys();
      return t5.slice(1).forEach((t6) => {
        i4 = e4.getKeysCommonToHash(Yt(t6)), e4 = e4.slice(i4);
      }), e4;
    }
    static box(t5) {
      return Yt(t5);
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(...arguments), this.values = Gt(t5);
    }
    add(t5, e4) {
      return this.merge(Jt(t5, e4));
    }
    remove(t5) {
      return new _Ht(Gt(this.values, t5));
    }
    get(t5) {
      return this.values[t5];
    }
    has(t5) {
      return t5 in this.values;
    }
    merge(t5) {
      return new _Ht(Kt(this.values, Xt(t5)));
    }
    slice(t5) {
      const e4 = {};
      return Array.from(t5).forEach((t6) => {
        this.has(t6) && (e4[t6] = this.values[t6]);
      }), new _Ht(e4);
    }
    getKeys() {
      return Object.keys(this.values);
    }
    getKeysCommonToHash(t5) {
      return t5 = Yt(t5), this.getKeys().filter((e4) => this.values[e4] === t5.values[e4]);
    }
    isEqualTo(t5) {
      return ot(this.toArray(), Yt(t5).toArray());
    }
    isEmpty() {
      return 0 === this.getKeys().length;
    }
    toArray() {
      if (!this.array) {
        const t5 = [];
        for (const e4 in this.values) {
          const i4 = this.values[e4];
          t5.push(t5.push(e4, i4));
        }
        this.array = t5.slice(0);
      }
      return this.array;
    }
    toObject() {
      return Gt(this.values);
    }
    toJSON() {
      return this.toObject();
    }
    contentsForInspection() {
      return { values: JSON.stringify(this.values) };
    }
  };
  var Jt = function(t5, e4) {
    const i4 = {};
    return i4[t5] = e4, i4;
  };
  var Kt = function(t5, e4) {
    const i4 = Gt(t5);
    for (const t6 in e4) {
      const n4 = e4[t6];
      i4[t6] = n4;
    }
    return i4;
  };
  var Gt = function(t5, e4) {
    const i4 = {};
    return Object.keys(t5).sort().forEach((n4) => {
      n4 !== e4 && (i4[n4] = t5[n4]);
    }), i4;
  };
  var Yt = function(t5) {
    return t5 instanceof Ht ? t5 : new Ht(t5);
  };
  var Xt = function(t5) {
    return t5 instanceof Ht ? t5.values : t5;
  };
  var $t = class {
    static groupObjects() {
      let t5, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: i4, asTree: n4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      n4 && null == i4 && (i4 = 0);
      const r4 = [];
      return Array.from(e4).forEach((e5) => {
        var o4;
        if (t5) {
          var s4, a4, l4;
          if (null !== (s4 = e5.canBeGrouped) && void 0 !== s4 && s4.call(e5, i4) && null !== (a4 = (l4 = t5[t5.length - 1]).canBeGroupedWith) && void 0 !== a4 && a4.call(l4, e5, i4)) return void t5.push(e5);
          r4.push(new this(t5, { depth: i4, asTree: n4 })), t5 = null;
        }
        null !== (o4 = e5.canBeGrouped) && void 0 !== o4 && o4.call(e5, i4) ? t5 = [e5] : r4.push(e5);
      }), t5 && r4.push(new this(t5, { depth: i4, asTree: n4 })), r4;
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: e4, asTree: i4 } = arguments.length > 1 ? arguments[1] : void 0;
      this.objects = t5, i4 && (this.depth = e4, this.objects = this.constructor.groupObjects(this.objects, { asTree: i4, depth: this.depth + 1 }));
    }
    getObjects() {
      return this.objects;
    }
    getDepth() {
      return this.depth;
    }
    getCacheKey() {
      const t5 = ["objectGroup"];
      return Array.from(this.getObjects()).forEach((e4) => {
        t5.push(e4.getCacheKey());
      }), t5.join("/");
    }
  };
  var Zt = class extends q3 {
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = {}, Array.from(t5).forEach((t6) => {
        const e4 = JSON.stringify(t6);
        null == this.objects[e4] && (this.objects[e4] = t6);
      });
    }
    find(t5) {
      const e4 = JSON.stringify(t5);
      return this.objects[e4];
    }
  };
  var Qt = class {
    constructor(t5) {
      this.reset(t5);
    }
    add(t5) {
      const e4 = te2(t5);
      this.elements[e4] = t5;
    }
    remove(t5) {
      const e4 = te2(t5), i4 = this.elements[e4];
      if (i4) return delete this.elements[e4], i4;
    }
    reset() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      return this.elements = {}, Array.from(t5).forEach((t6) => {
        this.add(t6);
      }), t5;
    }
  };
  var te2 = (t5) => t5.dataset.trixStoreKey;
  var ee4 = class extends q3 {
    isPerforming() {
      return true === this.performing;
    }
    hasPerformed() {
      return true === this.performed;
    }
    hasSucceeded() {
      return this.performed && this.succeeded;
    }
    hasFailed() {
      return this.performed && !this.succeeded;
    }
    getPromise() {
      return this.promise || (this.promise = new Promise((t5, e4) => (this.performing = true, this.perform((i4, n4) => {
        this.succeeded = i4, this.performing = false, this.performed = true, this.succeeded ? t5(n4) : e4(n4);
      })))), this.promise;
    }
    perform(t5) {
      return t5(false);
    }
    release() {
      var t5, e4;
      null === (t5 = this.promise) || void 0 === t5 || null === (e4 = t5.cancel) || void 0 === e4 || e4.call(t5), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
    }
  };
  ee4.proxyMethod("getPromise().then"), ee4.proxyMethod("getPromise().catch");
  var ie2 = class extends q3 {
    constructor(t5) {
      let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.object = t5, this.options = e4, this.childViews = [], this.rootView = this;
    }
    getNodes() {
      return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t5) => t5.cloneNode(true));
    }
    invalidate() {
      var t5;
      return this.nodes = null, this.childViews = [], null === (t5 = this.parentView) || void 0 === t5 ? void 0 : t5.invalidate();
    }
    invalidateViewForObject(t5) {
      var e4;
      return null === (e4 = this.findViewForObject(t5)) || void 0 === e4 ? void 0 : e4.invalidate();
    }
    findOrCreateCachedChildView(t5, e4, i4) {
      let n4 = this.getCachedViewForObject(e4);
      return n4 ? this.recordChildView(n4) : (n4 = this.createChildView(...arguments), this.cacheViewForObject(n4, e4)), n4;
    }
    createChildView(t5, e4) {
      let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      e4 instanceof $t && (i4.viewClass = t5, t5 = ne2);
      const n4 = new t5(e4, i4);
      return this.recordChildView(n4);
    }
    recordChildView(t5) {
      return t5.parentView = this, t5.rootView = this.rootView, this.childViews.push(t5), t5;
    }
    getAllChildViews() {
      let t5 = [];
      return this.childViews.forEach((e4) => {
        t5.push(e4), t5 = t5.concat(e4.getAllChildViews());
      }), t5;
    }
    findElement() {
      return this.findElementForObject(this.object);
    }
    findElementForObject(t5) {
      const e4 = null == t5 ? void 0 : t5.id;
      if (e4) return this.rootView.element.querySelector("[data-trix-id='".concat(e4, "']"));
    }
    findViewForObject(t5) {
      for (const e4 of this.getAllChildViews()) if (e4.object === t5) return e4;
    }
    getViewCache() {
      return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : void 0;
    }
    isViewCachingEnabled() {
      return false !== this.shouldCacheViews;
    }
    enableViewCaching() {
      this.shouldCacheViews = true;
    }
    disableViewCaching() {
      this.shouldCacheViews = false;
    }
    getCachedViewForObject(t5) {
      var e4;
      return null === (e4 = this.getViewCache()) || void 0 === e4 ? void 0 : e4[t5.getCacheKey()];
    }
    cacheViewForObject(t5, e4) {
      const i4 = this.getViewCache();
      i4 && (i4[e4.getCacheKey()] = t5);
    }
    garbageCollectCachedViews() {
      const t5 = this.getViewCache();
      if (t5) {
        const e4 = this.getAllChildViews().concat(this).map((t6) => t6.object.getCacheKey());
        for (const i4 in t5) e4.includes(i4) || delete t5[i4];
      }
    }
  };
  var ne2 = class extends ie2 {
    constructor() {
      super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
    }
    getChildViews() {
      return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t5) => {
        this.findOrCreateCachedChildView(this.viewClass, t5, this.options);
      }), this.childViews;
    }
    createNodes() {
      const t5 = this.createContainerElement();
      return this.getChildViews().forEach((e4) => {
        Array.from(e4.getNodes()).forEach((e5) => {
          t5.appendChild(e5);
        });
      }), [t5];
    }
    createContainerElement() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.objectGroup.getDepth();
      return this.getChildViews()[0].createContainerElement(t5);
    }
  };
  var { entries: re2, setPrototypeOf: oe, isFrozen: se2, getPrototypeOf: ae2, getOwnPropertyDescriptor: le2 } = Object;
  var { freeze: ce2, seal: ue, create: he2 } = Object;
  var { apply: de2, construct: ge2 } = "undefined" != typeof Reflect && Reflect;
  ce2 || (ce2 = function(t5) {
    return t5;
  }), ue || (ue = function(t5) {
    return t5;
  }), de2 || (de2 = function(t5, e4, i4) {
    return t5.apply(e4, i4);
  }), ge2 || (ge2 = function(t5, e4) {
    return new t5(...e4);
  });
  var me2 = Le(Array.prototype.forEach);
  var pe2 = Le(Array.prototype.lastIndexOf);
  var fe = Le(Array.prototype.pop);
  var be2 = Le(Array.prototype.push);
  var ve = Le(Array.prototype.splice);
  var Ae = Le(String.prototype.toLowerCase);
  var ye2 = Le(String.prototype.toString);
  var xe = Le(String.prototype.match);
  var Ce = Le(String.prototype.replace);
  var Ee = Le(String.prototype.indexOf);
  var Se = Le(String.prototype.trim);
  var Re = Le(Object.prototype.hasOwnProperty);
  var ke2 = Le(RegExp.prototype.test);
  var Te = (we2 = TypeError, function() {
    for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
    return ge2(we2, e4);
  });
  var we2;
  function Le(t5) {
    return function(e4) {
      e4 instanceof RegExp && (e4.lastIndex = 0);
      for (var i4 = arguments.length, n4 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1; r4 < i4; r4++) n4[r4 - 1] = arguments[r4];
      return de2(t5, e4, n4);
    };
  }
  function De(t5, e4) {
    let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ae;
    oe && oe(t5, null);
    let n4 = e4.length;
    for (; n4--; ) {
      let r4 = e4[n4];
      if ("string" == typeof r4) {
        const t6 = i4(r4);
        t6 !== r4 && (se2(e4) || (e4[n4] = t6), r4 = t6);
      }
      t5[r4] = true;
    }
    return t5;
  }
  function Ne(t5) {
    for (let e4 = 0; e4 < t5.length; e4++) {
      Re(t5, e4) || (t5[e4] = null);
    }
    return t5;
  }
  function Ie(t5) {
    const e4 = he2(null);
    for (const [i4, n4] of re2(t5)) {
      Re(t5, i4) && (Array.isArray(n4) ? e4[i4] = Ne(n4) : n4 && "object" == typeof n4 && n4.constructor === Object ? e4[i4] = Ie(n4) : e4[i4] = n4);
    }
    return e4;
  }
  function Oe2(t5, e4) {
    for (; null !== t5; ) {
      const i4 = le2(t5, e4);
      if (i4) {
        if (i4.get) return Le(i4.get);
        if ("function" == typeof i4.value) return Le(i4.value);
      }
      t5 = ae2(t5);
    }
    return function() {
      return null;
    };
  }
  var Fe = ce2(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var Pe = ce2(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var Me = ce2(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var Be = ce2(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var _e = ce2(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var je = ce2(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var We = ce2(["#text"]);
  var Ue = ce2(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var Ve = ce2(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var ze = ce2(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var qe = ce2(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var He = ue(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var Je = ue(/<%[\w\W]*|[\w\W]*%>/gm);
  var Ke = ue(/\$\{[\w\W]*/gm);
  var Ge = ue(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var Ye = ue(/^aria-[\-\w]+$/);
  var Xe = ue(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var $e = ue(/^(?:\w+script|data):/i);
  var Ze = ue(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var Qe = ue(/^html$/i);
  var ti = ue(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var ei = Object.freeze({ __proto__: null, ARIA_ATTR: Ye, ATTR_WHITESPACE: Ze, CUSTOM_ELEMENT: ti, DATA_ATTR: Ge, DOCTYPE_NAME: Qe, ERB_EXPR: Je, IS_ALLOWED_URI: Xe, IS_SCRIPT_OR_DATA: $e, MUSTACHE_EXPR: He, TMPLIT_EXPR: Ke });
  var ii = 1;
  var ni = 3;
  var ri = 7;
  var oi = 8;
  var si = 9;
  var ai = function() {
    return "undefined" == typeof window ? null : window;
  };
  var li = function t4() {
    let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ai();
    const i4 = (e5) => t4(e5);
    if (i4.version = "3.2.5", i4.removed = [], !e4 || !e4.document || e4.document.nodeType !== si || !e4.Element) return i4.isSupported = false, i4;
    let { document: n4 } = e4;
    const r4 = n4, o4 = r4.currentScript, { DocumentFragment: s4, HTMLTemplateElement: a4, Node: l4, Element: c4, NodeFilter: u4, NamedNodeMap: h4 = e4.NamedNodeMap || e4.MozNamedAttrMap, HTMLFormElement: d4, DOMParser: g4, trustedTypes: m4 } = e4, p4 = c4.prototype, f4 = Oe2(p4, "cloneNode"), b4 = Oe2(p4, "remove"), v4 = Oe2(p4, "nextSibling"), A4 = Oe2(p4, "childNodes"), y4 = Oe2(p4, "parentNode");
    if ("function" == typeof a4) {
      const t5 = n4.createElement("template");
      t5.content && t5.content.ownerDocument && (n4 = t5.content.ownerDocument);
    }
    let x4, C4 = "";
    const { implementation: E3, createNodeIterator: S4, createDocumentFragment: R3, getElementsByTagName: k4 } = n4, { importNode: T4 } = r4;
    let w4 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    i4.isSupported = "function" == typeof re2 && "function" == typeof y4 && E3 && void 0 !== E3.createHTMLDocument;
    const { MUSTACHE_EXPR: L4, ERB_EXPR: D4, TMPLIT_EXPR: N4, DATA_ATTR: I4, ARIA_ATTR: O4, IS_SCRIPT_OR_DATA: F4, ATTR_WHITESPACE: P4, CUSTOM_ELEMENT: M4 } = ei;
    let { IS_ALLOWED_URI: B4 } = ei, _4 = null;
    const j4 = De({}, [...Fe, ...Pe, ...Me, ..._e, ...We]);
    let W3 = null;
    const U3 = De({}, [...Ue, ...Ve, ...ze, ...qe]);
    let V3 = Object.seal(he2(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), z4 = null, q4 = null, H4 = true, J3 = true, K3 = false, G3 = true, Y3 = false, X3 = true, $5 = false, Z3 = false, Q3 = false, tt2 = false, et2 = false, it2 = false, nt2 = true, rt2 = false, ot2 = true, st2 = false, at2 = {}, lt2 = null;
    const ct2 = De({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let ut2 = null;
    const ht2 = De({}, ["audio", "video", "img", "source", "image", "track"]);
    let dt2 = null;
    const gt2 = De({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mt2 = "http://www.w3.org/1998/Math/MathML", pt2 = "http://www.w3.org/2000/svg", ft2 = "http://www.w3.org/1999/xhtml";
    let bt2 = ft2, vt2 = false, At2 = null;
    const yt2 = De({}, [mt2, pt2, ft2], ye2);
    let xt2 = De({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct2 = De({}, ["annotation-xml"]);
    const Et2 = De({}, ["title", "style", "font", "a", "script"]);
    let St2 = null;
    const Rt2 = ["application/xhtml+xml", "text/html"];
    let kt2 = null, Tt2 = null;
    const wt2 = n4.createElement("form"), Lt2 = function(t5) {
      return t5 instanceof RegExp || t5 instanceof Function;
    }, Dt2 = function() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!Tt2 || Tt2 !== t5) {
        if (t5 && "object" == typeof t5 || (t5 = {}), t5 = Ie(t5), St2 = -1 === Rt2.indexOf(t5.PARSER_MEDIA_TYPE) ? "text/html" : t5.PARSER_MEDIA_TYPE, kt2 = "application/xhtml+xml" === St2 ? ye2 : Ae, _4 = Re(t5, "ALLOWED_TAGS") ? De({}, t5.ALLOWED_TAGS, kt2) : j4, W3 = Re(t5, "ALLOWED_ATTR") ? De({}, t5.ALLOWED_ATTR, kt2) : U3, At2 = Re(t5, "ALLOWED_NAMESPACES") ? De({}, t5.ALLOWED_NAMESPACES, ye2) : yt2, dt2 = Re(t5, "ADD_URI_SAFE_ATTR") ? De(Ie(gt2), t5.ADD_URI_SAFE_ATTR, kt2) : gt2, ut2 = Re(t5, "ADD_DATA_URI_TAGS") ? De(Ie(ht2), t5.ADD_DATA_URI_TAGS, kt2) : ht2, lt2 = Re(t5, "FORBID_CONTENTS") ? De({}, t5.FORBID_CONTENTS, kt2) : ct2, z4 = Re(t5, "FORBID_TAGS") ? De({}, t5.FORBID_TAGS, kt2) : {}, q4 = Re(t5, "FORBID_ATTR") ? De({}, t5.FORBID_ATTR, kt2) : {}, at2 = !!Re(t5, "USE_PROFILES") && t5.USE_PROFILES, H4 = false !== t5.ALLOW_ARIA_ATTR, J3 = false !== t5.ALLOW_DATA_ATTR, K3 = t5.ALLOW_UNKNOWN_PROTOCOLS || false, G3 = false !== t5.ALLOW_SELF_CLOSE_IN_ATTR, Y3 = t5.SAFE_FOR_TEMPLATES || false, X3 = false !== t5.SAFE_FOR_XML, $5 = t5.WHOLE_DOCUMENT || false, tt2 = t5.RETURN_DOM || false, et2 = t5.RETURN_DOM_FRAGMENT || false, it2 = t5.RETURN_TRUSTED_TYPE || false, Q3 = t5.FORCE_BODY || false, nt2 = false !== t5.SANITIZE_DOM, rt2 = t5.SANITIZE_NAMED_PROPS || false, ot2 = false !== t5.KEEP_CONTENT, st2 = t5.IN_PLACE || false, B4 = t5.ALLOWED_URI_REGEXP || Xe, bt2 = t5.NAMESPACE || ft2, xt2 = t5.MATHML_TEXT_INTEGRATION_POINTS || xt2, Ct2 = t5.HTML_INTEGRATION_POINTS || Ct2, V3 = t5.CUSTOM_ELEMENT_HANDLING || {}, t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V3.tagNameCheck = t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V3.attributeNameCheck = t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t5.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (V3.allowCustomizedBuiltInElements = t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y3 && (J3 = false), et2 && (tt2 = true), at2 && (_4 = De({}, We), W3 = [], true === at2.html && (De(_4, Fe), De(W3, Ue)), true === at2.svg && (De(_4, Pe), De(W3, Ve), De(W3, qe)), true === at2.svgFilters && (De(_4, Me), De(W3, Ve), De(W3, qe)), true === at2.mathMl && (De(_4, _e), De(W3, ze), De(W3, qe))), t5.ADD_TAGS && (_4 === j4 && (_4 = Ie(_4)), De(_4, t5.ADD_TAGS, kt2)), t5.ADD_ATTR && (W3 === U3 && (W3 = Ie(W3)), De(W3, t5.ADD_ATTR, kt2)), t5.ADD_URI_SAFE_ATTR && De(dt2, t5.ADD_URI_SAFE_ATTR, kt2), t5.FORBID_CONTENTS && (lt2 === ct2 && (lt2 = Ie(lt2)), De(lt2, t5.FORBID_CONTENTS, kt2)), ot2 && (_4["#text"] = true), $5 && De(_4, ["html", "head", "body"]), _4.table && (De(_4, ["tbody"]), delete z4.tbody), t5.TRUSTED_TYPES_POLICY) {
          if ("function" != typeof t5.TRUSTED_TYPES_POLICY.createHTML) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if ("function" != typeof t5.TRUSTED_TYPES_POLICY.createScriptURL) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          x4 = t5.TRUSTED_TYPES_POLICY, C4 = x4.createHTML("");
        } else void 0 === x4 && (x4 = function(t6, e5) {
          if ("object" != typeof t6 || "function" != typeof t6.createPolicy) return null;
          let i5 = null;
          const n5 = "data-tt-policy-suffix";
          e5 && e5.hasAttribute(n5) && (i5 = e5.getAttribute(n5));
          const r5 = "dompurify" + (i5 ? "#" + i5 : "");
          try {
            return t6.createPolicy(r5, { createHTML: (t7) => t7, createScriptURL: (t7) => t7 });
          } catch (t7) {
            return console.warn("TrustedTypes policy " + r5 + " could not be created."), null;
          }
        }(m4, o4)), null !== x4 && "string" == typeof C4 && (C4 = x4.createHTML(""));
        ce2 && ce2(t5), Tt2 = t5;
      }
    }, Nt2 = De({}, [...Pe, ...Me, ...Be]), It2 = De({}, [..._e, ...je]), Ot2 = function(t5) {
      be2(i4.removed, { element: t5 });
      try {
        y4(t5).removeChild(t5);
      } catch (e5) {
        b4(t5);
      }
    }, Ft2 = function(t5, e5) {
      try {
        be2(i4.removed, { attribute: e5.getAttributeNode(t5), from: e5 });
      } catch (t6) {
        be2(i4.removed, { attribute: null, from: e5 });
      }
      if (e5.removeAttribute(t5), "is" === t5) if (tt2 || et2) try {
        Ot2(e5);
      } catch (t6) {
      }
      else try {
        e5.setAttribute(t5, "");
      } catch (t6) {
      }
    }, Pt2 = function(t5) {
      let e5 = null, i5 = null;
      if (Q3) t5 = "<remove></remove>" + t5;
      else {
        const e6 = xe(t5, /^[\r\n\t ]+/);
        i5 = e6 && e6[0];
      }
      "application/xhtml+xml" === St2 && bt2 === ft2 && (t5 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t5 + "</body></html>");
      const r5 = x4 ? x4.createHTML(t5) : t5;
      if (bt2 === ft2) try {
        e5 = new g4().parseFromString(r5, St2);
      } catch (t6) {
      }
      if (!e5 || !e5.documentElement) {
        e5 = E3.createDocument(bt2, "template", null);
        try {
          e5.documentElement.innerHTML = vt2 ? C4 : r5;
        } catch (t6) {
        }
      }
      const o5 = e5.body || e5.documentElement;
      return t5 && i5 && o5.insertBefore(n4.createTextNode(i5), o5.childNodes[0] || null), bt2 === ft2 ? k4.call(e5, $5 ? "html" : "body")[0] : $5 ? e5.documentElement : o5;
    }, Mt2 = function(t5) {
      return S4.call(t5.ownerDocument || t5, t5, u4.SHOW_ELEMENT | u4.SHOW_COMMENT | u4.SHOW_TEXT | u4.SHOW_PROCESSING_INSTRUCTION | u4.SHOW_CDATA_SECTION, null);
    }, Bt2 = function(t5) {
      return t5 instanceof d4 && ("string" != typeof t5.nodeName || "string" != typeof t5.textContent || "function" != typeof t5.removeChild || !(t5.attributes instanceof h4) || "function" != typeof t5.removeAttribute || "function" != typeof t5.setAttribute || "string" != typeof t5.namespaceURI || "function" != typeof t5.insertBefore || "function" != typeof t5.hasChildNodes);
    }, _t2 = function(t5) {
      return "function" == typeof l4 && t5 instanceof l4;
    };
    function jt2(t5, e5, n5) {
      me2(t5, (t6) => {
        t6.call(i4, e5, n5, Tt2);
      });
    }
    const Wt2 = function(t5) {
      let e5 = null;
      if (jt2(w4.beforeSanitizeElements, t5, null), Bt2(t5)) return Ot2(t5), true;
      const n5 = kt2(t5.nodeName);
      if (jt2(w4.uponSanitizeElement, t5, { tagName: n5, allowedTags: _4 }), t5.hasChildNodes() && !_t2(t5.firstElementChild) && ke2(/<[/\w!]/g, t5.innerHTML) && ke2(/<[/\w!]/g, t5.textContent)) return Ot2(t5), true;
      if (t5.nodeType === ri) return Ot2(t5), true;
      if (X3 && t5.nodeType === oi && ke2(/<[/\w]/g, t5.data)) return Ot2(t5), true;
      if (!_4[n5] || z4[n5]) {
        if (!z4[n5] && Vt2(n5)) {
          if (V3.tagNameCheck instanceof RegExp && ke2(V3.tagNameCheck, n5)) return false;
          if (V3.tagNameCheck instanceof Function && V3.tagNameCheck(n5)) return false;
        }
        if (ot2 && !lt2[n5]) {
          const e6 = y4(t5) || t5.parentNode, i5 = A4(t5) || t5.childNodes;
          if (i5 && e6) {
            for (let n6 = i5.length - 1; n6 >= 0; --n6) {
              const r5 = f4(i5[n6], true);
              r5.__removalCount = (t5.__removalCount || 0) + 1, e6.insertBefore(r5, v4(t5));
            }
          }
        }
        return Ot2(t5), true;
      }
      return t5 instanceof c4 && !function(t6) {
        let e6 = y4(t6);
        e6 && e6.tagName || (e6 = { namespaceURI: bt2, tagName: "template" });
        const i5 = Ae(t6.tagName), n6 = Ae(e6.tagName);
        return !!At2[t6.namespaceURI] && (t6.namespaceURI === pt2 ? e6.namespaceURI === ft2 ? "svg" === i5 : e6.namespaceURI === mt2 ? "svg" === i5 && ("annotation-xml" === n6 || xt2[n6]) : Boolean(Nt2[i5]) : t6.namespaceURI === mt2 ? e6.namespaceURI === ft2 ? "math" === i5 : e6.namespaceURI === pt2 ? "math" === i5 && Ct2[n6] : Boolean(It2[i5]) : t6.namespaceURI === ft2 ? !(e6.namespaceURI === pt2 && !Ct2[n6]) && !(e6.namespaceURI === mt2 && !xt2[n6]) && !It2[i5] && (Et2[i5] || !Nt2[i5]) : !("application/xhtml+xml" !== St2 || !At2[t6.namespaceURI]));
      }(t5) ? (Ot2(t5), true) : "noscript" !== n5 && "noembed" !== n5 && "noframes" !== n5 || !ke2(/<\/no(script|embed|frames)/i, t5.innerHTML) ? (Y3 && t5.nodeType === ni && (e5 = t5.textContent, me2([L4, D4, N4], (t6) => {
        e5 = Ce(e5, t6, " ");
      }), t5.textContent !== e5 && (be2(i4.removed, { element: t5.cloneNode() }), t5.textContent = e5)), jt2(w4.afterSanitizeElements, t5, null), false) : (Ot2(t5), true);
    }, Ut2 = function(t5, e5, i5) {
      if (nt2 && ("id" === e5 || "name" === e5) && (i5 in n4 || i5 in wt2)) return false;
      if (J3 && !q4[e5] && ke2(I4, e5)) ;
      else if (H4 && ke2(O4, e5)) ;
      else if (!W3[e5] || q4[e5]) {
        if (!(Vt2(t5) && (V3.tagNameCheck instanceof RegExp && ke2(V3.tagNameCheck, t5) || V3.tagNameCheck instanceof Function && V3.tagNameCheck(t5)) && (V3.attributeNameCheck instanceof RegExp && ke2(V3.attributeNameCheck, e5) || V3.attributeNameCheck instanceof Function && V3.attributeNameCheck(e5)) || "is" === e5 && V3.allowCustomizedBuiltInElements && (V3.tagNameCheck instanceof RegExp && ke2(V3.tagNameCheck, i5) || V3.tagNameCheck instanceof Function && V3.tagNameCheck(i5)))) return false;
      } else if (dt2[e5]) ;
      else if (ke2(B4, Ce(i5, P4, ""))) ;
      else if ("src" !== e5 && "xlink:href" !== e5 && "href" !== e5 || "script" === t5 || 0 !== Ee(i5, "data:") || !ut2[t5]) {
        if (K3 && !ke2(F4, Ce(i5, P4, ""))) ;
        else if (i5) return false;
      } else ;
      return true;
    }, Vt2 = function(t5) {
      return "annotation-xml" !== t5 && xe(t5, M4);
    }, zt2 = function(t5) {
      jt2(w4.beforeSanitizeAttributes, t5, null);
      const { attributes: e5 } = t5;
      if (!e5 || Bt2(t5)) return;
      const n5 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: W3, forceKeepAttr: void 0 };
      let r5 = e5.length;
      for (; r5--; ) {
        const o5 = e5[r5], { name: s5, namespaceURI: a5, value: l5 } = o5, c5 = kt2(s5);
        let u5 = "value" === s5 ? l5 : Se(l5);
        if (n5.attrName = c5, n5.attrValue = u5, n5.keepAttr = true, n5.forceKeepAttr = void 0, jt2(w4.uponSanitizeAttribute, t5, n5), u5 = n5.attrValue, !rt2 || "id" !== c5 && "name" !== c5 || (Ft2(s5, t5), u5 = "user-content-" + u5), X3 && ke2(/((--!?|])>)|<\/(style|title)/i, u5)) {
          Ft2(s5, t5);
          continue;
        }
        if (n5.forceKeepAttr) continue;
        if (Ft2(s5, t5), !n5.keepAttr) continue;
        if (!G3 && ke2(/\/>/i, u5)) {
          Ft2(s5, t5);
          continue;
        }
        Y3 && me2([L4, D4, N4], (t6) => {
          u5 = Ce(u5, t6, " ");
        });
        const h5 = kt2(t5.nodeName);
        if (Ut2(h5, c5, u5)) {
          if (x4 && "object" == typeof m4 && "function" == typeof m4.getAttributeType) if (a5) ;
          else switch (m4.getAttributeType(h5, c5)) {
            case "TrustedHTML":
              u5 = x4.createHTML(u5);
              break;
            case "TrustedScriptURL":
              u5 = x4.createScriptURL(u5);
          }
          try {
            a5 ? t5.setAttributeNS(a5, s5, u5) : t5.setAttribute(s5, u5), Bt2(t5) ? Ot2(t5) : fe(i4.removed);
          } catch (t6) {
          }
        }
      }
      jt2(w4.afterSanitizeAttributes, t5, null);
    }, qt2 = function t5(e5) {
      let i5 = null;
      const n5 = Mt2(e5);
      for (jt2(w4.beforeSanitizeShadowDOM, e5, null); i5 = n5.nextNode(); ) jt2(w4.uponSanitizeShadowNode, i5, null), Wt2(i5), zt2(i5), i5.content instanceof s4 && t5(i5.content);
      jt2(w4.afterSanitizeShadowDOM, e5, null);
    };
    return i4.sanitize = function(t5) {
      let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n5 = null, o5 = null, a5 = null, c5 = null;
      if (vt2 = !t5, vt2 && (t5 = "<!-->"), "string" != typeof t5 && !_t2(t5)) {
        if ("function" != typeof t5.toString) throw Te("toString is not a function");
        if ("string" != typeof (t5 = t5.toString())) throw Te("dirty is not a string, aborting");
      }
      if (!i4.isSupported) return t5;
      if (Z3 || Dt2(e5), i4.removed = [], "string" == typeof t5 && (st2 = false), st2) {
        if (t5.nodeName) {
          const e6 = kt2(t5.nodeName);
          if (!_4[e6] || z4[e6]) throw Te("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (t5 instanceof l4) n5 = Pt2("<!---->"), o5 = n5.ownerDocument.importNode(t5, true), o5.nodeType === ii && "BODY" === o5.nodeName || "HTML" === o5.nodeName ? n5 = o5 : n5.appendChild(o5);
      else {
        if (!tt2 && !Y3 && !$5 && -1 === t5.indexOf("<")) return x4 && it2 ? x4.createHTML(t5) : t5;
        if (n5 = Pt2(t5), !n5) return tt2 ? null : it2 ? C4 : "";
      }
      n5 && Q3 && Ot2(n5.firstChild);
      const u5 = Mt2(st2 ? t5 : n5);
      for (; a5 = u5.nextNode(); ) Wt2(a5), zt2(a5), a5.content instanceof s4 && qt2(a5.content);
      if (st2) return t5;
      if (tt2) {
        if (et2) for (c5 = R3.call(n5.ownerDocument); n5.firstChild; ) c5.appendChild(n5.firstChild);
        else c5 = n5;
        return (W3.shadowroot || W3.shadowrootmode) && (c5 = T4.call(r4, c5, true)), c5;
      }
      let h5 = $5 ? n5.outerHTML : n5.innerHTML;
      return $5 && _4["!doctype"] && n5.ownerDocument && n5.ownerDocument.doctype && n5.ownerDocument.doctype.name && ke2(Qe, n5.ownerDocument.doctype.name) && (h5 = "<!DOCTYPE " + n5.ownerDocument.doctype.name + ">\n" + h5), Y3 && me2([L4, D4, N4], (t6) => {
        h5 = Ce(h5, t6, " ");
      }), x4 && it2 ? x4.createHTML(h5) : h5;
    }, i4.setConfig = function() {
      Dt2(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Z3 = true;
    }, i4.clearConfig = function() {
      Tt2 = null, Z3 = false;
    }, i4.isValidAttribute = function(t5, e5, i5) {
      Tt2 || Dt2({});
      const n5 = kt2(t5), r5 = kt2(e5);
      return Ut2(n5, r5, i5);
    }, i4.addHook = function(t5, e5) {
      "function" == typeof e5 && be2(w4[t5], e5);
    }, i4.removeHook = function(t5, e5) {
      if (void 0 !== e5) {
        const i5 = pe2(w4[t5], e5);
        return -1 === i5 ? void 0 : ve(w4[t5], i5, 1)[0];
      }
      return fe(w4[t5]);
    }, i4.removeHooks = function(t5) {
      w4[t5] = [];
    }, i4.removeAllHooks = function() {
      w4 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    }, i4;
  }();
  li.addHook("uponSanitizeAttribute", function(t5, e4) {
    /^data-trix-/.test(e4.attrName) && (e4.forceKeepAttr = true);
  });
  var ci = "style href src width height language class".split(" ");
  var ui = "javascript:".split(" ");
  var hi = "script iframe form noscript".split(" ");
  var di = class extends q3 {
    static setHTML(t5, e4, i4) {
      const n4 = new this(e4, i4).sanitize(), r4 = n4.getHTML ? n4.getHTML() : n4.outerHTML;
      t5.innerHTML = r4;
    }
    static sanitize(t5, e4) {
      const i4 = new this(t5, e4);
      return i4.sanitize(), i4;
    }
    constructor(t5) {
      let { allowedAttributes: e4, forbiddenProtocols: i4, forbiddenElements: n4, purifyOptions: r4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.allowedAttributes = e4 || ci, this.forbiddenProtocols = i4 || ui, this.forbiddenElements = n4 || hi, this.purifyOptions = r4 || {}, this.body = gi(t5);
    }
    sanitize() {
      this.sanitizeElements(), this.normalizeListElementNesting();
      const t5 = Object.assign({}, l3, this.purifyOptions);
      return li.setConfig(t5), this.body = li.sanitize(this.body), this.body;
    }
    getHTML() {
      return this.body.innerHTML;
    }
    getBody() {
      return this.body;
    }
    sanitizeElements() {
      const t5 = R2(this.body), e4 = [];
      for (; t5.nextNode(); ) {
        const i4 = t5.currentNode;
        switch (i4.nodeType) {
          case Node.ELEMENT_NODE:
            this.elementIsRemovable(i4) ? e4.push(i4) : this.sanitizeElement(i4);
            break;
          case Node.COMMENT_NODE:
            e4.push(i4);
        }
      }
      return e4.forEach((t6) => S3(t6)), this.body;
    }
    sanitizeElement(t5) {
      return t5.hasAttribute("href") && this.forbiddenProtocols.includes(t5.protocol) && t5.removeAttribute("href"), Array.from(t5.attributes).forEach((e4) => {
        let { name: i4 } = e4;
        this.allowedAttributes.includes(i4) || 0 === i4.indexOf("data-trix") || t5.removeAttribute(i4);
      }), t5;
    }
    normalizeListElementNesting() {
      return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t5) => {
        const e4 = t5.previousElementSibling;
        e4 && "li" === k3(e4) && e4.appendChild(t5);
      }), this.body;
    }
    elementIsRemovable(t5) {
      if ((null == t5 ? void 0 : t5.nodeType) === Node.ELEMENT_NODE) return this.elementIsForbidden(t5) || this.elementIsntSerializable(t5);
    }
    elementIsForbidden(t5) {
      return this.forbiddenElements.includes(k3(t5));
    }
    elementIsntSerializable(t5) {
      return "false" === t5.getAttribute("data-trix-serialize") && !P3(t5);
    }
  };
  var gi = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    t5 = t5.replace(/<\/html[^>]*>[^]*$/i, "</html>");
    const e4 = document.implementation.createHTMLDocument("");
    return e4.documentElement.innerHTML = t5, Array.from(e4.head.querySelectorAll("style")).forEach((t6) => {
      e4.body.appendChild(t6);
    }), e4.body;
  };
  var { css: mi } = z3;
  var pi = class extends ie2 {
    constructor() {
      super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
    }
    createContentNodes() {
      return [];
    }
    createNodes() {
      let t5;
      const e4 = t5 = T3({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i4 = this.getHref();
      return i4 && (t5 = T3({ tagName: "a", editable: false, attributes: { href: i4, tabindex: -1 } }), e4.appendChild(t5)), this.attachment.hasContent() ? di.setHTML(t5, this.attachment.getContent()) : this.createContentNodes().forEach((e5) => {
        t5.appendChild(e5);
      }), t5.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = T3({ tagName: "progress", attributes: { class: mi.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e4.appendChild(this.progressElement)), [fi("left"), e4, fi("right")];
    }
    createCaptionElement() {
      const t5 = T3({ tagName: "figcaption", className: mi.attachmentCaption }), e4 = this.attachmentPiece.getCaption();
      if (e4) t5.classList.add("".concat(mi.attachmentCaption, "--edited")), t5.textContent = e4;
      else {
        let e5, i4;
        const n4 = this.getCaptionConfig();
        if (n4.name && (e5 = this.attachment.getFilename()), n4.size && (i4 = this.attachment.getFormattedFilesize()), e5) {
          const i5 = T3({ tagName: "span", className: mi.attachmentName, textContent: e5 });
          t5.appendChild(i5);
        }
        if (i4) {
          e5 && t5.appendChild(document.createTextNode(" "));
          const n5 = T3({ tagName: "span", className: mi.attachmentSize, textContent: i4 });
          t5.appendChild(n5);
        }
      }
      return t5;
    }
    getClassName() {
      const t5 = [mi.attachment, "".concat(mi.attachment, "--").concat(this.attachment.getType())], e4 = this.attachment.getExtension();
      return e4 && t5.push("".concat(mi.attachment, "--").concat(e4)), t5.join(" ");
    }
    getData() {
      const t5 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e4 } = this.attachmentPiece;
      return e4.isEmpty() || (t5.trixAttributes = JSON.stringify(e4)), this.attachment.isPending() && (t5.trixSerialize = false), t5;
    }
    getHref() {
      if (!bi(this.attachment.getContent(), "a")) return this.attachment.getHref();
    }
    getCaptionConfig() {
      var t5;
      const e4 = this.attachment.getType(), n4 = kt(null === (t5 = i3[e4]) || void 0 === t5 ? void 0 : t5.caption);
      return "file" === e4 && (n4.name = true), n4;
    }
    findProgressElement() {
      var t5;
      return null === (t5 = this.findElement()) || void 0 === t5 ? void 0 : t5.querySelector("progress");
    }
    attachmentDidChangeUploadProgress() {
      const t5 = this.attachment.getUploadProgress(), e4 = this.findProgressElement();
      e4 && (e4.value = t5);
    }
  };
  var fi = (t5) => T3({ tagName: "span", textContent: d3, data: { trixCursorTarget: t5, trixSerialize: false } });
  var bi = function(t5, e4) {
    const i4 = T3("div");
    return di.setHTML(i4, t5 || ""), i4.querySelector(e4);
  };
  var vi = class extends pi {
    constructor() {
      super(...arguments), this.attachment.previewDelegate = this;
    }
    createContentNodes() {
      return this.image = T3({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
    }
    createCaptionElement() {
      const t5 = super.createCaptionElement(...arguments);
      return t5.textContent || t5.setAttribute("data-trix-placeholder", c3.captionPlaceholder), t5;
    }
    refresh(t5) {
      var e4;
      t5 || (t5 = null === (e4 = this.findElement()) || void 0 === e4 ? void 0 : e4.querySelector("img"));
      if (t5) return this.updateAttributesForImage(t5);
    }
    updateAttributesForImage(t5) {
      const e4 = this.attachment.getURL(), i4 = this.attachment.getPreviewURL();
      if (t5.src = i4 || e4, i4 === e4) t5.removeAttribute("data-trix-serialized-attributes");
      else {
        const i5 = JSON.stringify({ src: e4 });
        t5.setAttribute("data-trix-serialized-attributes", i5);
      }
      const n4 = this.attachment.getWidth(), r4 = this.attachment.getHeight();
      null != n4 && (t5.width = n4), null != r4 && (t5.height = r4);
      const o4 = ["imageElement", this.attachment.id, t5.src, t5.width, t5.height].join("/");
      t5.dataset.trixStoreKey = o4;
    }
    attachmentDidChangeAttributes() {
      return this.refresh(this.image), this.refresh();
    }
  };
  var Ai = class extends ie2 {
    constructor() {
      super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
    }
    createNodes() {
      let t5 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
      const e4 = this.createElement();
      if (e4) {
        const i4 = function(t6) {
          for (; null !== (e5 = t6) && void 0 !== e5 && e5.firstElementChild; ) {
            var e5;
            t6 = t6.firstElementChild;
          }
          return t6;
        }(e4);
        Array.from(t5).forEach((t6) => {
          i4.appendChild(t6);
        }), t5 = [e4];
      }
      return t5;
    }
    createAttachmentNodes() {
      const t5 = this.attachment.isPreviewable() ? vi : pi;
      return this.createChildView(t5, this.piece.attachment, { piece: this.piece }).getNodes();
    }
    createStringNodes() {
      var t5;
      if (null !== (t5 = this.textConfig) && void 0 !== t5 && t5.plaintext) return [document.createTextNode(this.string)];
      {
        const t6 = [], e4 = this.string.split("\n");
        for (let i4 = 0; i4 < e4.length; i4++) {
          const n4 = e4[i4];
          if (i4 > 0) {
            const e5 = T3("br");
            t6.push(e5);
          }
          if (n4.length) {
            const e5 = document.createTextNode(this.preserveSpaces(n4));
            t6.push(e5);
          }
        }
        return t6;
      }
    }
    createElement() {
      let t5, e4, i4;
      const n4 = {};
      for (e4 in this.attributes) {
        i4 = this.attributes[e4];
        const o4 = ft(e4);
        if (o4) {
          if (o4.tagName) {
            var r4;
            const e5 = T3(o4.tagName);
            r4 ? (r4.appendChild(e5), r4 = e5) : t5 = r4 = e5;
          }
          if (o4.styleProperty && (n4[o4.styleProperty] = i4), o4.style) for (e4 in o4.style) i4 = o4.style[e4], n4[e4] = i4;
        }
      }
      if (Object.keys(n4).length) for (e4 in t5 || (t5 = T3("span")), n4) i4 = n4[e4], t5.style[e4] = i4;
      return t5;
    }
    createContainerElement() {
      for (const t5 in this.attributes) {
        const e4 = this.attributes[t5], i4 = ft(t5);
        if (i4 && i4.groupTagName) {
          const n4 = {};
          return n4[t5] = e4, T3(i4.groupTagName, n4);
        }
      }
    }
    preserveSpaces(t5) {
      return this.context.isLast && (t5 = t5.replace(/\ $/, g3)), t5 = t5.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(g3, " $2")).replace(/\ {2}/g, "".concat(g3, " ")).replace(/\ {2}/g, " ".concat(g3)), (this.context.isFirst || this.context.followsWhitespace) && (t5 = t5.replace(/^\ /, g3)), t5;
    }
  };
  var yi = class extends ie2 {
    constructor() {
      super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
    }
    createNodes() {
      const t5 = [], e4 = $t.groupObjects(this.getPieces()), i4 = e4.length - 1;
      for (let r4 = 0; r4 < e4.length; r4++) {
        const o4 = e4[r4], s4 = {};
        0 === r4 && (s4.isFirst = true), r4 === i4 && (s4.isLast = true), xi(n4) && (s4.followsWhitespace = true);
        const a4 = this.findOrCreateCachedChildView(Ai, o4, { textConfig: this.textConfig, context: s4 });
        t5.push(...Array.from(a4.getNodes() || []));
        var n4 = o4;
      }
      return t5;
    }
    getPieces() {
      return Array.from(this.text.getPieces()).filter((t5) => !t5.hasAttribute("blockBreak"));
    }
  };
  var xi = (t5) => /\s$/.test(null == t5 ? void 0 : t5.toString());
  var { css: Ci } = z3;
  var Ei = class extends ie2 {
    constructor() {
      super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
    }
    createNodes() {
      const t5 = [document.createComment("block")];
      if (this.block.isEmpty()) t5.push(T3("br"));
      else {
        var e4;
        const i4 = null === (e4 = mt(this.block.getLastAttribute())) || void 0 === e4 ? void 0 : e4.text, n4 = this.findOrCreateCachedChildView(yi, this.block.text, { textConfig: i4 });
        t5.push(...Array.from(n4.getNodes() || [])), this.shouldAddExtraNewlineElement() && t5.push(T3("br"));
      }
      if (this.attributes.length) return t5;
      {
        let e5;
        const { tagName: i4 } = n3.default;
        this.block.isRTL() && (e5 = { dir: "rtl" });
        const r4 = T3({ tagName: i4, attributes: e5 });
        return t5.forEach((t6) => r4.appendChild(t6)), [r4];
      }
    }
    createContainerElement(t5) {
      const e4 = {};
      let i4;
      const n4 = this.attributes[t5], { tagName: r4, htmlAttributes: o4 = [] } = mt(n4);
      if (0 === t5 && this.block.isRTL() && Object.assign(e4, { dir: "rtl" }), "attachmentGallery" === n4) {
        const t6 = this.block.getBlockBreakPosition();
        i4 = "".concat(Ci.attachmentGallery, " ").concat(Ci.attachmentGallery, "--").concat(t6);
      }
      return Object.entries(this.block.htmlAttributes).forEach((t6) => {
        let [i5, n5] = t6;
        o4.includes(i5) && (e4[i5] = n5);
      }), T3({ tagName: r4, className: i4, attributes: e4 });
    }
    shouldAddExtraNewlineElement() {
      return /\n\n$/.test(this.block.toString());
    }
  };
  var Si = class extends ie2 {
    static render(t5) {
      const e4 = T3("div"), i4 = new this(t5, { element: e4 });
      return i4.render(), i4.sync(), e4;
    }
    constructor() {
      super(...arguments), this.element = this.options.element, this.elementStore = new Qt(), this.setDocument(this.object);
    }
    setDocument(t5) {
      t5.isEqualTo(this.document) || (this.document = this.object = t5);
    }
    render() {
      if (this.childViews = [], this.shadowElement = T3("div"), !this.document.isEmpty()) {
        const t5 = $t.groupObjects(this.document.getBlocks(), { asTree: true });
        Array.from(t5).forEach((t6) => {
          const e4 = this.findOrCreateCachedChildView(Ei, t6);
          Array.from(e4.getNodes()).map((t7) => this.shadowElement.appendChild(t7));
        });
      }
    }
    isSynced() {
      return ki(this.shadowElement, this.element);
    }
    sync() {
      const t5 = this.createDocumentFragmentForSync();
      for (; this.element.lastChild; ) this.element.removeChild(this.element.lastChild);
      return this.element.appendChild(t5), this.didSync();
    }
    didSync() {
      return this.elementStore.reset(Ri(this.element)), Rt(() => this.garbageCollectCachedViews());
    }
    createDocumentFragmentForSync() {
      const t5 = document.createDocumentFragment();
      return Array.from(this.shadowElement.childNodes).forEach((e4) => {
        t5.appendChild(e4.cloneNode(true));
      }), Array.from(Ri(t5)).forEach((t6) => {
        const e4 = this.elementStore.remove(t6);
        e4 && t6.parentNode.replaceChild(e4, t6);
      }), t5;
    }
  };
  var Ri = (t5) => t5.querySelectorAll("[data-trix-store-key]");
  var ki = (t5, e4) => Ti(t5.innerHTML) === Ti(e4.innerHTML);
  var Ti = (t5) => t5.replace(/&nbsp;/g, " ");
  function wi(t5) {
    var e4, i4;
    function n4(e5, i5) {
      try {
        var o4 = t5[e5](i5), s4 = o4.value, a4 = s4 instanceof Li;
        Promise.resolve(a4 ? s4.v : s4).then(function(i6) {
          if (a4) {
            var l4 = "return" === e5 ? "return" : "next";
            if (!s4.k || i6.done) return n4(l4, i6);
            i6 = t5[l4](i6).value;
          }
          r4(o4.done ? "return" : "normal", i6);
        }, function(t6) {
          n4("throw", t6);
        });
      } catch (t6) {
        r4("throw", t6);
      }
    }
    function r4(t6, r5) {
      switch (t6) {
        case "return":
          e4.resolve({ value: r5, done: true });
          break;
        case "throw":
          e4.reject(r5);
          break;
        default:
          e4.resolve({ value: r5, done: false });
      }
      (e4 = e4.next) ? n4(e4.key, e4.arg) : i4 = null;
    }
    this._invoke = function(t6, r5) {
      return new Promise(function(o4, s4) {
        var a4 = { key: t6, arg: r5, resolve: o4, reject: s4, next: null };
        i4 ? i4 = i4.next = a4 : (e4 = i4 = a4, n4(t6, r5));
      });
    }, "function" != typeof t5.return && (this.return = void 0);
  }
  function Li(t5, e4) {
    this.v = t5, this.k = e4;
  }
  function Di(t5, e4, i4) {
    return (e4 = Ni(e4)) in t5 ? Object.defineProperty(t5, e4, { value: i4, enumerable: true, configurable: true, writable: true }) : t5[e4] = i4, t5;
  }
  function Ni(t5) {
    var e4 = function(t6, e5) {
      if ("object" != typeof t6 || null === t6) return t6;
      var i4 = t6[Symbol.toPrimitive];
      if (void 0 !== i4) {
        var n4 = i4.call(t6, e5 || "default");
        if ("object" != typeof n4) return n4;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === e5 ? String : Number)(t6);
    }(t5, "string");
    return "symbol" == typeof e4 ? e4 : String(e4);
  }
  wi.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
    return this;
  }, wi.prototype.next = function(t5) {
    return this._invoke("next", t5);
  }, wi.prototype.throw = function(t5) {
    return this._invoke("throw", t5);
  }, wi.prototype.return = function(t5) {
    return this._invoke("return", t5);
  };
  function Ii(t5, e4) {
    return Pi(t5, Fi(t5, e4, "get"));
  }
  function Oi(t5, e4, i4) {
    return Mi(t5, Fi(t5, e4, "set"), i4), i4;
  }
  function Fi(t5, e4, i4) {
    if (!e4.has(t5)) throw new TypeError("attempted to " + i4 + " private field on non-instance");
    return e4.get(t5);
  }
  function Pi(t5, e4) {
    return e4.get ? e4.get.call(t5) : e4.value;
  }
  function Mi(t5, e4, i4) {
    if (e4.set) e4.set.call(t5, i4);
    else {
      if (!e4.writable) throw new TypeError("attempted to set read only private field");
      e4.value = i4;
    }
  }
  function Bi(t5, e4, i4) {
    if (!e4.has(t5)) throw new TypeError("attempted to get private field on non-instance");
    return i4;
  }
  function _i(t5, e4) {
    if (e4.has(t5)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function ji(t5, e4, i4) {
    _i(t5, e4), e4.set(t5, i4);
  }
  var Wi = class extends rt {
    static registerType(t5, e4) {
      e4.type = t5, this.types[t5] = e4;
    }
    static fromJSON(t5) {
      const e4 = this.types[t5.type];
      if (e4) return e4.fromJSON(t5);
    }
    constructor(t5) {
      let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.attributes = Ht.box(e4);
    }
    copyWithAttributes(t5) {
      return new this.constructor(this.getValue(), t5);
    }
    copyWithAdditionalAttributes(t5) {
      return this.copyWithAttributes(this.attributes.merge(t5));
    }
    copyWithoutAttribute(t5) {
      return this.copyWithAttributes(this.attributes.remove(t5));
    }
    copy() {
      return this.copyWithAttributes(this.attributes);
    }
    getAttribute(t5) {
      return this.attributes.get(t5);
    }
    getAttributesHash() {
      return this.attributes;
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    hasAttribute(t5) {
      return this.attributes.has(t5);
    }
    hasSameStringValueAsPiece(t5) {
      return t5 && this.toString() === t5.toString();
    }
    hasSameAttributesAsPiece(t5) {
      return t5 && (this.attributes === t5.attributes || this.attributes.isEqualTo(t5.attributes));
    }
    isBlockBreak() {
      return false;
    }
    isEqualTo(t5) {
      return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t5) && this.hasSameStringValueAsPiece(t5) && this.hasSameAttributesAsPiece(t5);
    }
    isEmpty() {
      return 0 === this.length;
    }
    isSerializable() {
      return true;
    }
    toJSON() {
      return { type: this.constructor.type, attributes: this.getAttributes() };
    }
    contentsForInspection() {
      return { type: this.constructor.type, attributes: this.attributes.inspect() };
    }
    canBeGrouped() {
      return this.hasAttribute("href");
    }
    canBeGroupedWith(t5) {
      return this.getAttribute("href") === t5.getAttribute("href");
    }
    getLength() {
      return this.length;
    }
    canBeConsolidatedWith(t5) {
      return false;
    }
  };
  Di(Wi, "types", {});
  var Ui = class extends ee4 {
    constructor(t5) {
      super(...arguments), this.url = t5;
    }
    perform(t5) {
      const e4 = new Image();
      e4.onload = () => (e4.width = this.width = e4.naturalWidth, e4.height = this.height = e4.naturalHeight, t5(true, e4)), e4.onerror = () => t5(false), e4.src = this.url;
    }
  };
  var Vi = class _Vi extends rt {
    static attachmentForFile(t5) {
      const e4 = new this(this.attributesForFile(t5));
      return e4.setFile(t5), e4;
    }
    static attributesForFile(t5) {
      return new Ht({ filename: t5.name, filesize: t5.size, contentType: t5.type });
    }
    static fromJSON(t5) {
      return new this(t5);
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(t5), this.releaseFile = this.releaseFile.bind(this), this.attributes = Ht.box(t5), this.didChangeAttributes();
    }
    getAttribute(t5) {
      return this.attributes.get(t5);
    }
    hasAttribute(t5) {
      return this.attributes.has(t5);
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    setAttributes() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const e4 = this.attributes.merge(t5);
      var i4, n4, r4, o4;
      if (!this.attributes.isEqualTo(e4)) return this.attributes = e4, this.didChangeAttributes(), null === (i4 = this.previewDelegate) || void 0 === i4 || null === (n4 = i4.attachmentDidChangeAttributes) || void 0 === n4 || n4.call(i4, this), null === (r4 = this.delegate) || void 0 === r4 || null === (o4 = r4.attachmentDidChangeAttributes) || void 0 === o4 ? void 0 : o4.call(r4, this);
    }
    didChangeAttributes() {
      if (this.isPreviewable()) return this.preloadURL();
    }
    isPending() {
      return null != this.file && !(this.getURL() || this.getHref());
    }
    isPreviewable() {
      return this.attributes.has("previewable") ? this.attributes.get("previewable") : _Vi.previewablePattern.test(this.getContentType());
    }
    getType() {
      return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
    }
    getURL() {
      return this.attributes.get("url");
    }
    getHref() {
      return this.attributes.get("href");
    }
    getFilename() {
      return this.attributes.get("filename") || "";
    }
    getFilesize() {
      return this.attributes.get("filesize");
    }
    getFormattedFilesize() {
      const t5 = this.attributes.get("filesize");
      return "number" == typeof t5 ? h3.formatter(t5) : "";
    }
    getExtension() {
      var t5;
      return null === (t5 = this.getFilename().match(/\.(\w+)$/)) || void 0 === t5 ? void 0 : t5[1].toLowerCase();
    }
    getContentType() {
      return this.attributes.get("contentType");
    }
    hasContent() {
      return this.attributes.has("content");
    }
    getContent() {
      return this.attributes.get("content");
    }
    getWidth() {
      return this.attributes.get("width");
    }
    getHeight() {
      return this.attributes.get("height");
    }
    getFile() {
      return this.file;
    }
    setFile(t5) {
      if (this.file = t5, this.isPreviewable()) return this.preloadFile();
    }
    releaseFile() {
      this.releasePreloadedFile(), this.file = null;
    }
    getUploadProgress() {
      return null != this.uploadProgress ? this.uploadProgress : 0;
    }
    setUploadProgress(t5) {
      var e4, i4;
      if (this.uploadProgress !== t5) return this.uploadProgress = t5, null === (e4 = this.uploadProgressDelegate) || void 0 === e4 || null === (i4 = e4.attachmentDidChangeUploadProgress) || void 0 === i4 ? void 0 : i4.call(e4, this);
    }
    toJSON() {
      return this.getAttributes();
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
    }
    getPreviewURL() {
      return this.previewURL || this.preloadingURL;
    }
    setPreviewURL(t5) {
      var e4, i4, n4, r4;
      if (t5 !== this.getPreviewURL()) return this.previewURL = t5, null === (e4 = this.previewDelegate) || void 0 === e4 || null === (i4 = e4.attachmentDidChangeAttributes) || void 0 === i4 || i4.call(e4, this), null === (n4 = this.delegate) || void 0 === n4 || null === (r4 = n4.attachmentDidChangePreviewURL) || void 0 === r4 ? void 0 : r4.call(n4, this);
    }
    preloadURL() {
      return this.preload(this.getURL(), this.releaseFile);
    }
    preloadFile() {
      if (this.file) return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
    }
    releasePreloadedFile() {
      this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
    }
    preload(t5, e4) {
      if (t5 && t5 !== this.getPreviewURL()) {
        this.preloadingURL = t5;
        return new Ui(t5).then((i4) => {
          let { width: n4, height: r4 } = i4;
          return this.getWidth() && this.getHeight() || this.setAttributes({ width: n4, height: r4 }), this.preloadingURL = null, this.setPreviewURL(t5), null == e4 ? void 0 : e4();
        }).catch(() => (this.preloadingURL = null, null == e4 ? void 0 : e4()));
      }
    }
  };
  Di(Vi, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);
  var zi = class _zi extends Wi {
    static fromJSON(t5) {
      return new this(Vi.fromJSON(t5.attachment), t5.attributes);
    }
    constructor(t5) {
      super(...arguments), this.attachment = t5, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
    }
    ensureAttachmentExclusivelyHasAttribute(t5) {
      this.hasAttribute(t5) && (this.attachment.hasAttribute(t5) || this.attachment.setAttributes(this.attributes.slice([t5])), this.attributes = this.attributes.remove(t5));
    }
    removeProhibitedAttributes() {
      const t5 = this.attributes.slice(_zi.permittedAttributes);
      t5.isEqualTo(this.attributes) || (this.attributes = t5);
    }
    getValue() {
      return this.attachment;
    }
    isSerializable() {
      return !this.attachment.isPending();
    }
    getCaption() {
      return this.attributes.get("caption") || "";
    }
    isEqualTo(t5) {
      var e4;
      return super.isEqualTo(t5) && this.attachment.id === (null == t5 || null === (e4 = t5.attachment) || void 0 === e4 ? void 0 : e4.id);
    }
    toString() {
      return "\uFFFC";
    }
    toJSON() {
      const t5 = super.toJSON(...arguments);
      return t5.attachment = this.attachment, t5;
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
    }
    toConsole() {
      return JSON.stringify(this.toString());
    }
  };
  Di(zi, "permittedAttributes", ["caption", "presentation"]), Wi.registerType("attachment", zi);
  var qi = class extends Wi {
    static fromJSON(t5) {
      return new this(t5.string, t5.attributes);
    }
    constructor(t5) {
      super(...arguments), this.string = ((t6) => t6.replace(/\r\n?/g, "\n"))(t5), this.length = this.string.length;
    }
    getValue() {
      return this.string;
    }
    toString() {
      return this.string.toString();
    }
    isBlockBreak() {
      return "\n" === this.toString() && true === this.getAttribute("blockBreak");
    }
    toJSON() {
      const t5 = super.toJSON(...arguments);
      return t5.string = this.string, t5;
    }
    canBeConsolidatedWith(t5) {
      return t5 && this.hasSameConstructorAs(t5) && this.hasSameAttributesAsPiece(t5);
    }
    consolidateWith(t5) {
      return new this.constructor(this.toString() + t5.toString(), this.attributes);
    }
    splitAtOffset(t5) {
      let e4, i4;
      return 0 === t5 ? (e4 = null, i4 = this) : t5 === this.length ? (e4 = this, i4 = null) : (e4 = new this.constructor(this.string.slice(0, t5), this.attributes), i4 = new this.constructor(this.string.slice(t5), this.attributes)), [e4, i4];
    }
    toConsole() {
      let { string: t5 } = this;
      return t5.length > 15 && (t5 = t5.slice(0, 14) + "\u2026"), JSON.stringify(t5.toString());
    }
  };
  Wi.registerType("string", qi);
  var Hi = class extends rt {
    static box(t5) {
      return t5 instanceof this ? t5 : new this(t5);
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = t5.slice(0), this.length = this.objects.length;
    }
    indexOf(t5) {
      return this.objects.indexOf(t5);
    }
    splice() {
      for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
      return new this.constructor(st(this.objects, ...e4));
    }
    eachObject(t5) {
      return this.objects.map((e4, i4) => t5(e4, i4));
    }
    insertObjectAtIndex(t5, e4) {
      return this.splice(e4, 0, t5);
    }
    insertSplittableListAtIndex(t5, e4) {
      return this.splice(e4, 0, ...t5.objects);
    }
    insertSplittableListAtPosition(t5, e4) {
      const [i4, n4] = this.splitObjectAtPosition(e4);
      return new this.constructor(i4).insertSplittableListAtIndex(t5, n4);
    }
    editObjectAtIndex(t5, e4) {
      return this.replaceObjectAtIndex(e4(this.objects[t5]), t5);
    }
    replaceObjectAtIndex(t5, e4) {
      return this.splice(e4, 1, t5);
    }
    removeObjectAtIndex(t5) {
      return this.splice(t5, 1);
    }
    getObjectAtIndex(t5) {
      return this.objects[t5];
    }
    getSplittableListInRange(t5) {
      const [e4, i4, n4] = this.splitObjectsAtRange(t5);
      return new this.constructor(e4.slice(i4, n4 + 1));
    }
    selectSplittableList(t5) {
      const e4 = this.objects.filter((e5) => t5(e5));
      return new this.constructor(e4);
    }
    removeObjectsInRange(t5) {
      const [e4, i4, n4] = this.splitObjectsAtRange(t5);
      return new this.constructor(e4).splice(i4, n4 - i4 + 1);
    }
    transformObjectsInRange(t5, e4) {
      const [i4, n4, r4] = this.splitObjectsAtRange(t5), o4 = i4.map((t6, i5) => n4 <= i5 && i5 <= r4 ? e4(t6) : t6);
      return new this.constructor(o4);
    }
    splitObjectsAtRange(t5) {
      let e4, [i4, n4, r4] = this.splitObjectAtPosition(Ki(t5));
      return [i4, e4] = new this.constructor(i4).splitObjectAtPosition(Gi(t5) + r4), [i4, n4, e4 - 1];
    }
    getObjectAtPosition(t5) {
      const { index: e4 } = this.findIndexAndOffsetAtPosition(t5);
      return this.objects[e4];
    }
    splitObjectAtPosition(t5) {
      let e4, i4;
      const { index: n4, offset: r4 } = this.findIndexAndOffsetAtPosition(t5), o4 = this.objects.slice(0);
      if (null != n4) if (0 === r4) e4 = n4, i4 = 0;
      else {
        const t6 = this.getObjectAtIndex(n4), [s4, a4] = t6.splitAtOffset(r4);
        o4.splice(n4, 1, s4, a4), e4 = n4 + 1, i4 = s4.getLength() - r4;
      }
      else e4 = o4.length, i4 = 0;
      return [o4, e4, i4];
    }
    consolidate() {
      const t5 = [];
      let e4 = this.objects[0];
      return this.objects.slice(1).forEach((i4) => {
        var n4, r4;
        null !== (n4 = (r4 = e4).canBeConsolidatedWith) && void 0 !== n4 && n4.call(r4, i4) ? e4 = e4.consolidateWith(i4) : (t5.push(e4), e4 = i4);
      }), e4 && t5.push(e4), new this.constructor(t5);
    }
    consolidateFromIndexToIndex(t5, e4) {
      const i4 = this.objects.slice(0).slice(t5, e4 + 1), n4 = new this.constructor(i4).consolidate().toArray();
      return this.splice(t5, i4.length, ...n4);
    }
    findIndexAndOffsetAtPosition(t5) {
      let e4, i4 = 0;
      for (e4 = 0; e4 < this.objects.length; e4++) {
        const n4 = i4 + this.objects[e4].getLength();
        if (i4 <= t5 && t5 < n4) return { index: e4, offset: t5 - i4 };
        i4 = n4;
      }
      return { index: null, offset: null };
    }
    findPositionAtIndexAndOffset(t5, e4) {
      let i4 = 0;
      for (let n4 = 0; n4 < this.objects.length; n4++) {
        const r4 = this.objects[n4];
        if (n4 < t5) i4 += r4.getLength();
        else if (n4 === t5) {
          i4 += e4;
          break;
        }
      }
      return i4;
    }
    getEndPosition() {
      return null == this.endPosition && (this.endPosition = 0, this.objects.forEach((t5) => this.endPosition += t5.getLength())), this.endPosition;
    }
    toString() {
      return this.objects.join("");
    }
    toArray() {
      return this.objects.slice(0);
    }
    toJSON() {
      return this.toArray();
    }
    isEqualTo(t5) {
      return super.isEqualTo(...arguments) || Ji(this.objects, null == t5 ? void 0 : t5.objects);
    }
    contentsForInspection() {
      return { objects: "[".concat(this.objects.map((t5) => t5.inspect()).join(", "), "]") };
    }
  };
  var Ji = function(t5) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t5.length !== e4.length) return false;
    let i4 = true;
    for (let n4 = 0; n4 < t5.length; n4++) {
      const r4 = t5[n4];
      i4 && !r4.isEqualTo(e4[n4]) && (i4 = false);
    }
    return i4;
  };
  var Ki = (t5) => t5[0];
  var Gi = (t5) => t5[1];
  var Yi = class extends rt {
    static textForAttachmentWithAttributes(t5, e4) {
      return new this([new zi(t5, e4)]);
    }
    static textForStringWithAttributes(t5, e4) {
      return new this([new qi(t5, e4)]);
    }
    static fromJSON(t5) {
      return new this(Array.from(t5).map((t6) => Wi.fromJSON(t6)));
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments);
      const e4 = t5.filter((t6) => !t6.isEmpty());
      this.pieceList = new Hi(e4);
    }
    copy() {
      return this.copyWithPieceList(this.pieceList);
    }
    copyWithPieceList(t5) {
      return new this.constructor(t5.consolidate().toArray());
    }
    copyUsingObjectMap(t5) {
      const e4 = this.getPieces().map((e5) => t5.find(e5) || e5);
      return new this.constructor(e4);
    }
    appendText(t5) {
      return this.insertTextAtPosition(t5, this.getLength());
    }
    insertTextAtPosition(t5, e4) {
      return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t5.pieceList, e4));
    }
    removeTextAtRange(t5) {
      return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t5));
    }
    replaceTextAtRange(t5, e4) {
      return this.removeTextAtRange(e4).insertTextAtPosition(t5, e4[0]);
    }
    moveTextFromRangeToPosition(t5, e4) {
      if (t5[0] <= e4 && e4 <= t5[1]) return;
      const i4 = this.getTextAtRange(t5), n4 = i4.getLength();
      return t5[0] < e4 && (e4 -= n4), this.removeTextAtRange(t5).insertTextAtPosition(i4, e4);
    }
    addAttributeAtRange(t5, e4, i4) {
      const n4 = {};
      return n4[t5] = e4, this.addAttributesAtRange(n4, i4);
    }
    addAttributesAtRange(t5, e4) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAdditionalAttributes(t5)));
    }
    removeAttributeAtRange(t5, e4) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithoutAttribute(t5)));
    }
    setAttributesAtRange(t5, e4) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAttributes(t5)));
    }
    getAttributesAtPosition(t5) {
      var e4;
      return (null === (e4 = this.pieceList.getObjectAtPosition(t5)) || void 0 === e4 ? void 0 : e4.getAttributes()) || {};
    }
    getCommonAttributes() {
      const t5 = Array.from(this.pieceList.toArray()).map((t6) => t6.getAttributes());
      return Ht.fromCommonAttributesOfObjects(t5).toObject();
    }
    getCommonAttributesAtRange(t5) {
      return this.getTextAtRange(t5).getCommonAttributes() || {};
    }
    getExpandedRangeForAttributeAtOffset(t5, e4) {
      let i4, n4 = i4 = e4;
      const r4 = this.getLength();
      for (; n4 > 0 && this.getCommonAttributesAtRange([n4 - 1, i4])[t5]; ) n4--;
      for (; i4 < r4 && this.getCommonAttributesAtRange([e4, i4 + 1])[t5]; ) i4++;
      return [n4, i4];
    }
    getTextAtRange(t5) {
      return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t5));
    }
    getStringAtRange(t5) {
      return this.pieceList.getSplittableListInRange(t5).toString();
    }
    getStringAtPosition(t5) {
      return this.getStringAtRange([t5, t5 + 1]);
    }
    startsWithString(t5) {
      return this.getStringAtRange([0, t5.length]) === t5;
    }
    endsWithString(t5) {
      const e4 = this.getLength();
      return this.getStringAtRange([e4 - t5.length, e4]) === t5;
    }
    getAttachmentPieces() {
      return this.pieceList.toArray().filter((t5) => !!t5.attachment);
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t5) => t5.attachment);
    }
    getAttachmentAndPositionById(t5) {
      let e4 = 0;
      for (const n4 of this.pieceList.toArray()) {
        var i4;
        if ((null === (i4 = n4.attachment) || void 0 === i4 ? void 0 : i4.id) === t5) return { attachment: n4.attachment, position: e4 };
        e4 += n4.length;
      }
      return { attachment: null, position: null };
    }
    getAttachmentById(t5) {
      const { attachment: e4 } = this.getAttachmentAndPositionById(t5);
      return e4;
    }
    getRangeOfAttachment(t5) {
      const e4 = this.getAttachmentAndPositionById(t5.id), i4 = e4.position;
      if (t5 = e4.attachment) return [i4, i4 + 1];
    }
    updateAttributesForAttachment(t5, e4) {
      const i4 = this.getRangeOfAttachment(e4);
      return i4 ? this.addAttributesAtRange(t5, i4) : this;
    }
    getLength() {
      return this.pieceList.getEndPosition();
    }
    isEmpty() {
      return 0 === this.getLength();
    }
    isEqualTo(t5) {
      var e4;
      return super.isEqualTo(t5) || (null == t5 || null === (e4 = t5.pieceList) || void 0 === e4 ? void 0 : e4.isEqualTo(this.pieceList));
    }
    isBlockBreak() {
      return 1 === this.getLength() && this.pieceList.getObjectAtIndex(0).isBlockBreak();
    }
    eachPiece(t5) {
      return this.pieceList.eachObject(t5);
    }
    getPieces() {
      return this.pieceList.toArray();
    }
    getPieceAtPosition(t5) {
      return this.pieceList.getObjectAtPosition(t5);
    }
    contentsForInspection() {
      return { pieceList: this.pieceList.inspect() };
    }
    toSerializableText() {
      const t5 = this.pieceList.selectSplittableList((t6) => t6.isSerializable());
      return this.copyWithPieceList(t5);
    }
    toString() {
      return this.pieceList.toString();
    }
    toJSON() {
      return this.pieceList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.pieceList.toArray().map((t5) => JSON.parse(t5.toConsole())));
    }
    getDirection() {
      return lt(this.toString());
    }
    isRTL() {
      return "rtl" === this.getDirection();
    }
  };
  var Xi = class _Xi extends rt {
    static fromJSON(t5) {
      return new this(Yi.fromJSON(t5.text), t5.attributes, t5.htmlAttributes);
    }
    constructor(t5, e4, i4) {
      super(...arguments), this.text = $i(t5 || new Yi()), this.attributes = e4 || [], this.htmlAttributes = i4 || {};
    }
    isEmpty() {
      return this.text.isBlockBreak();
    }
    isEqualTo(t5) {
      return !!super.isEqualTo(t5) || this.text.isEqualTo(null == t5 ? void 0 : t5.text) && ot(this.attributes, null == t5 ? void 0 : t5.attributes) && Tt(this.htmlAttributes, null == t5 ? void 0 : t5.htmlAttributes);
    }
    copyWithText(t5) {
      return new _Xi(t5, this.attributes, this.htmlAttributes);
    }
    copyWithoutText() {
      return this.copyWithText(null);
    }
    copyWithAttributes(t5) {
      return new _Xi(this.text, t5, this.htmlAttributes);
    }
    copyWithoutAttributes() {
      return this.copyWithAttributes(null);
    }
    copyUsingObjectMap(t5) {
      const e4 = t5.find(this.text);
      return e4 ? this.copyWithText(e4) : this.copyWithText(this.text.copyUsingObjectMap(t5));
    }
    addAttribute(t5) {
      const e4 = this.attributes.concat(rn(t5));
      return this.copyWithAttributes(e4);
    }
    addHTMLAttribute(t5, e4) {
      const i4 = Object.assign({}, this.htmlAttributes, { [t5]: e4 });
      return new _Xi(this.text, this.attributes, i4);
    }
    removeAttribute(t5) {
      const { listAttribute: e4 } = mt(t5), i4 = sn(sn(this.attributes, t5), e4);
      return this.copyWithAttributes(i4);
    }
    removeLastAttribute() {
      return this.removeAttribute(this.getLastAttribute());
    }
    getLastAttribute() {
      return on(this.attributes);
    }
    getAttributes() {
      return this.attributes.slice(0);
    }
    getAttributeLevel() {
      return this.attributes.length;
    }
    getAttributeAtLevel(t5) {
      return this.attributes[t5 - 1];
    }
    hasAttribute(t5) {
      return this.attributes.includes(t5);
    }
    hasAttributes() {
      return this.getAttributeLevel() > 0;
    }
    getLastNestableAttribute() {
      return on(this.getNestableAttributes());
    }
    getNestableAttributes() {
      return this.attributes.filter((t5) => mt(t5).nestable);
    }
    getNestingLevel() {
      return this.getNestableAttributes().length;
    }
    decreaseNestingLevel() {
      const t5 = this.getLastNestableAttribute();
      return t5 ? this.removeAttribute(t5) : this;
    }
    increaseNestingLevel() {
      const t5 = this.getLastNestableAttribute();
      if (t5) {
        const e4 = this.attributes.lastIndexOf(t5), i4 = st(this.attributes, e4 + 1, 0, ...rn(t5));
        return this.copyWithAttributes(i4);
      }
      return this;
    }
    getListItemAttributes() {
      return this.attributes.filter((t5) => mt(t5).listAttribute);
    }
    isListItem() {
      var t5;
      return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.listAttribute;
    }
    isTerminalBlock() {
      var t5;
      return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.terminal;
    }
    breaksOnReturn() {
      var t5;
      return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.breakOnReturn;
    }
    findLineBreakInDirectionFromPosition(t5, e4) {
      const i4 = this.toString();
      let n4;
      switch (t5) {
        case "forward":
          n4 = i4.indexOf("\n", e4);
          break;
        case "backward":
          n4 = i4.slice(0, e4).lastIndexOf("\n");
      }
      if (-1 !== n4) return n4;
    }
    contentsForInspection() {
      return { text: this.text.inspect(), attributes: this.attributes };
    }
    toString() {
      return this.text.toString();
    }
    toJSON() {
      return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
    }
    getDirection() {
      return this.text.getDirection();
    }
    isRTL() {
      return this.text.isRTL();
    }
    getLength() {
      return this.text.getLength();
    }
    canBeConsolidatedWith(t5) {
      return !this.hasAttributes() && !t5.hasAttributes() && this.getDirection() === t5.getDirection();
    }
    consolidateWith(t5) {
      const e4 = Yi.textForStringWithAttributes("\n"), i4 = this.getTextWithoutBlockBreak().appendText(e4);
      return this.copyWithText(i4.appendText(t5.text));
    }
    splitAtOffset(t5) {
      let e4, i4;
      return 0 === t5 ? (e4 = null, i4 = this) : t5 === this.getLength() ? (e4 = this, i4 = null) : (e4 = this.copyWithText(this.text.getTextAtRange([0, t5])), i4 = this.copyWithText(this.text.getTextAtRange([t5, this.getLength()]))), [e4, i4];
    }
    getBlockBreakPosition() {
      return this.text.getLength() - 1;
    }
    getTextWithoutBlockBreak() {
      return en(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
    }
    canBeGrouped(t5) {
      return this.attributes[t5];
    }
    canBeGroupedWith(t5, e4) {
      const i4 = t5.getAttributes(), r4 = i4[e4], o4 = this.attributes[e4];
      return o4 === r4 && !(false === mt(o4).group && !(() => {
        if (!dt) {
          dt = [];
          for (const t6 in n3) {
            const { listAttribute: e5 } = n3[t6];
            null != e5 && dt.push(e5);
          }
        }
        return dt;
      })().includes(i4[e4 + 1])) && (this.getDirection() === t5.getDirection() || t5.isEmpty());
    }
  };
  var $i = function(t5) {
    return t5 = Zi(t5), t5 = tn(t5);
  };
  var Zi = function(t5) {
    let e4 = false;
    const i4 = t5.getPieces();
    let n4 = i4.slice(0, i4.length - 1);
    const r4 = i4[i4.length - 1];
    return r4 ? (n4 = n4.map((t6) => t6.isBlockBreak() ? (e4 = true, nn(t6)) : t6), e4 ? new Yi([...n4, r4]) : t5) : t5;
  };
  var Qi = Yi.textForStringWithAttributes("\n", { blockBreak: true });
  var tn = function(t5) {
    return en(t5) ? t5 : t5.appendText(Qi);
  };
  var en = function(t5) {
    const e4 = t5.getLength();
    if (0 === e4) return false;
    return t5.getTextAtRange([e4 - 1, e4]).isBlockBreak();
  };
  var nn = (t5) => t5.copyWithoutAttribute("blockBreak");
  var rn = function(t5) {
    const { listAttribute: e4 } = mt(t5);
    return e4 ? [e4, t5] : [t5];
  };
  var on = (t5) => t5.slice(-1)[0];
  var sn = function(t5, e4) {
    const i4 = t5.lastIndexOf(e4);
    return -1 === i4 ? t5 : st(t5, i4, 1);
  };
  var an = class extends rt {
    static fromJSON(t5) {
      return new this(Array.from(t5).map((t6) => Xi.fromJSON(t6)));
    }
    static fromString(t5, e4) {
      const i4 = Yi.textForStringWithAttributes(t5, e4);
      return new this([new Xi(i4)]);
    }
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), 0 === t5.length && (t5 = [new Xi()]), this.blockList = Hi.box(t5);
    }
    isEmpty() {
      const t5 = this.getBlockAtIndex(0);
      return 1 === this.blockList.length && t5.isEmpty() && !t5.hasAttributes();
    }
    copy() {
      const t5 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
      return new this.constructor(t5);
    }
    copyUsingObjectsFromDocument(t5) {
      const e4 = new Zt(t5.getObjects());
      return this.copyUsingObjectMap(e4);
    }
    copyUsingObjectMap(t5) {
      const e4 = this.getBlocks().map((e5) => t5.find(e5) || e5.copyUsingObjectMap(t5));
      return new this.constructor(e4);
    }
    copyWithBaseBlockAttributes() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const e4 = this.getBlocks().map((e5) => {
        const i4 = t5.concat(e5.getAttributes());
        return e5.copyWithAttributes(i4);
      });
      return new this.constructor(e4);
    }
    replaceBlock(t5, e4) {
      const i4 = this.blockList.indexOf(t5);
      return -1 === i4 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e4, i4));
    }
    insertDocumentAtRange(t5, e4) {
      const { blockList: i4 } = t5;
      e4 = wt(e4);
      let [n4] = e4;
      const { index: r4, offset: o4 } = this.locationFromPosition(n4);
      let s4 = this;
      const a4 = this.getBlockAtPosition(n4);
      return Lt(e4) && a4.isEmpty() && !a4.hasAttributes() ? s4 = new this.constructor(s4.blockList.removeObjectAtIndex(r4)) : a4.getBlockBreakPosition() === o4 && n4++, s4 = s4.removeTextAtRange(e4), new this.constructor(s4.blockList.insertSplittableListAtPosition(i4, n4));
    }
    mergeDocumentAtRange(t5, e4) {
      let i4, n4;
      e4 = wt(e4);
      const [r4] = e4, o4 = this.locationFromPosition(r4), s4 = this.getBlockAtIndex(o4.index).getAttributes(), a4 = t5.getBaseBlockAttributes(), l4 = s4.slice(-a4.length);
      if (ot(a4, l4)) {
        const e5 = s4.slice(0, -a4.length);
        i4 = t5.copyWithBaseBlockAttributes(e5);
      } else i4 = t5.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s4);
      const c4 = i4.getBlockCount(), u4 = i4.getBlockAtIndex(0);
      if (ot(s4, u4.getAttributes())) {
        const t6 = u4.getTextWithoutBlockBreak();
        if (n4 = this.insertTextAtRange(t6, e4), c4 > 1) {
          i4 = new this.constructor(i4.getBlocks().slice(1));
          const e5 = r4 + t6.getLength();
          n4 = n4.insertDocumentAtRange(i4, e5);
        }
      } else n4 = this.insertDocumentAtRange(i4, e4);
      return n4;
    }
    insertTextAtRange(t5, e4) {
      e4 = wt(e4);
      const [i4] = e4, { index: n4, offset: r4 } = this.locationFromPosition(i4), o4 = this.removeTextAtRange(e4);
      return new this.constructor(o4.blockList.editObjectAtIndex(n4, (e5) => e5.copyWithText(e5.text.insertTextAtPosition(t5, r4))));
    }
    removeTextAtRange(t5) {
      let e4;
      t5 = wt(t5);
      const [i4, n4] = t5;
      if (Lt(t5)) return this;
      const [r4, o4] = Array.from(this.locationRangeFromRange(t5)), s4 = r4.index, a4 = r4.offset, l4 = this.getBlockAtIndex(s4), c4 = o4.index, u4 = o4.offset, h4 = this.getBlockAtIndex(c4);
      if (n4 - i4 == 1 && l4.getBlockBreakPosition() === a4 && h4.getBlockBreakPosition() !== u4 && "\n" === h4.text.getStringAtPosition(u4)) e4 = this.blockList.editObjectAtIndex(c4, (t6) => t6.copyWithText(t6.text.removeTextAtRange([u4, u4 + 1])));
      else {
        let t6;
        const i5 = l4.text.getTextAtRange([0, a4]), n5 = h4.text.getTextAtRange([u4, h4.getLength()]), r5 = i5.appendText(n5);
        t6 = s4 !== c4 && 0 === a4 && l4.getAttributeLevel() >= h4.getAttributeLevel() ? h4.copyWithText(r5) : l4.copyWithText(r5);
        const o5 = c4 + 1 - s4;
        e4 = this.blockList.splice(s4, o5, t6);
      }
      return new this.constructor(e4);
    }
    moveTextFromRangeToPosition(t5, e4) {
      let i4;
      t5 = wt(t5);
      const [n4, r4] = t5;
      if (n4 <= e4 && e4 <= r4) return this;
      let o4 = this.getDocumentAtRange(t5), s4 = this.removeTextAtRange(t5);
      const a4 = n4 < e4;
      a4 && (e4 -= o4.getLength());
      const [l4, ...c4] = o4.getBlocks();
      return 0 === c4.length ? (i4 = l4.getTextWithoutBlockBreak(), a4 && (e4 += 1)) : i4 = l4.text, s4 = s4.insertTextAtRange(i4, e4), 0 === c4.length ? s4 : (o4 = new this.constructor(c4), e4 += i4.getLength(), s4.insertDocumentAtRange(o4, e4));
    }
    addAttributeAtRange(t5, e4, i4) {
      let { blockList: n4 } = this;
      return this.eachBlockAtRange(i4, (i5, r4, o4) => n4 = n4.editObjectAtIndex(o4, function() {
        return mt(t5) ? i5.addAttribute(t5, e4) : r4[0] === r4[1] ? i5 : i5.copyWithText(i5.text.addAttributeAtRange(t5, e4, r4));
      })), new this.constructor(n4);
    }
    addAttribute(t5, e4) {
      let { blockList: i4 } = this;
      return this.eachBlock((n4, r4) => i4 = i4.editObjectAtIndex(r4, () => n4.addAttribute(t5, e4))), new this.constructor(i4);
    }
    removeAttributeAtRange(t5, e4) {
      let { blockList: i4 } = this;
      return this.eachBlockAtRange(e4, function(e5, n4, r4) {
        mt(t5) ? i4 = i4.editObjectAtIndex(r4, () => e5.removeAttribute(t5)) : n4[0] !== n4[1] && (i4 = i4.editObjectAtIndex(r4, () => e5.copyWithText(e5.text.removeAttributeAtRange(t5, n4))));
      }), new this.constructor(i4);
    }
    updateAttributesForAttachment(t5, e4) {
      const i4 = this.getRangeOfAttachment(e4), [n4] = Array.from(i4), { index: r4 } = this.locationFromPosition(n4), o4 = this.getTextAtIndex(r4);
      return new this.constructor(this.blockList.editObjectAtIndex(r4, (i5) => i5.copyWithText(o4.updateAttributesForAttachment(t5, e4))));
    }
    removeAttributeForAttachment(t5, e4) {
      const i4 = this.getRangeOfAttachment(e4);
      return this.removeAttributeAtRange(t5, i4);
    }
    setHTMLAttributeAtPosition(t5, e4, i4) {
      const n4 = this.getBlockAtPosition(t5), r4 = n4.addHTMLAttribute(e4, i4);
      return this.replaceBlock(n4, r4);
    }
    insertBlockBreakAtRange(t5) {
      let e4;
      t5 = wt(t5);
      const [i4] = t5, { offset: n4 } = this.locationFromPosition(i4), r4 = this.removeTextAtRange(t5);
      return 0 === n4 && (e4 = [new Xi()]), new this.constructor(r4.blockList.insertSplittableListAtPosition(new Hi(e4), i4));
    }
    applyBlockAttributeAtRange(t5, e4, i4) {
      const n4 = this.expandRangeToLineBreaksAndSplitBlocks(i4);
      let r4 = n4.document;
      i4 = n4.range;
      const o4 = mt(t5);
      if (o4.listAttribute) {
        r4 = r4.removeLastListAttributeAtRange(i4, { exceptAttributeName: t5 });
        const e5 = r4.convertLineBreaksToBlockBreaksInRange(i4);
        r4 = e5.document, i4 = e5.range;
      } else r4 = o4.exclusive ? r4.removeBlockAttributesAtRange(i4) : o4.terminal ? r4.removeLastTerminalAttributeAtRange(i4) : r4.consolidateBlocksAtRange(i4);
      return r4.addAttributeAtRange(t5, e4, i4);
    }
    removeLastListAttributeAtRange(t5) {
      let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { blockList: i4 } = this;
      return this.eachBlockAtRange(t5, function(t6, n4, r4) {
        const o4 = t6.getLastAttribute();
        o4 && mt(o4).listAttribute && o4 !== e4.exceptAttributeName && (i4 = i4.editObjectAtIndex(r4, () => t6.removeAttribute(o4)));
      }), new this.constructor(i4);
    }
    removeLastTerminalAttributeAtRange(t5) {
      let { blockList: e4 } = this;
      return this.eachBlockAtRange(t5, function(t6, i4, n4) {
        const r4 = t6.getLastAttribute();
        r4 && mt(r4).terminal && (e4 = e4.editObjectAtIndex(n4, () => t6.removeAttribute(r4)));
      }), new this.constructor(e4);
    }
    removeBlockAttributesAtRange(t5) {
      let { blockList: e4 } = this;
      return this.eachBlockAtRange(t5, function(t6, i4, n4) {
        t6.hasAttributes() && (e4 = e4.editObjectAtIndex(n4, () => t6.copyWithoutAttributes()));
      }), new this.constructor(e4);
    }
    expandRangeToLineBreaksAndSplitBlocks(t5) {
      let e4;
      t5 = wt(t5);
      let [i4, n4] = t5;
      const r4 = this.locationFromPosition(i4), o4 = this.locationFromPosition(n4);
      let s4 = this;
      const a4 = s4.getBlockAtIndex(r4.index);
      if (r4.offset = a4.findLineBreakInDirectionFromPosition("backward", r4.offset), null != r4.offset && (e4 = s4.positionFromLocation(r4), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]), o4.index += 1, o4.offset -= s4.getBlockAtIndex(r4.index).getLength(), r4.index += 1), r4.offset = 0, 0 === o4.offset && o4.index > r4.index) o4.index -= 1, o4.offset = s4.getBlockAtIndex(o4.index).getBlockBreakPosition();
      else {
        const t6 = s4.getBlockAtIndex(o4.index);
        "\n" === t6.text.getStringAtRange([o4.offset - 1, o4.offset]) ? o4.offset -= 1 : o4.offset = t6.findLineBreakInDirectionFromPosition("forward", o4.offset), o4.offset !== t6.getBlockBreakPosition() && (e4 = s4.positionFromLocation(o4), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]));
      }
      return i4 = s4.positionFromLocation(r4), n4 = s4.positionFromLocation(o4), { document: s4, range: t5 = wt([i4, n4]) };
    }
    convertLineBreaksToBlockBreaksInRange(t5) {
      t5 = wt(t5);
      let [e4] = t5;
      const i4 = this.getStringAtRange(t5).slice(0, -1);
      let n4 = this;
      return i4.replace(/.*?\n/g, function(t6) {
        e4 += t6.length, n4 = n4.insertBlockBreakAtRange([e4 - 1, e4]);
      }), { document: n4, range: t5 };
    }
    consolidateBlocksAtRange(t5) {
      t5 = wt(t5);
      const [e4, i4] = t5, n4 = this.locationFromPosition(e4).index, r4 = this.locationFromPosition(i4).index;
      return new this.constructor(this.blockList.consolidateFromIndexToIndex(n4, r4));
    }
    getDocumentAtRange(t5) {
      t5 = wt(t5);
      const e4 = this.blockList.getSplittableListInRange(t5).toArray();
      return new this.constructor(e4);
    }
    getStringAtRange(t5) {
      let e4;
      const i4 = t5 = wt(t5);
      return i4[i4.length - 1] !== this.getLength() && (e4 = -1), this.getDocumentAtRange(t5).toString().slice(0, e4);
    }
    getBlockAtIndex(t5) {
      return this.blockList.getObjectAtIndex(t5);
    }
    getBlockAtPosition(t5) {
      const { index: e4 } = this.locationFromPosition(t5);
      return this.getBlockAtIndex(e4);
    }
    getTextAtIndex(t5) {
      var e4;
      return null === (e4 = this.getBlockAtIndex(t5)) || void 0 === e4 ? void 0 : e4.text;
    }
    getTextAtPosition(t5) {
      const { index: e4 } = this.locationFromPosition(t5);
      return this.getTextAtIndex(e4);
    }
    getPieceAtPosition(t5) {
      const { index: e4, offset: i4 } = this.locationFromPosition(t5);
      return this.getTextAtIndex(e4).getPieceAtPosition(i4);
    }
    getCharacterAtPosition(t5) {
      const { index: e4, offset: i4 } = this.locationFromPosition(t5);
      return this.getTextAtIndex(e4).getStringAtRange([i4, i4 + 1]);
    }
    getLength() {
      return this.blockList.getEndPosition();
    }
    getBlocks() {
      return this.blockList.toArray();
    }
    getBlockCount() {
      return this.blockList.length;
    }
    getEditCount() {
      return this.editCount;
    }
    eachBlock(t5) {
      return this.blockList.eachObject(t5);
    }
    eachBlockAtRange(t5, e4) {
      let i4, n4;
      t5 = wt(t5);
      const [r4, o4] = t5, s4 = this.locationFromPosition(r4), a4 = this.locationFromPosition(o4);
      if (s4.index === a4.index) return i4 = this.getBlockAtIndex(s4.index), n4 = [s4.offset, a4.offset], e4(i4, n4, s4.index);
      for (let t6 = s4.index; t6 <= a4.index; t6++) if (i4 = this.getBlockAtIndex(t6), i4) {
        switch (t6) {
          case s4.index:
            n4 = [s4.offset, i4.text.getLength()];
            break;
          case a4.index:
            n4 = [0, a4.offset];
            break;
          default:
            n4 = [0, i4.text.getLength()];
        }
        e4(i4, n4, t6);
      }
    }
    getCommonAttributesAtRange(t5) {
      t5 = wt(t5);
      const [e4] = t5;
      if (Lt(t5)) return this.getCommonAttributesAtPosition(e4);
      {
        const e5 = [], i4 = [];
        return this.eachBlockAtRange(t5, function(t6, n4) {
          if (n4[0] !== n4[1]) return e5.push(t6.text.getCommonAttributesAtRange(n4)), i4.push(ln(t6));
        }), Ht.fromCommonAttributesOfObjects(e5).merge(Ht.fromCommonAttributesOfObjects(i4)).toObject();
      }
    }
    getCommonAttributesAtPosition(t5) {
      let e4, i4;
      const { index: n4, offset: r4 } = this.locationFromPosition(t5), o4 = this.getBlockAtIndex(n4);
      if (!o4) return {};
      const s4 = ln(o4), a4 = o4.text.getAttributesAtPosition(r4), l4 = o4.text.getAttributesAtPosition(r4 - 1), c4 = Object.keys(W2).filter((t6) => W2[t6].inheritable);
      for (e4 in l4) i4 = l4[e4], (i4 === a4[e4] || c4.includes(e4)) && (s4[e4] = i4);
      return s4;
    }
    getRangeOfCommonAttributeAtPosition(t5, e4) {
      const { index: i4, offset: n4 } = this.locationFromPosition(e4), r4 = this.getTextAtIndex(i4), [o4, s4] = Array.from(r4.getExpandedRangeForAttributeAtOffset(t5, n4)), a4 = this.positionFromLocation({ index: i4, offset: o4 }), l4 = this.positionFromLocation({ index: i4, offset: s4 });
      return wt([a4, l4]);
    }
    getBaseBlockAttributes() {
      let t5 = this.getBlockAtIndex(0).getAttributes();
      for (let e4 = 1; e4 < this.getBlockCount(); e4++) {
        const i4 = this.getBlockAtIndex(e4).getAttributes(), n4 = Math.min(t5.length, i4.length);
        t5 = (() => {
          const e5 = [];
          for (let r4 = 0; r4 < n4 && i4[r4] === t5[r4]; r4++) e5.push(i4[r4]);
          return e5;
        })();
      }
      return t5;
    }
    getAttachmentById(t5) {
      for (const e4 of this.getAttachments()) if (e4.id === t5) return e4;
    }
    getAttachmentPieces() {
      let t5 = [];
      return this.blockList.eachObject((e4) => {
        let { text: i4 } = e4;
        return t5 = t5.concat(i4.getAttachmentPieces());
      }), t5;
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t5) => t5.attachment);
    }
    getRangeOfAttachment(t5) {
      let e4 = 0;
      const i4 = this.blockList.toArray();
      for (let n4 = 0; n4 < i4.length; n4++) {
        const { text: r4 } = i4[n4], o4 = r4.getRangeOfAttachment(t5);
        if (o4) return wt([e4 + o4[0], e4 + o4[1]]);
        e4 += r4.getLength();
      }
    }
    getLocationRangeOfAttachment(t5) {
      const e4 = this.getRangeOfAttachment(t5);
      return this.locationRangeFromRange(e4);
    }
    getAttachmentPieceForAttachment(t5) {
      for (const e4 of this.getAttachmentPieces()) if (e4.attachment === t5) return e4;
    }
    findRangesForBlockAttribute(t5) {
      let e4 = 0;
      const i4 = [];
      return this.getBlocks().forEach((n4) => {
        const r4 = n4.getLength();
        n4.hasAttribute(t5) && i4.push([e4, e4 + r4]), e4 += r4;
      }), i4;
    }
    findRangesForTextAttribute(t5) {
      let { withValue: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i4 = 0, n4 = [];
      const r4 = [];
      return this.getPieces().forEach((o4) => {
        const s4 = o4.getLength();
        (function(i5) {
          return e4 ? i5.getAttribute(t5) === e4 : i5.hasAttribute(t5);
        })(o4) && (n4[1] === i4 ? n4[1] = i4 + s4 : r4.push(n4 = [i4, i4 + s4])), i4 += s4;
      }), r4;
    }
    locationFromPosition(t5) {
      const e4 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t5));
      if (null != e4.index) return e4;
      {
        const t6 = this.getBlocks();
        return { index: t6.length - 1, offset: t6[t6.length - 1].getLength() };
      }
    }
    positionFromLocation(t5) {
      return this.blockList.findPositionAtIndexAndOffset(t5.index, t5.offset);
    }
    locationRangeFromPosition(t5) {
      return wt(this.locationFromPosition(t5));
    }
    locationRangeFromRange(t5) {
      if (!(t5 = wt(t5))) return;
      const [e4, i4] = Array.from(t5), n4 = this.locationFromPosition(e4), r4 = this.locationFromPosition(i4);
      return wt([n4, r4]);
    }
    rangeFromLocationRange(t5) {
      let e4;
      t5 = wt(t5);
      const i4 = this.positionFromLocation(t5[0]);
      return Lt(t5) || (e4 = this.positionFromLocation(t5[1])), wt([i4, e4]);
    }
    isEqualTo(t5) {
      return this.blockList.isEqualTo(null == t5 ? void 0 : t5.blockList);
    }
    getTexts() {
      return this.getBlocks().map((t5) => t5.text);
    }
    getPieces() {
      const t5 = [];
      return Array.from(this.getTexts()).forEach((e4) => {
        t5.push(...Array.from(e4.getPieces() || []));
      }), t5;
    }
    getObjects() {
      return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
    }
    toSerializableDocument() {
      const t5 = [];
      return this.blockList.eachObject((e4) => t5.push(e4.copyWithText(e4.text.toSerializableText()))), new this.constructor(t5);
    }
    toString() {
      return this.blockList.toString();
    }
    toJSON() {
      return this.blockList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.blockList.toArray().map((t5) => JSON.parse(t5.text.toConsole())));
    }
  };
  var ln = function(t5) {
    const e4 = {}, i4 = t5.getLastAttribute();
    return i4 && (e4[i4] = true), e4;
  };
  var cn = function(t5) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return { string: t5 = Wt(t5), attributes: e4, type: "string" };
  };
  var un = (t5, e4) => {
    try {
      return JSON.parse(t5.getAttribute("data-trix-".concat(e4)));
    } catch (t6) {
      return {};
    }
  };
  var hn = class extends q3 {
    static parse(t5, e4) {
      const i4 = new this(t5, e4);
      return i4.parse(), i4;
    }
    constructor(t5) {
      let { referenceElement: e4, purifyOptions: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.html = t5, this.referenceElement = e4, this.purifyOptions = i4, this.blocks = [], this.blockElements = [], this.processedElements = [];
    }
    getDocument() {
      return an.fromJSON(this.blocks);
    }
    parse() {
      try {
        this.createHiddenContainer(), di.setHTML(this.containerElement, this.html, { purifyOptions: this.purifyOptions });
        const t5 = R2(this.containerElement, { usingFilter: pn });
        for (; t5.nextNode(); ) this.processNode(t5.currentNode);
        return this.translateBlockElementMarginsToNewlines();
      } finally {
        this.removeHiddenContainer();
      }
    }
    createHiddenContainer() {
      return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = T3({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
    }
    removeHiddenContainer() {
      return S3(this.containerElement);
    }
    processNode(t5) {
      switch (t5.nodeType) {
        case Node.TEXT_NODE:
          if (!this.isInsignificantTextNode(t5)) return this.appendBlockForTextNode(t5), this.processTextNode(t5);
          break;
        case Node.ELEMENT_NODE:
          return this.appendBlockForElement(t5), this.processElement(t5);
      }
    }
    appendBlockForTextNode(t5) {
      const e4 = t5.parentNode;
      if (e4 === this.currentBlockElement && this.isBlockElement(t5.previousSibling)) return this.appendStringWithAttributes("\n");
      if (e4 === this.containerElement || this.isBlockElement(e4)) {
        var i4;
        const t6 = this.getBlockAttributes(e4), n4 = this.getBlockHTMLAttributes(e4);
        ot(t6, null === (i4 = this.currentBlock) || void 0 === i4 ? void 0 : i4.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t6, e4, n4), this.currentBlockElement = e4);
      }
    }
    appendBlockForElement(t5) {
      const e4 = this.isBlockElement(t5), i4 = C3(this.currentBlockElement, t5);
      if (e4 && !this.isBlockElement(t5.firstChild)) {
        if (!this.isInsignificantTextNode(t5.firstChild) || !this.isBlockElement(t5.firstElementChild)) {
          const e5 = this.getBlockAttributes(t5), n4 = this.getBlockHTMLAttributes(t5);
          if (t5.firstChild) {
            if (i4 && ot(e5, this.currentBlock.attributes)) return this.appendStringWithAttributes("\n");
            this.currentBlock = this.appendBlockForAttributesWithElement(e5, t5, n4), this.currentBlockElement = t5;
          }
        }
      } else if (this.currentBlockElement && !i4 && !e4) {
        const e5 = this.findParentBlockElement(t5);
        if (e5) return this.appendBlockForElement(e5);
        this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
      }
    }
    findParentBlockElement(t5) {
      let { parentElement: e4 } = t5;
      for (; e4 && e4 !== this.containerElement; ) {
        if (this.isBlockElement(e4) && this.blockElements.includes(e4)) return e4;
        e4 = e4.parentElement;
      }
      return null;
    }
    processTextNode(t5) {
      let e4 = t5.data;
      var i4;
      dn(t5.parentNode) || (e4 = Vt(e4), vn(null === (i4 = t5.previousSibling) || void 0 === i4 ? void 0 : i4.textContent) && (e4 = fn3(e4)));
      return this.appendStringWithAttributes(e4, this.getTextAttributes(t5.parentNode));
    }
    processElement(t5) {
      let e4;
      if (P3(t5)) {
        if (e4 = un(t5, "attachment"), Object.keys(e4).length) {
          const i4 = this.getTextAttributes(t5);
          this.appendAttachmentWithAttributes(e4, i4), t5.innerHTML = "";
        }
        return this.processedElements.push(t5);
      }
      switch (k3(t5)) {
        case "br":
          return this.isExtraBR(t5) || this.isBlockElement(t5.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t5)), this.processedElements.push(t5);
        case "img":
          e4 = { url: t5.getAttribute("src"), contentType: "image" };
          const i4 = ((t6) => {
            const e5 = t6.getAttribute("width"), i5 = t6.getAttribute("height"), n4 = {};
            return e5 && (n4.width = parseInt(e5, 10)), i5 && (n4.height = parseInt(i5, 10)), n4;
          })(t5);
          for (const t6 in i4) {
            const n4 = i4[t6];
            e4[t6] = n4;
          }
          return this.appendAttachmentWithAttributes(e4, this.getTextAttributes(t5)), this.processedElements.push(t5);
        case "tr":
          if (this.needsTableSeparator(t5)) return this.appendStringWithAttributes(j3.tableRowSeparator);
          break;
        case "td":
          if (this.needsTableSeparator(t5)) return this.appendStringWithAttributes(j3.tableCellSeparator);
      }
    }
    appendBlockForAttributesWithElement(t5, e4) {
      let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      this.blockElements.push(e4);
      const n4 = function() {
        return { text: [], attributes: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {} };
      }(t5, i4);
      return this.blocks.push(n4), n4;
    }
    appendEmptyBlock() {
      return this.appendBlockForAttributesWithElement([], null);
    }
    appendStringWithAttributes(t5, e4) {
      return this.appendPiece(cn(t5, e4));
    }
    appendAttachmentWithAttributes(t5, e4) {
      return this.appendPiece(function(t6) {
        return { attachment: t6, attributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, type: "attachment" };
      }(t5, e4));
    }
    appendPiece(t5) {
      return 0 === this.blocks.length && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t5);
    }
    appendStringToTextAtIndex(t5, e4) {
      const { text: i4 } = this.blocks[e4], n4 = i4[i4.length - 1];
      if ("string" !== (null == n4 ? void 0 : n4.type)) return i4.push(cn(t5));
      n4.string += t5;
    }
    prependStringToTextAtIndex(t5, e4) {
      const { text: i4 } = this.blocks[e4], n4 = i4[0];
      if ("string" !== (null == n4 ? void 0 : n4.type)) return i4.unshift(cn(t5));
      n4.string = t5 + n4.string;
    }
    getTextAttributes(t5) {
      let e4;
      const i4 = {};
      for (const n4 in W2) {
        const r4 = W2[n4];
        if (r4.tagName && y3(t5, { matchingSelector: r4.tagName, untilNode: this.containerElement })) i4[n4] = true;
        else if (r4.parser) {
          if (e4 = r4.parser(t5), e4) {
            let o4 = false;
            for (const i5 of this.findBlockElementAncestors(t5)) if (r4.parser(i5) === e4) {
              o4 = true;
              break;
            }
            o4 || (i4[n4] = e4);
          }
        } else r4.styleProperty && (e4 = t5.style[r4.styleProperty], e4 && (i4[n4] = e4));
      }
      if (P3(t5)) {
        const n4 = un(t5, "attributes");
        for (const t6 in n4) e4 = n4[t6], i4[t6] = e4;
      }
      return i4;
    }
    getBlockAttributes(t5) {
      const e4 = [];
      for (; t5 && t5 !== this.containerElement; ) {
        for (const r4 in n3) {
          const o4 = n3[r4];
          var i4;
          if (false !== o4.parse) {
            if (k3(t5) === o4.tagName) (null !== (i4 = o4.test) && void 0 !== i4 && i4.call(o4, t5) || !o4.test) && (e4.push(r4), o4.listAttribute && e4.push(o4.listAttribute));
          }
        }
        t5 = t5.parentNode;
      }
      return e4.reverse();
    }
    getBlockHTMLAttributes(t5) {
      const e4 = {}, i4 = Object.values(n3).find((e5) => e5.tagName === k3(t5));
      return ((null == i4 ? void 0 : i4.htmlAttributes) || []).forEach((i5) => {
        t5.hasAttribute(i5) && (e4[i5] = t5.getAttribute(i5));
      }), e4;
    }
    findBlockElementAncestors(t5) {
      const e4 = [];
      for (; t5 && t5 !== this.containerElement; ) {
        const i4 = k3(t5);
        L3().includes(i4) && e4.push(t5), t5 = t5.parentNode;
      }
      return e4;
    }
    isBlockElement(t5) {
      if ((null == t5 ? void 0 : t5.nodeType) === Node.ELEMENT_NODE && !P3(t5) && !y3(t5, { matchingSelector: "td", untilNode: this.containerElement })) return L3().includes(k3(t5)) || "block" === window.getComputedStyle(t5).display;
    }
    isInsignificantTextNode(t5) {
      if ((null == t5 ? void 0 : t5.nodeType) !== Node.TEXT_NODE) return;
      if (!bn(t5.data)) return;
      const { parentNode: e4, previousSibling: i4, nextSibling: n4 } = t5;
      return gn(e4.previousSibling) && !this.isBlockElement(e4.previousSibling) || dn(e4) ? void 0 : !i4 || this.isBlockElement(i4) || !n4 || this.isBlockElement(n4);
    }
    isExtraBR(t5) {
      return "br" === k3(t5) && this.isBlockElement(t5.parentNode) && t5.parentNode.lastChild === t5;
    }
    needsTableSeparator(t5) {
      if (j3.removeBlankTableCells) {
        var e4;
        const i4 = null === (e4 = t5.previousSibling) || void 0 === e4 ? void 0 : e4.textContent;
        return i4 && /\S/.test(i4);
      }
      return t5.previousSibling;
    }
    translateBlockElementMarginsToNewlines() {
      const t5 = this.getMarginOfDefaultBlockElement();
      for (let e4 = 0; e4 < this.blocks.length; e4++) {
        const i4 = this.getMarginOfBlockElementAtIndex(e4);
        i4 && (i4.top > 2 * t5.top && this.prependStringToTextAtIndex("\n", e4), i4.bottom > 2 * t5.bottom && this.appendStringToTextAtIndex("\n", e4));
      }
    }
    getMarginOfBlockElementAtIndex(t5) {
      const e4 = this.blockElements[t5];
      if (e4 && e4.textContent && !L3().includes(k3(e4)) && !this.processedElements.includes(e4)) return mn(e4);
    }
    getMarginOfDefaultBlockElement() {
      const t5 = T3(n3.default.tagName);
      return this.containerElement.appendChild(t5), mn(t5);
    }
  };
  var dn = function(t5) {
    const { whiteSpace: e4 } = window.getComputedStyle(t5);
    return ["pre", "pre-wrap", "pre-line"].includes(e4);
  };
  var gn = (t5) => t5 && !vn(t5.textContent);
  var mn = function(t5) {
    const e4 = window.getComputedStyle(t5);
    if ("block" === e4.display) return { top: parseInt(e4.marginTop), bottom: parseInt(e4.marginBottom) };
  };
  var pn = function(t5) {
    return "style" === k3(t5) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var fn3 = (t5) => t5.replace(new RegExp("^".concat(Ut.source, "+")), "");
  var bn = (t5) => new RegExp("^".concat(Ut.source, "*$")).test(t5);
  var vn = (t5) => /\s$/.test(t5);
  var An = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"];
  var yn = "data-trix-serialized-attributes";
  var xn = "[".concat(yn, "]");
  var Cn = new RegExp("<!--block-->", "g");
  var En = { "application/json": function(t5) {
    let e4;
    if (t5 instanceof an) e4 = t5;
    else {
      if (!(t5 instanceof HTMLElement)) throw new Error("unserializable object");
      e4 = hn.parse(t5.innerHTML).getDocument();
    }
    return e4.toSerializableDocument().toJSONString();
  }, "text/html": function(t5) {
    let e4;
    if (t5 instanceof an) e4 = Si.render(t5);
    else {
      if (!(t5 instanceof HTMLElement)) throw new Error("unserializable object");
      e4 = t5.cloneNode(true);
    }
    return Array.from(e4.querySelectorAll("[data-trix-serialize=false]")).forEach((t6) => {
      S3(t6);
    }), An.forEach((t6) => {
      Array.from(e4.querySelectorAll("[".concat(t6, "]"))).forEach((e5) => {
        e5.removeAttribute(t6);
      });
    }), Array.from(e4.querySelectorAll(xn)).forEach((t6) => {
      try {
        const e5 = JSON.parse(t6.getAttribute(yn));
        t6.removeAttribute(yn);
        for (const i4 in e5) {
          const n4 = e5[i4];
          t6.setAttribute(i4, n4);
        }
      } catch (t7) {
      }
    }), e4.innerHTML.replace(Cn, "");
  } };
  var Sn = Object.freeze({ __proto__: null });
  var Rn = class extends q3 {
    constructor(t5, e4) {
      super(...arguments), this.attachmentManager = t5, this.attachment = e4, this.id = this.attachment.id, this.file = this.attachment.file;
    }
    remove() {
      return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
    }
  };
  Rn.proxyMethod("attachment.getAttribute"), Rn.proxyMethod("attachment.hasAttribute"), Rn.proxyMethod("attachment.setAttribute"), Rn.proxyMethod("attachment.getAttributes"), Rn.proxyMethod("attachment.setAttributes"), Rn.proxyMethod("attachment.isPending"), Rn.proxyMethod("attachment.isPreviewable"), Rn.proxyMethod("attachment.getURL"), Rn.proxyMethod("attachment.getHref"), Rn.proxyMethod("attachment.getFilename"), Rn.proxyMethod("attachment.getFilesize"), Rn.proxyMethod("attachment.getFormattedFilesize"), Rn.proxyMethod("attachment.getExtension"), Rn.proxyMethod("attachment.getContentType"), Rn.proxyMethod("attachment.getFile"), Rn.proxyMethod("attachment.setFile"), Rn.proxyMethod("attachment.releaseFile"), Rn.proxyMethod("attachment.getUploadProgress"), Rn.proxyMethod("attachment.setUploadProgress");
  var kn = class extends q3 {
    constructor() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.managedAttachments = {}, Array.from(t5).forEach((t6) => {
        this.manageAttachment(t6);
      });
    }
    getAttachments() {
      const t5 = [];
      for (const e4 in this.managedAttachments) {
        const i4 = this.managedAttachments[e4];
        t5.push(i4);
      }
      return t5;
    }
    manageAttachment(t5) {
      return this.managedAttachments[t5.id] || (this.managedAttachments[t5.id] = new Rn(this, t5)), this.managedAttachments[t5.id];
    }
    attachmentIsManaged(t5) {
      return t5.id in this.managedAttachments;
    }
    requestRemovalOfAttachment(t5) {
      var e4, i4;
      if (this.attachmentIsManaged(t5)) return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.attachmentManagerDidRequestRemovalOfAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    unmanageAttachment(t5) {
      const e4 = this.managedAttachments[t5.id];
      return delete this.managedAttachments[t5.id], e4;
    }
  };
  var Tn = class {
    constructor(t5) {
      this.composition = t5, this.document = this.composition.document;
      const e4 = this.composition.getSelectedRange();
      this.startPosition = e4[0], this.endPosition = e4[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
    }
    shouldInsertBlockBreak() {
      return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? 0 !== this.startLocation.offset : this.breaksOnReturn && "\n" !== this.nextCharacter;
    }
    shouldBreakFormattedBlock() {
      return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && "\n" === this.nextCharacter || "\n" === this.previousCharacter);
    }
    shouldDecreaseListLevel() {
      return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
    }
    shouldPrependListItem() {
      return this.block.isListItem() && 0 === this.startLocation.offset && !this.block.isEmpty();
    }
    shouldRemoveLastBlockAttribute() {
      return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
    }
  };
  var wn = class extends q3 {
    constructor() {
      super(...arguments), this.document = new an(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
    }
    setDocument(t5) {
      var e4, i4;
      if (!t5.isEqualTo(this.document)) return this.document = t5, this.refreshAttachments(), this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidChangeDocument) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.getSelectedRange() };
    }
    loadSnapshot(t5) {
      var e4, i4, n4, r4;
      let { document: o4, selectedRange: s4 } = t5;
      return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionWillLoadSnapshot) || void 0 === i4 || i4.call(e4), this.setDocument(null != o4 ? o4 : new an()), this.setSelection(null != s4 ? s4 : [0, 0]), null === (n4 = this.delegate) || void 0 === n4 || null === (r4 = n4.compositionDidLoadSnapshot) || void 0 === r4 ? void 0 : r4.call(n4);
    }
    insertText(t5) {
      let { updatePosition: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { updatePosition: true };
      const i4 = this.getSelectedRange();
      this.setDocument(this.document.insertTextAtRange(t5, i4));
      const n4 = i4[0], r4 = n4 + t5.getLength();
      return e4 && this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n4, r4]);
    }
    insertBlock() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xi();
      const e4 = new an([t5]);
      return this.insertDocument(e4);
    }
    insertDocument() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new an();
      const e4 = this.getSelectedRange();
      this.setDocument(this.document.insertDocumentAtRange(t5, e4));
      const i4 = e4[0], n4 = i4 + t5.getLength();
      return this.setSelection(n4), this.notifyDelegateOfInsertionAtRange([i4, n4]);
    }
    insertString(t5, e4) {
      const i4 = this.getCurrentTextAttributes(), n4 = Yi.textForStringWithAttributes(t5, i4);
      return this.insertText(n4, e4);
    }
    insertBlockBreak() {
      const t5 = this.getSelectedRange();
      this.setDocument(this.document.insertBlockBreakAtRange(t5));
      const e4 = t5[0], i4 = e4 + 1;
      return this.setSelection(i4), this.notifyDelegateOfInsertionAtRange([e4, i4]);
    }
    insertLineBreak() {
      const t5 = new Tn(this);
      if (t5.shouldDecreaseListLevel()) return this.decreaseListLevel(), this.setSelection(t5.startPosition);
      if (t5.shouldPrependListItem()) {
        const e4 = new an([t5.block.copyWithoutText()]);
        return this.insertDocument(e4);
      }
      return t5.shouldInsertBlockBreak() ? this.insertBlockBreak() : t5.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t5.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t5) : this.insertString("\n");
    }
    insertHTML(t5) {
      const e4 = hn.parse(t5, { purifyOptions: { SAFE_FOR_XML: true } }).getDocument(), i4 = this.getSelectedRange();
      this.setDocument(this.document.mergeDocumentAtRange(e4, i4));
      const n4 = i4[0], r4 = n4 + e4.getLength() - 1;
      return this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n4, r4]);
    }
    replaceHTML(t5) {
      const e4 = hn.parse(t5).getDocument().copyUsingObjectsFromDocument(this.document), i4 = this.getLocationRange({ strict: false }), n4 = this.document.rangeFromLocationRange(i4);
      return this.setDocument(e4), this.setSelection(n4);
    }
    insertFile(t5) {
      return this.insertFiles([t5]);
    }
    insertFiles(t5) {
      const e4 = [];
      return Array.from(t5).forEach((t6) => {
        var i4;
        if (null !== (i4 = this.delegate) && void 0 !== i4 && i4.compositionShouldAcceptFile(t6)) {
          const i5 = Vi.attachmentForFile(t6);
          e4.push(i5);
        }
      }), this.insertAttachments(e4);
    }
    insertAttachment(t5) {
      return this.insertAttachments([t5]);
    }
    insertAttachments(t5) {
      let e4 = new Yi();
      return Array.from(t5).forEach((t6) => {
        var n4;
        const r4 = t6.getType(), o4 = null === (n4 = i3[r4]) || void 0 === n4 ? void 0 : n4.presentation, s4 = this.getCurrentTextAttributes();
        o4 && (s4.presentation = o4);
        const a4 = Yi.textForAttachmentWithAttributes(t6, s4);
        e4 = e4.appendText(a4);
      }), this.insertText(e4);
    }
    shouldManageDeletingInDirection(t5) {
      const e4 = this.getLocationRange();
      if (Lt(e4)) {
        if ("backward" === t5 && 0 === e4[0].offset) return true;
        if (this.shouldManageMovingCursorInDirection(t5)) return true;
      } else if (e4[0].index !== e4[1].index) return true;
      return false;
    }
    deleteInDirection(t5) {
      let e4, i4, n4, { length: r4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const o4 = this.getLocationRange();
      let s4 = this.getSelectedRange();
      const a4 = Lt(s4);
      if (a4 ? i4 = "backward" === t5 && 0 === o4[0].offset : n4 = o4[0].index !== o4[1].index, i4 && this.canDecreaseBlockAttributeLevel()) {
        const t6 = this.getBlock();
        if (t6.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s4[0]), t6.isEmpty()) return false;
      }
      return a4 && (s4 = this.getExpandedRangeInDirection(t5, { length: r4 }), "backward" === t5 && (e4 = this.getAttachmentAtRange(s4))), e4 ? (this.editAttachment(e4), false) : (this.setDocument(this.document.removeTextAtRange(s4)), this.setSelection(s4[0]), !i4 && !n4 && void 0);
    }
    moveTextFromRange(t5) {
      const [e4] = Array.from(this.getSelectedRange());
      return this.setDocument(this.document.moveTextFromRangeToPosition(t5, e4)), this.setSelection(e4);
    }
    removeAttachment(t5) {
      const e4 = this.document.getRangeOfAttachment(t5);
      if (e4) return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e4)), this.setSelection(e4[0]);
    }
    removeLastBlockAttribute() {
      const [t5, e4] = Array.from(this.getSelectedRange()), i4 = this.document.getBlockAtPosition(e4);
      return this.removeCurrentAttribute(i4.getLastAttribute()), this.setSelection(t5);
    }
    insertPlaceholder() {
      return this.placeholderPosition = this.getPosition(), this.insertString(" ");
    }
    selectPlaceholder() {
      if (null != this.placeholderPosition) return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
    }
    forgetPlaceholder() {
      this.placeholderPosition = null;
    }
    hasCurrentAttribute(t5) {
      const e4 = this.currentAttributes[t5];
      return null != e4 && false !== e4;
    }
    toggleCurrentAttribute(t5) {
      const e4 = !this.currentAttributes[t5];
      return e4 ? this.setCurrentAttribute(t5, e4) : this.removeCurrentAttribute(t5);
    }
    canSetCurrentAttribute(t5) {
      return mt(t5) ? this.canSetCurrentBlockAttribute(t5) : this.canSetCurrentTextAttribute(t5);
    }
    canSetCurrentTextAttribute(t5) {
      const e4 = this.getSelectedDocument();
      if (e4) {
        for (const t6 of Array.from(e4.getAttachments())) if (!t6.hasContent()) return false;
        return true;
      }
    }
    canSetCurrentBlockAttribute(t5) {
      const e4 = this.getBlock();
      if (e4) return !e4.isTerminalBlock();
    }
    setCurrentAttribute(t5, e4) {
      return mt(t5) ? this.setBlockAttribute(t5, e4) : (this.setTextAttribute(t5, e4), this.currentAttributes[t5] = e4, this.notifyDelegateOfCurrentAttributesChange());
    }
    setHTMLAtributeAtPosition(t5, e4, i4) {
      var n4;
      const r4 = this.document.getBlockAtPosition(t5), o4 = null === (n4 = mt(r4.getLastAttribute())) || void 0 === n4 ? void 0 : n4.htmlAttributes;
      if (r4 && null != o4 && o4.includes(e4)) {
        const n5 = this.document.setHTMLAttributeAtPosition(t5, e4, i4);
        this.setDocument(n5);
      }
    }
    setTextAttribute(t5, e4) {
      const i4 = this.getSelectedRange();
      if (!i4) return;
      const [n4, r4] = Array.from(i4);
      if (n4 !== r4) return this.setDocument(this.document.addAttributeAtRange(t5, e4, i4));
      if ("href" === t5) {
        const t6 = Yi.textForStringWithAttributes(e4, { href: e4 });
        return this.insertText(t6);
      }
    }
    setBlockAttribute(t5, e4) {
      const i4 = this.getSelectedRange();
      if (this.canSetCurrentAttribute(t5)) return this.setDocument(this.document.applyBlockAttributeAtRange(t5, e4, i4)), this.setSelection(i4);
    }
    removeCurrentAttribute(t5) {
      return mt(t5) ? (this.removeBlockAttribute(t5), this.updateCurrentAttributes()) : (this.removeTextAttribute(t5), delete this.currentAttributes[t5], this.notifyDelegateOfCurrentAttributesChange());
    }
    removeTextAttribute(t5) {
      const e4 = this.getSelectedRange();
      if (e4) return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
    }
    removeBlockAttribute(t5) {
      const e4 = this.getSelectedRange();
      if (e4) return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
    }
    canDecreaseNestingLevel() {
      var t5;
      return (null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getNestingLevel()) > 0;
    }
    canIncreaseNestingLevel() {
      var t5;
      const e4 = this.getBlock();
      if (e4) {
        if (null === (t5 = mt(e4.getLastNestableAttribute())) || void 0 === t5 || !t5.listAttribute) return e4.getNestingLevel() > 0;
        {
          const t6 = this.getPreviousBlock();
          if (t6) return function() {
            let t7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return ot((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).slice(0, t7.length), t7);
          }(t6.getListItemAttributes(), e4.getListItemAttributes());
        }
      }
    }
    decreaseNestingLevel() {
      const t5 = this.getBlock();
      if (t5) return this.setDocument(this.document.replaceBlock(t5, t5.decreaseNestingLevel()));
    }
    increaseNestingLevel() {
      const t5 = this.getBlock();
      if (t5) return this.setDocument(this.document.replaceBlock(t5, t5.increaseNestingLevel()));
    }
    canDecreaseBlockAttributeLevel() {
      var t5;
      return (null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getAttributeLevel()) > 0;
    }
    decreaseBlockAttributeLevel() {
      var t5;
      const e4 = null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getLastAttribute();
      if (e4) return this.removeCurrentAttribute(e4);
    }
    decreaseListLevel() {
      let [t5] = Array.from(this.getSelectedRange());
      const { index: e4 } = this.document.locationFromPosition(t5);
      let i4 = e4;
      const n4 = this.getBlock().getAttributeLevel();
      let r4 = this.document.getBlockAtIndex(i4 + 1);
      for (; r4 && r4.isListItem() && !(r4.getAttributeLevel() <= n4); ) i4++, r4 = this.document.getBlockAtIndex(i4 + 1);
      t5 = this.document.positionFromLocation({ index: e4, offset: 0 });
      const o4 = this.document.positionFromLocation({ index: i4, offset: 0 });
      return this.setDocument(this.document.removeLastListAttributeAtRange([t5, o4]));
    }
    updateCurrentAttributes() {
      const t5 = this.getSelectedRange({ ignoreLock: true });
      if (t5) {
        const e4 = this.document.getCommonAttributesAtRange(t5);
        if (Array.from(gt()).forEach((t6) => {
          e4[t6] || this.canSetCurrentAttribute(t6) || (e4[t6] = false);
        }), !Tt(e4, this.currentAttributes)) return this.currentAttributes = e4, this.notifyDelegateOfCurrentAttributesChange();
      }
    }
    getCurrentAttributes() {
      return m3.call({}, this.currentAttributes);
    }
    getCurrentTextAttributes() {
      const t5 = {};
      for (const e4 in this.currentAttributes) {
        const i4 = this.currentAttributes[e4];
        false !== i4 && ft(e4) && (t5[e4] = i4);
      }
      return t5;
    }
    freezeSelection() {
      return this.setCurrentAttribute("frozen", true);
    }
    thawSelection() {
      return this.removeCurrentAttribute("frozen");
    }
    hasFrozenSelection() {
      return this.hasCurrentAttribute("frozen");
    }
    setSelection(t5) {
      var e4;
      const i4 = this.document.locationRangeFromRange(t5);
      return null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.compositionDidRequestChangingSelectionToLocationRange(i4);
    }
    getSelectedRange() {
      const t5 = this.getLocationRange();
      if (t5) return this.document.rangeFromLocationRange(t5);
    }
    setSelectedRange(t5) {
      const e4 = this.document.locationRangeFromRange(t5);
      return this.getSelectionManager().setLocationRange(e4);
    }
    getPosition() {
      const t5 = this.getLocationRange();
      if (t5) return this.document.positionFromLocation(t5[0]);
    }
    getLocationRange(t5) {
      return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t5) || wt({ index: 0, offset: 0 });
    }
    withTargetLocationRange(t5, e4) {
      let i4;
      this.targetLocationRange = t5;
      try {
        i4 = e4();
      } finally {
        this.targetLocationRange = null;
      }
      return i4;
    }
    withTargetRange(t5, e4) {
      const i4 = this.document.locationRangeFromRange(t5);
      return this.withTargetLocationRange(i4, e4);
    }
    withTargetDOMRange(t5, e4) {
      const i4 = this.createLocationRangeFromDOMRange(t5, { strict: false });
      return this.withTargetLocationRange(i4, e4);
    }
    getExpandedRangeInDirection(t5) {
      let { length: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, [i4, n4] = Array.from(this.getSelectedRange());
      return "backward" === t5 ? e4 ? i4 -= e4 : i4 = this.translateUTF16PositionFromOffset(i4, -1) : e4 ? n4 += e4 : n4 = this.translateUTF16PositionFromOffset(n4, 1), wt([i4, n4]);
    }
    shouldManageMovingCursorInDirection(t5) {
      if (this.editingAttachment) return true;
      const e4 = this.getExpandedRangeInDirection(t5);
      return null != this.getAttachmentAtRange(e4);
    }
    moveCursorInDirection(t5) {
      let e4, i4;
      if (this.editingAttachment) i4 = this.document.getRangeOfAttachment(this.editingAttachment);
      else {
        const n4 = this.getSelectedRange();
        i4 = this.getExpandedRangeInDirection(t5), e4 = !Dt(n4, i4);
      }
      if ("backward" === t5 ? this.setSelectedRange(i4[0]) : this.setSelectedRange(i4[1]), e4) {
        const t6 = this.getAttachmentAtRange(i4);
        if (t6) return this.editAttachment(t6);
      }
    }
    expandSelectionInDirection(t5) {
      let { length: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const i4 = this.getExpandedRangeInDirection(t5, { length: e4 });
      return this.setSelectedRange(i4);
    }
    expandSelectionForEditing() {
      if (this.hasCurrentAttribute("href")) return this.expandSelectionAroundCommonAttribute("href");
    }
    expandSelectionAroundCommonAttribute(t5) {
      const e4 = this.getPosition(), i4 = this.document.getRangeOfCommonAttributeAtPosition(t5, e4);
      return this.setSelectedRange(i4);
    }
    selectionContainsAttachments() {
      var t5;
      return (null === (t5 = this.getSelectedAttachments()) || void 0 === t5 ? void 0 : t5.length) > 0;
    }
    selectionIsInCursorTarget() {
      return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
    }
    positionIsCursorTarget(t5) {
      const e4 = this.document.locationFromPosition(t5);
      if (e4) return this.locationIsCursorTarget(e4);
    }
    positionIsBlockBreak(t5) {
      var e4;
      return null === (e4 = this.document.getPieceAtPosition(t5)) || void 0 === e4 ? void 0 : e4.isBlockBreak();
    }
    getSelectedDocument() {
      const t5 = this.getSelectedRange();
      if (t5) return this.document.getDocumentAtRange(t5);
    }
    getSelectedAttachments() {
      var t5;
      return null === (t5 = this.getSelectedDocument()) || void 0 === t5 ? void 0 : t5.getAttachments();
    }
    getAttachments() {
      return this.attachments.slice(0);
    }
    refreshAttachments() {
      const t5 = this.document.getAttachments(), { added: e4, removed: i4 } = function() {
        let t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        const i5 = [], n4 = [], r4 = /* @__PURE__ */ new Set();
        t6.forEach((t7) => {
          r4.add(t7);
        });
        const o4 = /* @__PURE__ */ new Set();
        return e5.forEach((t7) => {
          o4.add(t7), r4.has(t7) || i5.push(t7);
        }), t6.forEach((t7) => {
          o4.has(t7) || n4.push(t7);
        }), { added: i5, removed: n4 };
      }(this.attachments, t5);
      return this.attachments = t5, Array.from(i4).forEach((t6) => {
        var e5, i5;
        t6.delegate = null, null === (e5 = this.delegate) || void 0 === e5 || null === (i5 = e5.compositionDidRemoveAttachment) || void 0 === i5 || i5.call(e5, t6);
      }), (() => {
        const t6 = [];
        return Array.from(e4).forEach((e5) => {
          var i5, n4;
          e5.delegate = this, t6.push(null === (i5 = this.delegate) || void 0 === i5 || null === (n4 = i5.compositionDidAddAttachment) || void 0 === n4 ? void 0 : n4.call(i5, e5));
        }), t6;
      })();
    }
    attachmentDidChangeAttributes(t5) {
      var e4, i4;
      return this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidEditAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    attachmentDidChangePreviewURL(t5) {
      var e4, i4;
      return this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidChangeAttachmentPreviewURL) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    editAttachment(t5, e4) {
      var i4, n4;
      if (t5 !== this.editingAttachment) return this.stopEditingAttachment(), this.editingAttachment = t5, null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.compositionDidStartEditingAttachment) || void 0 === n4 ? void 0 : n4.call(i4, this.editingAttachment, e4);
    }
    stopEditingAttachment() {
      var t5, e4;
      this.editingAttachment && (null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionDidStopEditingAttachment) || void 0 === e4 || e4.call(t5, this.editingAttachment), this.editingAttachment = null);
    }
    updateAttributesForAttachment(t5, e4) {
      return this.setDocument(this.document.updateAttributesForAttachment(t5, e4));
    }
    removeAttributeForAttachment(t5, e4) {
      return this.setDocument(this.document.removeAttributeForAttachment(t5, e4));
    }
    breakFormattedBlock(t5) {
      let { document: e4 } = t5;
      const { block: i4 } = t5;
      let n4 = t5.startPosition, r4 = [n4 - 1, n4];
      i4.getBlockBreakPosition() === t5.startLocation.offset ? (i4.breaksOnReturn() && "\n" === t5.nextCharacter ? n4 += 1 : e4 = e4.removeTextAtRange(r4), r4 = [n4, n4]) : "\n" === t5.nextCharacter ? "\n" === t5.previousCharacter ? r4 = [n4 - 1, n4 + 1] : (r4 = [n4, n4 + 1], n4 += 1) : t5.startLocation.offset - 1 != 0 && (n4 += 1);
      const o4 = new an([i4.removeLastAttribute().copyWithoutText()]);
      return this.setDocument(e4.insertDocumentAtRange(o4, r4)), this.setSelection(n4);
    }
    getPreviousBlock() {
      const t5 = this.getLocationRange();
      if (t5) {
        const { index: e4 } = t5[0];
        if (e4 > 0) return this.document.getBlockAtIndex(e4 - 1);
      }
    }
    getBlock() {
      const t5 = this.getLocationRange();
      if (t5) return this.document.getBlockAtIndex(t5[0].index);
    }
    getAttachmentAtRange(t5) {
      const e4 = this.document.getDocumentAtRange(t5);
      if (e4.toString() === "".concat("\uFFFC", "\n")) return e4.getAttachments()[0];
    }
    notifyDelegateOfCurrentAttributesChange() {
      var t5, e4;
      return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionDidChangeCurrentAttributes) || void 0 === e4 ? void 0 : e4.call(t5, this.currentAttributes);
    }
    notifyDelegateOfInsertionAtRange(t5) {
      var e4, i4;
      return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidPerformInsertionAtRange) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    translateUTF16PositionFromOffset(t5, e4) {
      const i4 = this.document.toUTF16String(), n4 = i4.offsetFromUCS2Offset(t5);
      return i4.offsetToUCS2Offset(n4 + e4);
    }
  };
  wn.proxyMethod("getSelectionManager().getPointRange"), wn.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), wn.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), wn.proxyMethod("getSelectionManager().locationIsCursorTarget"), wn.proxyMethod("getSelectionManager().selectionIsExpanded"), wn.proxyMethod("delegate?.getSelectionManager");
  var Ln = class extends q3 {
    constructor(t5) {
      super(...arguments), this.composition = t5, this.undoEntries = [], this.redoEntries = [];
    }
    recordUndoEntry(t5) {
      let { context: e4, consolidatable: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const n4 = this.undoEntries.slice(-1)[0];
      if (!i4 || !Dn(n4, t5, e4)) {
        const i5 = this.createEntry({ description: t5, context: e4 });
        this.undoEntries.push(i5), this.redoEntries = [];
      }
    }
    undo() {
      const t5 = this.undoEntries.pop();
      if (t5) {
        const e4 = this.createEntry(t5);
        return this.redoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
      }
    }
    redo() {
      const t5 = this.redoEntries.pop();
      if (t5) {
        const e4 = this.createEntry(t5);
        return this.undoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
      }
    }
    canUndo() {
      return this.undoEntries.length > 0;
    }
    canRedo() {
      return this.redoEntries.length > 0;
    }
    createEntry() {
      let { description: t5, context: e4 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return { description: null == t5 ? void 0 : t5.toString(), context: JSON.stringify(e4), snapshot: this.composition.getSnapshot() };
    }
  };
  var Dn = (t5, e4, i4) => (null == t5 ? void 0 : t5.description) === (null == e4 ? void 0 : e4.toString()) && (null == t5 ? void 0 : t5.context) === JSON.stringify(i4);
  var Nn = "attachmentGallery";
  var In = class {
    constructor(t5) {
      this.document = t5.document, this.selectedRange = t5.selectedRange;
    }
    perform() {
      return this.removeBlockAttribute(), this.applyBlockAttribute();
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.selectedRange };
    }
    removeBlockAttribute() {
      return this.findRangesOfBlocks().map((t5) => this.document = this.document.removeAttributeAtRange(Nn, t5));
    }
    applyBlockAttribute() {
      let t5 = 0;
      this.findRangesOfPieces().forEach((e4) => {
        e4[1] - e4[0] > 1 && (e4[0] += t5, e4[1] += t5, "\n" !== this.document.getCharacterAtPosition(e4[1]) && (this.document = this.document.insertBlockBreakAtRange(e4[1]), e4[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e4[1]++, t5++), 0 !== e4[0] && "\n" !== this.document.getCharacterAtPosition(e4[0] - 1) && (this.document = this.document.insertBlockBreakAtRange(e4[0]), e4[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e4[0]++, t5++), this.document = this.document.applyBlockAttributeAtRange(Nn, true, e4));
      });
    }
    findRangesOfBlocks() {
      return this.document.findRangesForBlockAttribute(Nn);
    }
    findRangesOfPieces() {
      return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
    }
    moveSelectedRangeForward() {
      this.selectedRange[0] += 1, this.selectedRange[1] += 1;
    }
  };
  var On = function(t5) {
    const e4 = new In(t5);
    return e4.perform(), e4.getSnapshot();
  };
  var Fn = [On];
  var Pn = class {
    constructor(t5, e4, i4) {
      this.insertFiles = this.insertFiles.bind(this), this.composition = t5, this.selectionManager = e4, this.element = i4, this.undoManager = new Ln(this.composition), this.filters = Fn.slice(0);
    }
    loadDocument(t5) {
      return this.loadSnapshot({ document: t5, selectedRange: [0, 0] });
    }
    loadHTML() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      const e4 = hn.parse(t5, { referenceElement: this.element }).getDocument();
      return this.loadDocument(e4);
    }
    loadJSON(t5) {
      let { document: e4, selectedRange: i4 } = t5;
      return e4 = an.fromJSON(e4), this.loadSnapshot({ document: e4, selectedRange: i4 });
    }
    loadSnapshot(t5) {
      return this.undoManager = new Ln(this.composition), this.composition.loadSnapshot(t5);
    }
    getDocument() {
      return this.composition.document;
    }
    getSelectedDocument() {
      return this.composition.getSelectedDocument();
    }
    getSnapshot() {
      return this.composition.getSnapshot();
    }
    toJSON() {
      return this.getSnapshot();
    }
    deleteInDirection(t5) {
      return this.composition.deleteInDirection(t5);
    }
    insertAttachment(t5) {
      return this.composition.insertAttachment(t5);
    }
    insertAttachments(t5) {
      return this.composition.insertAttachments(t5);
    }
    insertDocument(t5) {
      return this.composition.insertDocument(t5);
    }
    insertFile(t5) {
      return this.composition.insertFile(t5);
    }
    insertFiles(t5) {
      return this.composition.insertFiles(t5);
    }
    insertHTML(t5) {
      return this.composition.insertHTML(t5);
    }
    insertString(t5) {
      return this.composition.insertString(t5);
    }
    insertText(t5) {
      return this.composition.insertText(t5);
    }
    insertLineBreak() {
      return this.composition.insertLineBreak();
    }
    getSelectedRange() {
      return this.composition.getSelectedRange();
    }
    getPosition() {
      return this.composition.getPosition();
    }
    getClientRectAtPosition(t5) {
      const e4 = this.getDocument().locationRangeFromRange([t5, t5 + 1]);
      return this.selectionManager.getClientRectAtLocationRange(e4);
    }
    expandSelectionInDirection(t5) {
      return this.composition.expandSelectionInDirection(t5);
    }
    moveCursorInDirection(t5) {
      return this.composition.moveCursorInDirection(t5);
    }
    setSelectedRange(t5) {
      return this.composition.setSelectedRange(t5);
    }
    activateAttribute(t5) {
      let e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return this.composition.setCurrentAttribute(t5, e4);
    }
    attributeIsActive(t5) {
      return this.composition.hasCurrentAttribute(t5);
    }
    canActivateAttribute(t5) {
      return this.composition.canSetCurrentAttribute(t5);
    }
    deactivateAttribute(t5) {
      return this.composition.removeCurrentAttribute(t5);
    }
    setHTMLAtributeAtPosition(t5, e4, i4) {
      this.composition.setHTMLAtributeAtPosition(t5, e4, i4);
    }
    canDecreaseNestingLevel() {
      return this.composition.canDecreaseNestingLevel();
    }
    canIncreaseNestingLevel() {
      return this.composition.canIncreaseNestingLevel();
    }
    decreaseNestingLevel() {
      if (this.canDecreaseNestingLevel()) return this.composition.decreaseNestingLevel();
    }
    increaseNestingLevel() {
      if (this.canIncreaseNestingLevel()) return this.composition.increaseNestingLevel();
    }
    canRedo() {
      return this.undoManager.canRedo();
    }
    canUndo() {
      return this.undoManager.canUndo();
    }
    recordUndoEntry(t5) {
      let { context: e4, consolidatable: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return this.undoManager.recordUndoEntry(t5, { context: e4, consolidatable: i4 });
    }
    redo() {
      if (this.canRedo()) return this.undoManager.redo();
    }
    undo() {
      if (this.canUndo()) return this.undoManager.undo();
    }
  };
  var Mn = class {
    constructor(t5) {
      this.element = t5;
    }
    findLocationFromContainerAndOffset(t5, e4) {
      let { strict: i4 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { strict: true }, n4 = 0, r4 = false;
      const o4 = { index: 0, offset: 0 }, s4 = this.findAttachmentElementParentForNode(t5);
      s4 && (t5 = s4.parentNode, e4 = E2(s4));
      const a4 = R2(this.element, { usingFilter: Wn });
      for (; a4.nextNode(); ) {
        const s5 = a4.currentNode;
        if (s5 === t5 && B3(t5)) {
          F3(s5) || (o4.offset += e4);
          break;
        }
        if (s5.parentNode === t5) {
          if (n4++ === e4) break;
        } else if (!C3(t5, s5) && n4 > 0) break;
        N3(s5, { strict: i4 }) ? (r4 && o4.index++, o4.offset = 0, r4 = true) : o4.offset += Bn(s5);
      }
      return o4;
    }
    findContainerAndOffsetFromLocation(t5) {
      let e4, i4;
      if (0 === t5.index && 0 === t5.offset) {
        for (e4 = this.element, i4 = 0; e4.firstChild; ) if (e4 = e4.firstChild, D3(e4)) {
          i4 = 1;
          break;
        }
        return [e4, i4];
      }
      let [n4, r4] = this.findNodeAndOffsetFromLocation(t5);
      if (n4) {
        if (B3(n4)) 0 === Bn(n4) ? (e4 = n4.parentNode.parentNode, i4 = E2(n4.parentNode), F3(n4, { name: "right" }) && i4++) : (e4 = n4, i4 = t5.offset - r4);
        else {
          if (e4 = n4.parentNode, !N3(n4.previousSibling) && !D3(e4)) for (; n4 === e4.lastChild && (n4 = e4, e4 = e4.parentNode, !D3(e4)); ) ;
          i4 = E2(n4), 0 !== t5.offset && i4++;
        }
        return [e4, i4];
      }
    }
    findNodeAndOffsetFromLocation(t5) {
      let e4, i4, n4 = 0;
      for (const r4 of this.getSignificantNodesForIndex(t5.index)) {
        const o4 = Bn(r4);
        if (t5.offset <= n4 + o4) if (B3(r4)) {
          if (e4 = r4, i4 = n4, t5.offset === i4 && F3(e4)) break;
        } else e4 || (e4 = r4, i4 = n4);
        if (n4 += o4, n4 > t5.offset) break;
      }
      return [e4, i4];
    }
    findAttachmentElementParentForNode(t5) {
      for (; t5 && t5 !== this.element; ) {
        if (P3(t5)) return t5;
        t5 = t5.parentNode;
      }
    }
    getSignificantNodesForIndex(t5) {
      const e4 = [], i4 = R2(this.element, { usingFilter: _n });
      let n4 = false;
      for (; i4.nextNode(); ) {
        const o4 = i4.currentNode;
        var r4;
        if (I3(o4)) {
          if (null != r4 ? r4++ : r4 = 0, r4 === t5) n4 = true;
          else if (n4) break;
        } else n4 && e4.push(o4);
      }
      return e4;
    }
  };
  var Bn = function(t5) {
    if (t5.nodeType === Node.TEXT_NODE) {
      if (F3(t5)) return 0;
      return t5.textContent.length;
    }
    return "br" === k3(t5) || P3(t5) ? 1 : 0;
  };
  var _n = function(t5) {
    return jn(t5) === NodeFilter.FILTER_ACCEPT ? Wn(t5) : NodeFilter.FILTER_REJECT;
  };
  var jn = function(t5) {
    return M3(t5) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Wn = function(t5) {
    return P3(t5.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Un = class {
    createDOMRangeFromPoint(t5) {
      let e4, { x: i4, y: n4 } = t5;
      if (document.caretPositionFromPoint) {
        const { offsetNode: t6, offset: r4 } = document.caretPositionFromPoint(i4, n4);
        return e4 = document.createRange(), e4.setStart(t6, r4), e4;
      }
      if (document.caretRangeFromPoint) return document.caretRangeFromPoint(i4, n4);
      if (document.body.createTextRange) {
        const t6 = Mt();
        try {
          const t7 = document.body.createTextRange();
          t7.moveToPoint(i4, n4), t7.select();
        } catch (t7) {
        }
        return e4 = Mt(), Bt(t6), e4;
      }
    }
    getClientRectsForDOMRange(t5) {
      const e4 = Array.from(t5.getClientRects());
      return [e4[0], e4[e4.length - 1]];
    }
  };
  var Vn = class extends q3 {
    constructor(t5) {
      super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t5, this.locationMapper = new Mn(this.element), this.pointMapper = new Un(), this.lockCount = 0, b3("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
    }
    getLocationRange() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return false === t5.strict ? this.createLocationRangeFromDOMRange(Mt()) : t5.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
    }
    setLocationRange(t5) {
      if (this.lockedLocationRange) return;
      t5 = wt(t5);
      const e4 = this.createDOMRangeFromLocationRange(t5);
      e4 && (Bt(e4), this.updateCurrentLocationRange(t5));
    }
    setLocationRangeFromPointRange(t5) {
      t5 = wt(t5);
      const e4 = this.getLocationAtPoint(t5[0]), i4 = this.getLocationAtPoint(t5[1]);
      this.setLocationRange([e4, i4]);
    }
    getClientRectAtLocationRange(t5) {
      const e4 = this.createDOMRangeFromLocationRange(t5);
      if (e4) return this.getClientRectsForDOMRange(e4)[1];
    }
    locationIsCursorTarget(t5) {
      const e4 = Array.from(this.findNodeAndOffsetFromLocation(t5))[0];
      return F3(e4);
    }
    lock() {
      0 == this.lockCount++ && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
    }
    unlock() {
      if (0 == --this.lockCount) {
        const { lockedLocationRange: t5 } = this;
        if (this.lockedLocationRange = null, null != t5) return this.setLocationRange(t5);
      }
    }
    clearSelection() {
      var t5;
      return null === (t5 = Pt()) || void 0 === t5 ? void 0 : t5.removeAllRanges();
    }
    selectionIsCollapsed() {
      var t5;
      return true === (null === (t5 = Mt()) || void 0 === t5 ? void 0 : t5.collapsed);
    }
    selectionIsExpanded() {
      return !this.selectionIsCollapsed();
    }
    createLocationRangeFromDOMRange(t5, e4) {
      if (null == t5 || !this.domRangeWithinElement(t5)) return;
      const i4 = this.findLocationFromContainerAndOffset(t5.startContainer, t5.startOffset, e4);
      if (!i4) return;
      const n4 = t5.collapsed ? void 0 : this.findLocationFromContainerAndOffset(t5.endContainer, t5.endOffset, e4);
      return wt([i4, n4]);
    }
    didMouseDown() {
      return this.pauseTemporarily();
    }
    pauseTemporarily() {
      let t5;
      this.paused = true;
      const e4 = () => {
        if (this.paused = false, clearTimeout(i4), Array.from(t5).forEach((t6) => {
          t6.destroy();
        }), C3(document, this.element)) return this.selectionDidChange();
      }, i4 = setTimeout(e4, 200);
      t5 = ["mousemove", "keydown"].map((t6) => b3(t6, { onElement: document, withCallback: e4 }));
    }
    selectionDidChange() {
      if (!this.paused && !x3(this.element)) return this.updateCurrentLocationRange();
    }
    updateCurrentLocationRange(t5) {
      var e4, i4;
      if ((null != t5 ? t5 : t5 = this.createLocationRangeFromDOMRange(Mt())) && !Dt(t5, this.currentLocationRange)) return this.currentLocationRange = t5, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.locationRangeDidChange) || void 0 === i4 ? void 0 : i4.call(e4, this.currentLocationRange.slice(0));
    }
    createDOMRangeFromLocationRange(t5) {
      const e4 = this.findContainerAndOffsetFromLocation(t5[0]), i4 = Lt(t5) ? e4 : this.findContainerAndOffsetFromLocation(t5[1]) || e4;
      if (null != e4 && null != i4) {
        const t6 = document.createRange();
        return t6.setStart(...Array.from(e4 || [])), t6.setEnd(...Array.from(i4 || [])), t6;
      }
    }
    getLocationAtPoint(t5) {
      const e4 = this.createDOMRangeFromPoint(t5);
      var i4;
      if (e4) return null === (i4 = this.createLocationRangeFromDOMRange(e4)) || void 0 === i4 ? void 0 : i4[0];
    }
    domRangeWithinElement(t5) {
      return t5.collapsed ? C3(this.element, t5.startContainer) : C3(this.element, t5.startContainer) && C3(this.element, t5.endContainer);
    }
  };
  Vn.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Vn.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Vn.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Vn.proxyMethod("pointMapper.createDOMRangeFromPoint"), Vn.proxyMethod("pointMapper.getClientRectsForDOMRange");
  var zn = Object.freeze({ __proto__: null, Attachment: Vi, AttachmentManager: kn, AttachmentPiece: zi, Block: Xi, Composition: wn, Document: an, Editor: Pn, HTMLParser: hn, HTMLSanitizer: di, LineBreakInsertion: Tn, LocationMapper: Mn, ManagedAttachment: Rn, Piece: Wi, PointMapper: Un, SelectionManager: Vn, SplittableList: Hi, StringPiece: qi, Text: Yi, UndoManager: Ln });
  var qn = Object.freeze({ __proto__: null, ObjectView: ie2, AttachmentView: pi, BlockView: Ei, DocumentView: Si, PieceView: Ai, PreviewableAttachmentView: vi, TextView: yi });
  var { lang: Hn, css: Jn, keyNames: Kn } = z3;
  var Gn = function(t5) {
    return function() {
      const e4 = t5.apply(this, arguments);
      e4.do(), this.undos || (this.undos = []), this.undos.push(e4.undo);
    };
  };
  var Yn = class extends q3 {
    constructor(t5, e4, i4) {
      let n4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      super(...arguments), Di(this, "makeElementMutable", Gn(() => ({ do: () => {
        this.element.dataset.trixMutable = true;
      }, undo: () => delete this.element.dataset.trixMutable }))), Di(this, "addToolbar", Gn(() => {
        const t6 = T3({ tagName: "div", className: Jn.attachmentToolbar, data: { trixMutable: true }, childNodes: T3({ tagName: "div", className: "trix-button-row", childNodes: T3({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: T3({ tagName: "button", className: "trix-button trix-button--remove", textContent: Hn.remove, attributes: { title: Hn.remove }, data: { trixAction: "remove" } }) }) }) });
        return this.attachment.isPreviewable() && t6.appendChild(T3({ tagName: "div", className: Jn.attachmentMetadataContainer, childNodes: T3({ tagName: "span", className: Jn.attachmentMetadata, childNodes: [T3({ tagName: "span", className: Jn.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), T3({ tagName: "span", className: Jn.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), b3("click", { onElement: t6, withCallback: this.didClickToolbar }), b3("click", { onElement: t6, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), v3("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t6, attachment: this.attachment } }), { do: () => this.element.appendChild(t6), undo: () => S3(t6) };
      })), Di(this, "installCaptionEditor", Gn(() => {
        const t6 = T3({ tagName: "textarea", className: Jn.attachmentCaptionEditor, attributes: { placeholder: Hn.captionPlaceholder }, data: { trixMutable: true } });
        t6.value = this.attachmentPiece.getCaption();
        const e5 = t6.cloneNode();
        e5.classList.add("trix-autoresize-clone"), e5.tabIndex = -1;
        const i5 = function() {
          e5.value = t6.value, t6.style.height = e5.scrollHeight + "px";
        };
        b3("input", { onElement: t6, withCallback: i5 }), b3("input", { onElement: t6, withCallback: this.didInputCaption }), b3("keydown", { onElement: t6, withCallback: this.didKeyDownCaption }), b3("change", { onElement: t6, withCallback: this.didChangeCaption }), b3("blur", { onElement: t6, withCallback: this.didBlurCaption });
        const n5 = this.element.querySelector("figcaption"), r4 = n5.cloneNode();
        return { do: () => {
          if (n5.style.display = "none", r4.appendChild(t6), r4.appendChild(e5), r4.classList.add("".concat(Jn.attachmentCaption, "--editing")), n5.parentElement.insertBefore(r4, n5), i5(), this.options.editCaption) return Rt(() => t6.focus());
        }, undo() {
          S3(r4), n5.style.display = null;
        } };
      })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t5, this.element = e4, this.container = i4, this.options = n4, this.attachment = this.attachmentPiece.attachment, "a" === k3(this.element) && (this.element = this.element.firstChild), this.install();
    }
    install() {
      this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
    }
    uninstall() {
      var t5;
      let e4 = this.undos.pop();
      for (this.savePendingCaption(); e4; ) e4(), e4 = this.undos.pop();
      null === (t5 = this.delegate) || void 0 === t5 || t5.didUninstallAttachmentEditor(this);
    }
    savePendingCaption() {
      if (null != this.pendingCaption) {
        const r4 = this.pendingCaption;
        var t5, e4, i4, n4;
        if (this.pendingCaption = null, r4) null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.attachmentEditorDidRequestUpdatingAttributesForAttachment) || void 0 === e4 || e4.call(t5, { caption: r4 }, this.attachment);
        else null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.attachmentEditorDidRequestRemovingAttributeForAttachment) || void 0 === n4 || n4.call(i4, "caption", this.attachment);
      }
    }
    didClickToolbar(t5) {
      return t5.preventDefault(), t5.stopPropagation();
    }
    didClickActionButton(t5) {
      var e4;
      if ("remove" === t5.target.getAttribute("data-trix-action")) return null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
    }
    didKeyDownCaption(t5) {
      var e4, i4;
      if ("return" === Kn[t5.keyCode]) return t5.preventDefault(), this.savePendingCaption(), null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.attachmentEditorDidRequestDeselectingAttachment) || void 0 === i4 ? void 0 : i4.call(e4, this.attachment);
    }
    didInputCaption(t5) {
      this.pendingCaption = t5.target.value.replace(/\s/g, " ").trim();
    }
    didChangeCaption(t5) {
      return this.savePendingCaption();
    }
    didBlurCaption(t5) {
      return this.savePendingCaption();
    }
  };
  var Xn = class extends q3 {
    constructor(t5, i4) {
      super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t5, this.composition = i4, this.documentView = new Si(this.composition.document, { element: this.element }), b3("focus", { onElement: this.element, withCallback: this.didFocus }), b3("blur", { onElement: this.element, withCallback: this.didBlur }), b3("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), b3("mousedown", { onElement: this.element, matchingSelector: e3, withCallback: this.didClickAttachment }), b3("click", { onElement: this.element, matchingSelector: "a".concat(e3), preventDefault: true });
    }
    didFocus(t5) {
      var e4;
      const i4 = () => {
        var t6, e5;
        if (!this.focused) return this.focused = true, null === (t6 = this.delegate) || void 0 === t6 || null === (e5 = t6.compositionControllerDidFocus) || void 0 === e5 ? void 0 : e5.call(t6);
      };
      return (null === (e4 = this.blurPromise) || void 0 === e4 ? void 0 : e4.then(i4)) || i4();
    }
    didBlur(t5) {
      this.blurPromise = new Promise((t6) => Rt(() => {
        var e4, i4;
        x3(this.element) || (this.focused = null, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidBlur) || void 0 === i4 || i4.call(e4));
        return this.blurPromise = null, t6();
      }));
    }
    didClickAttachment(t5, e4) {
      var i4, n4;
      const r4 = this.findAttachmentForElement(e4), o4 = !!y3(t5.target, { matchingSelector: "figcaption" });
      return null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.compositionControllerDidSelectAttachment) || void 0 === n4 ? void 0 : n4.call(i4, r4, { editCaption: o4 });
    }
    getSerializableElement() {
      return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
    }
    render() {
      var t5, e4, i4, n4, r4, o4;
      (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && (null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.compositionControllerWillSyncDocumentView) || void 0 === n4 || n4.call(i4), this.documentView.sync(), null === (r4 = this.delegate) || void 0 === r4 || null === (o4 = r4.compositionControllerDidSyncDocumentView) || void 0 === o4 || o4.call(r4));
      return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionControllerDidRender) || void 0 === e4 ? void 0 : e4.call(t5);
    }
    rerenderViewForObject(t5) {
      return this.invalidateViewForObject(t5), this.render();
    }
    invalidateViewForObject(t5) {
      return this.documentView.invalidateViewForObject(t5);
    }
    isViewCachingEnabled() {
      return this.documentView.isViewCachingEnabled();
    }
    enableViewCaching() {
      return this.documentView.enableViewCaching();
    }
    disableViewCaching() {
      return this.documentView.disableViewCaching();
    }
    refreshViewCache() {
      return this.documentView.garbageCollectCachedViews();
    }
    isEditingAttachment() {
      return !!this.attachmentEditor;
    }
    installAttachmentEditorForAttachment(t5, e4) {
      var i4;
      if ((null === (i4 = this.attachmentEditor) || void 0 === i4 ? void 0 : i4.attachment) === t5) return;
      const n4 = this.documentView.findElementForObject(t5);
      if (!n4) return;
      this.uninstallAttachmentEditor();
      const r4 = this.composition.document.getAttachmentPieceForAttachment(t5);
      this.attachmentEditor = new Yn(r4, n4, this.element, e4), this.attachmentEditor.delegate = this;
    }
    uninstallAttachmentEditor() {
      var t5;
      return null === (t5 = this.attachmentEditor) || void 0 === t5 ? void 0 : t5.uninstall();
    }
    didUninstallAttachmentEditor() {
      return this.attachmentEditor = null, this.render();
    }
    attachmentEditorDidRequestUpdatingAttributesForAttachment(t5, e4) {
      var i4, n4;
      return null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.compositionControllerWillUpdateAttachment) || void 0 === n4 || n4.call(i4, e4), this.composition.updateAttributesForAttachment(t5, e4);
    }
    attachmentEditorDidRequestRemovingAttributeForAttachment(t5, e4) {
      var i4, n4;
      return null === (i4 = this.delegate) || void 0 === i4 || null === (n4 = i4.compositionControllerWillUpdateAttachment) || void 0 === n4 || n4.call(i4, e4), this.composition.removeAttributeForAttachment(t5, e4);
    }
    attachmentEditorDidRequestRemovalOfAttachment(t5) {
      var e4, i4;
      return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidRequestRemovalOfAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    attachmentEditorDidRequestDeselectingAttachment(t5) {
      var e4, i4;
      return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidRequestDeselectingAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
    }
    canSyncDocumentView() {
      return !this.isEditingAttachment();
    }
    findAttachmentForElement(t5) {
      return this.composition.document.getAttachmentById(parseInt(t5.dataset.trixId, 10));
    }
  };
  var $n = class extends q3 {
  };
  var Zn = "data-trix-mutable";
  var Qn = "[".concat(Zn, "]");
  var tr = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };
  var er = class extends q3 {
    constructor(t5) {
      super(t5), this.didMutate = this.didMutate.bind(this), this.element = t5, this.observer = new window.MutationObserver(this.didMutate), this.start();
    }
    start() {
      return this.reset(), this.observer.observe(this.element, tr);
    }
    stop() {
      return this.observer.disconnect();
    }
    didMutate(t5) {
      var e4, i4;
      if (this.mutations.push(...Array.from(this.findSignificantMutations(t5) || [])), this.mutations.length) return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.elementDidMutate) || void 0 === i4 || i4.call(e4, this.getMutationSummary()), this.reset();
    }
    reset() {
      this.mutations = [];
    }
    findSignificantMutations(t5) {
      return t5.filter((t6) => this.mutationIsSignificant(t6));
    }
    mutationIsSignificant(t5) {
      if (this.nodeIsMutable(t5.target)) return false;
      for (const e4 of Array.from(this.nodesModifiedByMutation(t5))) if (this.nodeIsSignificant(e4)) return true;
      return false;
    }
    nodeIsSignificant(t5) {
      return t5 !== this.element && !this.nodeIsMutable(t5) && !M3(t5);
    }
    nodeIsMutable(t5) {
      return y3(t5, { matchingSelector: Qn });
    }
    nodesModifiedByMutation(t5) {
      const e4 = [];
      switch (t5.type) {
        case "attributes":
          t5.attributeName !== Zn && e4.push(t5.target);
          break;
        case "characterData":
          e4.push(t5.target.parentNode), e4.push(t5.target);
          break;
        case "childList":
          e4.push(...Array.from(t5.addedNodes || [])), e4.push(...Array.from(t5.removedNodes || []));
      }
      return e4;
    }
    getMutationSummary() {
      return this.getTextMutationSummary();
    }
    getTextMutationSummary() {
      const { additions: t5, deletions: e4 } = this.getTextChangesFromCharacterData(), i4 = this.getTextChangesFromChildList();
      Array.from(i4.additions).forEach((e5) => {
        Array.from(t5).includes(e5) || t5.push(e5);
      }), e4.push(...Array.from(i4.deletions || []));
      const n4 = {}, r4 = t5.join("");
      r4 && (n4.textAdded = r4);
      const o4 = e4.join("");
      return o4 && (n4.textDeleted = o4), n4;
    }
    getMutationsByType(t5) {
      return Array.from(this.mutations).filter((e4) => e4.type === t5);
    }
    getTextChangesFromChildList() {
      let t5, e4;
      const i4 = [], n4 = [];
      Array.from(this.getMutationsByType("childList")).forEach((t6) => {
        i4.push(...Array.from(t6.addedNodes || [])), n4.push(...Array.from(t6.removedNodes || []));
      });
      0 === i4.length && 1 === n4.length && I3(n4[0]) ? (t5 = [], e4 = ["\n"]) : (t5 = ir(i4), e4 = ir(n4));
      const r4 = t5.filter((t6, i5) => t6 !== e4[i5]).map(Wt), o4 = e4.filter((e5, i5) => e5 !== t5[i5]).map(Wt);
      return { additions: r4, deletions: o4 };
    }
    getTextChangesFromCharacterData() {
      let t5, e4;
      const i4 = this.getMutationsByType("characterData");
      if (i4.length) {
        const n4 = i4[0], r4 = i4[i4.length - 1], o4 = function(t6, e5) {
          let i5, n5;
          return t6 = $4.box(t6), (e5 = $4.box(e5)).length < t6.length ? [n5, i5] = zt(t6, e5) : [i5, n5] = zt(e5, t6), { added: i5, removed: n5 };
        }(Wt(n4.oldValue), Wt(r4.target.data));
        t5 = o4.added, e4 = o4.removed;
      }
      return { additions: t5 ? [t5] : [], deletions: e4 ? [e4] : [] };
    }
  };
  var ir = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const e4 = [];
    for (const i4 of Array.from(t5)) switch (i4.nodeType) {
      case Node.TEXT_NODE:
        e4.push(i4.data);
        break;
      case Node.ELEMENT_NODE:
        "br" === k3(i4) ? e4.push("\n") : e4.push(...Array.from(ir(i4.childNodes) || []));
    }
    return e4;
  };
  var nr = class extends ee4 {
    constructor(t5) {
      super(...arguments), this.file = t5;
    }
    perform(t5) {
      const e4 = new FileReader();
      return e4.onerror = () => t5(false), e4.onload = () => {
        e4.onerror = null;
        try {
          e4.abort();
        } catch (t6) {
        }
        return t5(true, this.file);
      }, e4.readAsArrayBuffer(this.file);
    }
  };
  var rr = class {
    constructor(t5) {
      this.element = t5;
    }
    shouldIgnore(t5) {
      return !!a3.samsungAndroid && (this.previousEvent = this.event, this.event = t5, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
    }
    checkSamsungKeyboardBuggyModeStart() {
      this.insertingLongTextAfterUnidentifiedChar() && or(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
    }
    checkSamsungKeyboardBuggyModeEnd() {
      this.buggyMode && "insertText" !== this.event.inputType && (this.buggyMode = false);
    }
    insertingLongTextAfterUnidentifiedChar() {
      var t5;
      return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && (null === (t5 = this.event.data) || void 0 === t5 ? void 0 : t5.length) > 50;
    }
    isBeforeInputInsertText() {
      return "beforeinput" === this.event.type && "insertText" === this.event.inputType;
    }
    previousEventWasUnidentifiedKeydown() {
      var t5, e4;
      return "keydown" === (null === (t5 = this.previousEvent) || void 0 === t5 ? void 0 : t5.type) && "Unidentified" === (null === (e4 = this.previousEvent) || void 0 === e4 ? void 0 : e4.key);
    }
  };
  var or = (t5, e4) => ar(t5) === ar(e4);
  var sr = new RegExp("(".concat("\uFFFC", "|").concat(d3, "|").concat(g3, "|\\s)+"), "g");
  var ar = (t5) => t5.replace(sr, " ").trim();
  var lr = class extends q3 {
    constructor(t5) {
      super(...arguments), this.element = t5, this.mutationObserver = new er(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new rr(this.element);
      for (const t6 in this.constructor.events) b3(t6, { onElement: this.element, withCallback: this.handlerFor(t6) });
    }
    elementDidMutate(t5) {
    }
    editorWillSyncDocumentView() {
      return this.mutationObserver.stop();
    }
    editorDidSyncDocumentView() {
      return this.mutationObserver.start();
    }
    requestRender() {
      var t5, e4;
      return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidRequestRender) || void 0 === e4 ? void 0 : e4.call(t5);
    }
    requestReparse() {
      var t5, e4;
      return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidRequestReparse) || void 0 === e4 || e4.call(t5), this.requestRender();
    }
    attachFiles(t5) {
      const e4 = Array.from(t5).map((t6) => new nr(t6));
      return Promise.all(e4).then((t6) => {
        this.handleInput(function() {
          var e5, i4;
          return null === (e5 = this.delegate) || void 0 === e5 || e5.inputControllerWillAttachFiles(), null === (i4 = this.responder) || void 0 === i4 || i4.insertFiles(t6), this.requestRender();
        });
      });
    }
    handlerFor(t5) {
      return (e4) => {
        e4.defaultPrevented || this.handleInput(() => {
          if (!x3(this.element)) {
            if (this.flakyKeyboardDetector.shouldIgnore(e4)) return;
            this.eventName = t5, this.constructor.events[t5].call(this, e4);
          }
        });
      };
    }
    handleInput(t5) {
      try {
        var e4;
        null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillHandleInput(), t5.call(this);
      } finally {
        var i4;
        null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerDidHandleInput();
      }
    }
    createLinkHTML(t5, e4) {
      const i4 = document.createElement("a");
      return i4.href = t5, i4.textContent = e4 || t5, i4.outerHTML;
    }
  };
  var cr;
  Di(lr, "events", {});
  var { browser: ur, keyNames: hr } = z3;
  var dr = 0;
  var gr = class extends lr {
    constructor() {
      super(...arguments), this.resetInputSummary();
    }
    setInputSummary() {
      let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.inputSummary.eventName = this.eventName;
      for (const e4 in t5) {
        const i4 = t5[e4];
        this.inputSummary[e4] = i4;
      }
      return this.inputSummary;
    }
    resetInputSummary() {
      this.inputSummary = {};
    }
    reset() {
      return this.resetInputSummary(), Ft.reset();
    }
    elementDidMutate(t5) {
      var e4, i4;
      return this.isComposing() ? null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidAllowUnhandledInput) || void 0 === i4 ? void 0 : i4.call(e4) : this.handleInput(function() {
        return this.mutationIsSignificant(t5) && (this.mutationIsExpected(t5) ? this.requestRender() : this.requestReparse()), this.reset();
      });
    }
    mutationIsExpected(t5) {
      let { textAdded: e4, textDeleted: i4 } = t5;
      if (this.inputSummary.preferDocument) return true;
      const n4 = null != e4 ? e4 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r4 = null != i4 ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o4 = ["\n", " \n"].includes(e4) && !n4, s4 = "\n" === i4 && !r4;
      if (o4 && !s4 || s4 && !o4) {
        const t6 = this.getSelectedRange();
        if (t6) {
          var a4;
          const i5 = o4 ? e4.replace(/\n$/, "").length || -1 : (null == e4 ? void 0 : e4.length) || 1;
          if (null !== (a4 = this.responder) && void 0 !== a4 && a4.positionIsBlockBreak(t6[1] + i5)) return true;
        }
      }
      return n4 && r4;
    }
    mutationIsSignificant(t5) {
      var e4;
      const i4 = Object.keys(t5).length > 0, n4 = "" === (null === (e4 = this.compositionInput) || void 0 === e4 ? void 0 : e4.getEndData());
      return i4 || !n4;
    }
    getCompositionInput() {
      if (this.isComposing()) return this.compositionInput;
      this.compositionInput = new vr(this);
    }
    isComposing() {
      return this.compositionInput && !this.compositionInput.isEnded();
    }
    deleteInDirection(t5, e4) {
      var i4;
      return false !== (null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.deleteInDirection(t5)) ? this.setInputSummary({ didDelete: true }) : e4 ? (e4.preventDefault(), this.requestRender()) : void 0;
    }
    serializeSelectionToDataTransfer(t5) {
      var e4;
      if (!function(t6) {
        if (null == t6 || !t6.setData) return false;
        for (const e5 in Ct) {
          const i5 = Ct[e5];
          try {
            if (t6.setData(e5, i5), !t6.getData(e5) === i5) return false;
          } catch (t7) {
            return false;
          }
        }
        return true;
      }(t5)) return;
      const i4 = null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.getSelectedDocument().toSerializableDocument();
      return t5.setData("application/x-trix-document", JSON.stringify(i4)), t5.setData("text/html", Si.render(i4).innerHTML), t5.setData("text/plain", i4.toString().replace(/\n$/, "")), true;
    }
    canAcceptDataTransfer(t5) {
      const e4 = {};
      return Array.from((null == t5 ? void 0 : t5.types) || []).forEach((t6) => {
        e4[t6] = true;
      }), e4.Files || e4["application/x-trix-document"] || e4["text/html"] || e4["text/plain"];
    }
    getPastedHTMLUsingHiddenElement(t5) {
      const e4 = this.getSelectedRange(), i4 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n4 = T3({ style: i4, tagName: "div", editable: true });
      return document.body.appendChild(n4), n4.focus(), requestAnimationFrame(() => {
        const i5 = n4.innerHTML;
        return S3(n4), this.setSelectedRange(e4), t5(i5);
      });
    }
  };
  Di(gr, "events", { keydown(t5) {
    this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
    const e4 = hr[t5.keyCode];
    if (e4) {
      var i4;
      let n5 = this.keys;
      ["ctrl", "alt", "shift", "meta"].forEach((e5) => {
        var i5;
        t5["".concat(e5, "Key")] && ("ctrl" === e5 && (e5 = "control"), n5 = null === (i5 = n5) || void 0 === i5 ? void 0 : i5[e5]);
      }), null != (null === (i4 = n5) || void 0 === i4 ? void 0 : i4[e4]) && (this.setInputSummary({ keyName: e4 }), Ft.reset(), n5[e4].call(this, t5));
    }
    if (St(t5)) {
      const e5 = String.fromCharCode(t5.keyCode).toLowerCase();
      if (e5) {
        var n4;
        const i5 = ["alt", "shift"].map((e6) => {
          if (t5["".concat(e6, "Key")]) return e6;
        }).filter((t6) => t6);
        i5.push(e5), null !== (n4 = this.delegate) && void 0 !== n4 && n4.inputControllerDidReceiveKeyboardCommand(i5) && t5.preventDefault();
      }
    }
  }, keypress(t5) {
    if (null != this.inputSummary.eventName) return;
    if (t5.metaKey) return;
    if (t5.ctrlKey && !t5.altKey) return;
    const e4 = fr(t5);
    var i4, n4;
    return e4 ? (null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformTyping(), null === (n4 = this.responder) || void 0 === n4 || n4.insertString(e4), this.setInputSummary({ textAdded: e4, didDelete: this.selectionIsExpanded() })) : void 0;
  }, textInput(t5) {
    const { data: e4 } = t5, { textAdded: i4 } = this.inputSummary;
    if (i4 && i4 !== e4 && i4.toUpperCase() === e4) {
      var n4;
      const t6 = this.getSelectedRange();
      return this.setSelectedRange([t6[0], t6[1] + i4.length]), null === (n4 = this.responder) || void 0 === n4 || n4.insertString(e4), this.setInputSummary({ textAdded: e4 }), this.setSelectedRange(t6);
    }
  }, dragenter(t5) {
    t5.preventDefault();
  }, dragstart(t5) {
    var e4, i4;
    return this.serializeSelectionToDataTransfer(t5.dataTransfer), this.draggedRange = this.getSelectedRange(), null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidStartDrag) || void 0 === i4 ? void 0 : i4.call(e4);
  }, dragover(t5) {
    if (this.draggedRange || this.canAcceptDataTransfer(t5.dataTransfer)) {
      t5.preventDefault();
      const n4 = { x: t5.clientX, y: t5.clientY };
      var e4, i4;
      if (!Tt(n4, this.draggingPoint)) return this.draggingPoint = n4, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidReceiveDragOverPoint) || void 0 === i4 ? void 0 : i4.call(e4, this.draggingPoint);
    }
  }, dragend(t5) {
    var e4, i4;
    null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidCancelDrag) || void 0 === i4 || i4.call(e4), this.draggedRange = null, this.draggingPoint = null;
  }, drop(t5) {
    var e4, i4;
    t5.preventDefault();
    const n4 = null === (e4 = t5.dataTransfer) || void 0 === e4 ? void 0 : e4.files, r4 = t5.dataTransfer.getData("application/x-trix-document"), o4 = { x: t5.clientX, y: t5.clientY };
    if (null === (i4 = this.responder) || void 0 === i4 || i4.setLocationRangeFromPointRange(o4), null != n4 && n4.length) this.attachFiles(n4);
    else if (this.draggedRange) {
      var s4, a4;
      null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillMoveText(), null === (a4 = this.responder) || void 0 === a4 || a4.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
    } else if (r4) {
      var l4;
      const t6 = an.fromJSONString(r4);
      null === (l4 = this.responder) || void 0 === l4 || l4.insertDocument(t6), this.requestRender();
    }
    this.draggedRange = null, this.draggingPoint = null;
  }, cut(t5) {
    var e4, i4;
    if (null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault(), null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillCutText(), this.deleteInDirection("backward"), t5.defaultPrevented)) return this.requestRender();
  }, copy(t5) {
    var e4;
    null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault();
  }, paste(t5) {
    const e4 = t5.clipboardData || t5.testClipboardData, i4 = { clipboard: e4 };
    if (!e4 || br(t5)) return void this.getPastedHTMLUsingHiddenElement((t6) => {
      var e5, n5, r5;
      return i4.type = "text/html", i4.html = t6, null === (e5 = this.delegate) || void 0 === e5 || e5.inputControllerWillPaste(i4), null === (n5 = this.responder) || void 0 === n5 || n5.insertHTML(i4.html), this.requestRender(), null === (r5 = this.delegate) || void 0 === r5 ? void 0 : r5.inputControllerDidPaste(i4);
    });
    const n4 = e4.getData("URL"), r4 = e4.getData("text/html"), o4 = e4.getData("public.url-name");
    if (n4) {
      var s4, a4, l4;
      let t6;
      i4.type = "text/html", t6 = o4 ? Vt(o4).trim() : n4, i4.html = this.createLinkHTML(n4, t6), null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: t6, didDelete: this.selectionIsExpanded() }), null === (a4 = this.responder) || void 0 === a4 || a4.insertHTML(i4.html), this.requestRender(), null === (l4 = this.delegate) || void 0 === l4 || l4.inputControllerDidPaste(i4);
    } else if (Et(e4)) {
      var c4, u4, h4;
      i4.type = "text/plain", i4.string = e4.getData("text/plain"), null === (c4 = this.delegate) || void 0 === c4 || c4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: i4.string, didDelete: this.selectionIsExpanded() }), null === (u4 = this.responder) || void 0 === u4 || u4.insertString(i4.string), this.requestRender(), null === (h4 = this.delegate) || void 0 === h4 || h4.inputControllerDidPaste(i4);
    } else if (r4) {
      var d4, g4, m4;
      i4.type = "text/html", i4.html = r4, null === (d4 = this.delegate) || void 0 === d4 || d4.inputControllerWillPaste(i4), null === (g4 = this.responder) || void 0 === g4 || g4.insertHTML(i4.html), this.requestRender(), null === (m4 = this.delegate) || void 0 === m4 || m4.inputControllerDidPaste(i4);
    } else if (Array.from(e4.types).includes("Files")) {
      var p4, f4;
      const t6 = null === (p4 = e4.items) || void 0 === p4 || null === (p4 = p4[0]) || void 0 === p4 || null === (f4 = p4.getAsFile) || void 0 === f4 ? void 0 : f4.call(p4);
      if (t6) {
        var b4, v4, A4;
        const e5 = mr(t6);
        !t6.name && e5 && (t6.name = "pasted-file-".concat(++dr, ".").concat(e5)), i4.type = "File", i4.file = t6, null === (b4 = this.delegate) || void 0 === b4 || b4.inputControllerWillAttachFiles(), null === (v4 = this.responder) || void 0 === v4 || v4.insertFile(i4.file), this.requestRender(), null === (A4 = this.delegate) || void 0 === A4 || A4.inputControllerDidPaste(i4);
      }
    }
    t5.preventDefault();
  }, compositionstart(t5) {
    return this.getCompositionInput().start(t5.data);
  }, compositionupdate(t5) {
    return this.getCompositionInput().update(t5.data);
  }, compositionend(t5) {
    return this.getCompositionInput().end(t5.data);
  }, beforeinput(t5) {
    this.inputSummary.didInput = true;
  }, input(t5) {
    return this.inputSummary.didInput = true, t5.stopPropagation();
  } }), Di(gr, "keys", { backspace(t5) {
    var e4;
    return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
  }, delete(t5) {
    var e4;
    return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
  }, return(t5) {
    var e4, i4;
    return this.setInputSummary({ preferDocument: true }), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.insertLineBreak();
  }, tab(t5) {
    var e4, i4;
    null !== (e4 = this.responder) && void 0 !== e4 && e4.canIncreaseNestingLevel() && (null === (i4 = this.responder) || void 0 === i4 || i4.increaseNestingLevel(), this.requestRender(), t5.preventDefault());
  }, left(t5) {
    var e4;
    if (this.selectionIsInCursorTarget()) return t5.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("backward");
  }, right(t5) {
    var e4;
    if (this.selectionIsInCursorTarget()) return t5.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("forward");
  }, control: { d(t5) {
    var e4;
    return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
  }, h(t5) {
    var e4;
    return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
  }, o(t5) {
    var e4, i4;
    return t5.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.insertString("\n", { updatePosition: false }), this.requestRender();
  } }, shift: { return(t5) {
    var e4, i4;
    null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.insertString("\n"), this.requestRender(), t5.preventDefault();
  }, tab(t5) {
    var e4, i4;
    null !== (e4 = this.responder) && void 0 !== e4 && e4.canDecreaseNestingLevel() && (null === (i4 = this.responder) || void 0 === i4 || i4.decreaseNestingLevel(), this.requestRender(), t5.preventDefault());
  }, left(t5) {
    if (this.selectionIsInCursorTarget()) return t5.preventDefault(), this.expandSelectionInDirection("backward");
  }, right(t5) {
    if (this.selectionIsInCursorTarget()) return t5.preventDefault(), this.expandSelectionInDirection("forward");
  } }, alt: { backspace(t5) {
    var e4;
    return this.setInputSummary({ preferDocument: false }), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.inputControllerWillPerformTyping();
  } }, meta: { backspace(t5) {
    var e4;
    return this.setInputSummary({ preferDocument: false }), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.inputControllerWillPerformTyping();
  } } }), gr.proxyMethod("responder?.getSelectedRange"), gr.proxyMethod("responder?.setSelectedRange"), gr.proxyMethod("responder?.expandSelectionInDirection"), gr.proxyMethod("responder?.selectionIsInCursorTarget"), gr.proxyMethod("responder?.selectionIsExpanded");
  var mr = (t5) => {
    var e4;
    return null === (e4 = t5.type) || void 0 === e4 || null === (e4 = e4.match(/\/(\w+)$/)) || void 0 === e4 ? void 0 : e4[1];
  };
  var pr = !(null === (cr = " ".codePointAt) || void 0 === cr || !cr.call(" ", 0));
  var fr = function(t5) {
    if (t5.key && pr && t5.key.codePointAt(0) === t5.keyCode) return t5.key;
    {
      let e4;
      if (null === t5.which ? e4 = t5.keyCode : 0 !== t5.which && 0 !== t5.charCode && (e4 = t5.charCode), null != e4 && "escape" !== hr[e4]) return $4.fromCodepoints([e4]).toString();
    }
  };
  var br = function(t5) {
    const e4 = t5.clipboardData;
    if (e4) {
      if (e4.types.includes("text/html")) {
        for (const t6 of e4.types) {
          const i4 = /^CorePasteboardFlavorType/.test(t6), n4 = /^dyn\./.test(t6) && e4.getData(t6);
          if (i4 || n4) return true;
        }
        return false;
      }
      {
        const t6 = e4.types.includes("com.apple.webarchive"), i4 = e4.types.includes("com.apple.flat-rtfd");
        return t6 || i4;
      }
    }
  };
  var vr = class extends q3 {
    constructor(t5) {
      super(...arguments), this.inputController = t5, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
    }
    start(t5) {
      if (this.data.start = t5, this.isSignificant()) {
        var e4, i4;
        if ("keypress" === this.inputSummary.eventName && this.inputSummary.textAdded) null === (i4 = this.responder) || void 0 === i4 || i4.deleteInDirection("left");
        this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.getSelectedRange();
      }
    }
    update(t5) {
      if (this.data.update = t5, this.isSignificant()) {
        const t6 = this.selectPlaceholder();
        t6 && (this.forgetPlaceholder(), this.range = t6);
      }
    }
    end(t5) {
      return this.data.end = t5, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.setSelectedRange(this.range), null === (n4 = this.responder) || void 0 === n4 || n4.insertString(this.data.end), null === (r4 = this.responder) || void 0 === r4 ? void 0 : r4.setSelectedRange(this.range[0] + this.data.end.length)) : null != this.data.start || null != this.data.update ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
      var e4, i4, n4, r4;
    }
    getEndData() {
      return this.data.end;
    }
    isEnded() {
      return null != this.getEndData();
    }
    isSignificant() {
      return !ur.composesExistingText || this.inputSummary.didInput;
    }
    canApplyToDocument() {
      var t5, e4;
      return 0 === (null === (t5 = this.data.start) || void 0 === t5 ? void 0 : t5.length) && (null === (e4 = this.data.end) || void 0 === e4 ? void 0 : e4.length) > 0 && this.range;
    }
  };
  vr.proxyMethod("inputController.setInputSummary"), vr.proxyMethod("inputController.requestRender"), vr.proxyMethod("inputController.requestReparse"), vr.proxyMethod("responder?.selectionIsExpanded"), vr.proxyMethod("responder?.insertPlaceholder"), vr.proxyMethod("responder?.selectPlaceholder"), vr.proxyMethod("responder?.forgetPlaceholder");
  var Ar = class extends lr {
    constructor() {
      super(...arguments), this.render = this.render.bind(this);
    }
    elementDidMutate() {
      return this.scheduledRender ? this.composing ? null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidAllowUnhandledInput) || void 0 === e4 ? void 0 : e4.call(t5) : void 0 : this.reparse();
      var t5, e4;
    }
    scheduleRender() {
      return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
    }
    render() {
      var t5, e4;
      (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || (null === (e4 = this.delegate) || void 0 === e4 || e4.render());
      null === (t5 = this.afterRender) || void 0 === t5 || t5.call(this), this.afterRender = null;
    }
    reparse() {
      var t5;
      return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.reparse();
    }
    insertString() {
      var t5;
      let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i4 = arguments.length > 1 ? arguments[1] : void 0;
      return null === (t5 = this.delegate) || void 0 === t5 || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
        var t6;
        return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertString(e4, i4);
      });
    }
    toggleAttributeIfSupported(t5) {
      var e4;
      if (gt().includes(t5)) return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
        var e5;
        return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.toggleCurrentAttribute(t5);
      });
    }
    activateAttributeIfSupported(t5, e4) {
      var i4;
      if (gt().includes(t5)) return null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
        var i5;
        return null === (i5 = this.responder) || void 0 === i5 ? void 0 : i5.setCurrentAttribute(t5, e4);
      });
    }
    deleteInDirection(t5) {
      let { recordUndoEntry: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { recordUndoEntry: true };
      var i4;
      e4 && (null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformTyping());
      const n4 = () => {
        var e5;
        return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.deleteInDirection(t5);
      }, r4 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
      return r4 ? this.withTargetDOMRange(r4, n4) : n4();
    }
    withTargetDOMRange(t5, e4) {
      var i4;
      return "function" == typeof t5 && (e4 = t5, t5 = this.getTargetDOMRange()), t5 ? null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.withTargetDOMRange(t5, e4.bind(this)) : (Ft.reset(), e4.call(this));
    }
    getTargetDOMRange() {
      var t5, e4;
      let { minLength: i4 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { minLength: 0 };
      const n4 = null === (t5 = (e4 = this.event).getTargetRanges) || void 0 === t5 ? void 0 : t5.call(e4);
      if (n4 && n4.length) {
        const t6 = yr(n4[0]);
        if (0 === i4 || t6.toString().length >= i4) return t6;
      }
    }
    withEvent(t5, e4) {
      let i4;
      this.event = t5;
      try {
        i4 = e4.call(this);
      } finally {
        this.event = null;
      }
      return i4;
    }
  };
  Di(Ar, "events", { keydown(t5) {
    if (St(t5)) {
      var e4;
      const i4 = Rr(t5);
      null !== (e4 = this.delegate) && void 0 !== e4 && e4.inputControllerDidReceiveKeyboardCommand(i4) && t5.preventDefault();
    } else {
      let e5 = t5.key;
      t5.altKey && (e5 += "+Alt"), t5.shiftKey && (e5 += "+Shift");
      const i4 = this.constructor.keys[e5];
      if (i4) return this.withEvent(t5, i4);
    }
  }, paste(t5) {
    var e4;
    let i4;
    const n4 = null === (e4 = t5.clipboardData) || void 0 === e4 ? void 0 : e4.getData("URL");
    return Er(t5) ? (t5.preventDefault(), this.attachFiles(t5.clipboardData.files)) : Sr(t5) ? (t5.preventDefault(), i4 = { type: "text/plain", string: t5.clipboardData.getData("text/plain") }, null === (r4 = this.delegate) || void 0 === r4 || r4.inputControllerWillPaste(i4), null === (o4 = this.responder) || void 0 === o4 || o4.insertString(i4.string), this.render(), null === (s4 = this.delegate) || void 0 === s4 ? void 0 : s4.inputControllerDidPaste(i4)) : n4 ? (t5.preventDefault(), i4 = { type: "text/html", html: this.createLinkHTML(n4) }, null === (a4 = this.delegate) || void 0 === a4 || a4.inputControllerWillPaste(i4), null === (l4 = this.responder) || void 0 === l4 || l4.insertHTML(i4.html), this.render(), null === (c4 = this.delegate) || void 0 === c4 ? void 0 : c4.inputControllerDidPaste(i4)) : void 0;
    var r4, o4, s4, a4, l4, c4;
  }, beforeinput(t5) {
    const e4 = this.constructor.inputTypes[t5.inputType], i4 = (n4 = t5, !(!/iPhone|iPad/.test(navigator.userAgent) || n4.inputType && "insertParagraph" !== n4.inputType));
    var n4;
    e4 && (this.withEvent(t5, e4), i4 || this.scheduleRender()), i4 && this.render();
  }, input(t5) {
    Ft.reset();
  }, dragstart(t5) {
    var e4, i4;
    null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionContainsAttachments() && (t5.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.getSelectedRange(), point: kr(t5) });
  }, dragenter(t5) {
    xr(t5) && t5.preventDefault();
  }, dragover(t5) {
    if (this.dragging) {
      t5.preventDefault();
      const i4 = kr(t5);
      var e4;
      if (!Tt(i4, this.dragging.point)) return this.dragging.point = i4, null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.setLocationRangeFromPointRange(i4);
    } else xr(t5) && t5.preventDefault();
  }, drop(t5) {
    var e4, i4;
    if (this.dragging) return t5.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillMoveText(), null === (i4 = this.responder) || void 0 === i4 || i4.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
    if (xr(t5)) {
      var n4;
      t5.preventDefault();
      const e5 = kr(t5);
      return null === (n4 = this.responder) || void 0 === n4 || n4.setLocationRangeFromPointRange(e5), this.attachFiles(t5.dataTransfer.files);
    }
  }, dragend() {
    var t5;
    this.dragging && (null === (t5 = this.responder) || void 0 === t5 || t5.setSelectedRange(this.dragging.range), this.dragging = null);
  }, compositionend(t5) {
    this.composing && (this.composing = false, a3.recentAndroid || this.scheduleRender());
  } }), Di(Ar, "keys", { ArrowLeft() {
    var t5, e4;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageMovingCursorInDirection("backward")) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("backward");
  }, ArrowRight() {
    var t5, e4;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageMovingCursorInDirection("forward")) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("forward");
  }, Backspace() {
    var t5, e4, i4;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageDeletingInDirection("backward")) return this.event.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.deleteInDirection("backward"), this.render();
  }, Tab() {
    var t5, e4;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canIncreaseNestingLevel()) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 || e4.increaseNestingLevel(), this.render();
  }, "Tab+Shift"() {
    var t5, e4;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canDecreaseNestingLevel()) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 || e4.decreaseNestingLevel(), this.render();
  } }), Di(Ar, "inputTypes", { deleteByComposition() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteByCut() {
    return this.deleteInDirection("backward");
  }, deleteByDrag() {
    return this.event.preventDefault(), this.withTargetDOMRange(function() {
      var t5;
      this.deleteByDragRange = null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.getSelectedRange();
    });
  }, deleteCompositionText() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteContent() {
    return this.deleteInDirection("backward");
  }, deleteContentBackward() {
    return this.deleteInDirection("backward");
  }, deleteContentForward() {
    return this.deleteInDirection("forward");
  }, deleteEntireSoftLine() {
    return this.deleteInDirection("forward");
  }, deleteHardLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteHardLineForward() {
    return this.deleteInDirection("forward");
  }, deleteSoftLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteSoftLineForward() {
    return this.deleteInDirection("forward");
  }, deleteWordBackward() {
    return this.deleteInDirection("backward");
  }, deleteWordForward() {
    return this.deleteInDirection("forward");
  }, formatBackColor() {
    return this.activateAttributeIfSupported("backgroundColor", this.event.data);
  }, formatBold() {
    return this.toggleAttributeIfSupported("bold");
  }, formatFontColor() {
    return this.activateAttributeIfSupported("color", this.event.data);
  }, formatFontName() {
    return this.activateAttributeIfSupported("font", this.event.data);
  }, formatIndent() {
    var t5;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canIncreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.increaseNestingLevel();
    });
  }, formatItalic() {
    return this.toggleAttributeIfSupported("italic");
  }, formatJustifyCenter() {
    return this.toggleAttributeIfSupported("justifyCenter");
  }, formatJustifyFull() {
    return this.toggleAttributeIfSupported("justifyFull");
  }, formatJustifyLeft() {
    return this.toggleAttributeIfSupported("justifyLeft");
  }, formatJustifyRight() {
    return this.toggleAttributeIfSupported("justifyRight");
  }, formatOutdent() {
    var t5;
    if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canDecreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.decreaseNestingLevel();
    });
  }, formatRemove() {
    this.withTargetDOMRange(function() {
      for (const i4 in null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.getCurrentAttributes()) {
        var t5, e4;
        null === (e4 = this.responder) || void 0 === e4 || e4.removeCurrentAttribute(i4);
      }
    });
  }, formatSetBlockTextDirection() {
    return this.activateAttributeIfSupported("blockDir", this.event.data);
  }, formatSetInlineTextDirection() {
    return this.activateAttributeIfSupported("textDir", this.event.data);
  }, formatStrikeThrough() {
    return this.toggleAttributeIfSupported("strike");
  }, formatSubscript() {
    return this.toggleAttributeIfSupported("sub");
  }, formatSuperscript() {
    return this.toggleAttributeIfSupported("sup");
  }, formatUnderline() {
    return this.toggleAttributeIfSupported("underline");
  }, historyRedo() {
    var t5;
    return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerWillPerformRedo();
  }, historyUndo() {
    var t5;
    return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerWillPerformUndo();
  }, insertCompositionText() {
    return this.composing = true, this.insertString(this.event.data);
  }, insertFromComposition() {
    return this.composing = false, this.insertString(this.event.data);
  }, insertFromDrop() {
    const t5 = this.deleteByDragRange;
    var e4;
    if (t5) return this.deleteByDragRange = null, null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
      var e5;
      return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.moveTextFromRange(t5);
    });
  }, insertFromPaste() {
    const { dataTransfer: t5 } = this.event, e4 = { dataTransfer: t5 }, i4 = t5.getData("URL"), n4 = t5.getData("text/html");
    if (i4) {
      var r4;
      let n5;
      this.event.preventDefault(), e4.type = "text/html";
      const o5 = t5.getData("public.url-name");
      n5 = o5 ? Vt(o5).trim() : i4, e4.html = this.createLinkHTML(i4, n5), null === (r4 = this.delegate) || void 0 === r4 || r4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
        var t6;
        return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertHTML(e4.html);
      }), this.afterRender = () => {
        var t6;
        return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
      };
    } else if (Et(t5)) {
      var o4;
      e4.type = "text/plain", e4.string = t5.getData("text/plain"), null === (o4 = this.delegate) || void 0 === o4 || o4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
        var t6;
        return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertString(e4.string);
      }), this.afterRender = () => {
        var t6;
        return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
      };
    } else if (Cr(this.event)) {
      var s4;
      e4.type = "File", e4.file = t5.files[0], null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
        var t6;
        return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertFile(e4.file);
      }), this.afterRender = () => {
        var t6;
        return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
      };
    } else if (n4) {
      var a4;
      this.event.preventDefault(), e4.type = "text/html", e4.html = n4, null === (a4 = this.delegate) || void 0 === a4 || a4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
        var t6;
        return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertHTML(e4.html);
      }), this.afterRender = () => {
        var t6;
        return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
      };
    }
  }, insertFromYank() {
    return this.insertString(this.event.data);
  }, insertLineBreak() {
    return this.insertString("\n");
  }, insertLink() {
    return this.activateAttributeIfSupported("href", this.event.data);
  }, insertOrderedList() {
    return this.toggleAttributeIfSupported("number");
  }, insertParagraph() {
    var t5;
    return null === (t5 = this.delegate) || void 0 === t5 || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertLineBreak();
    });
  }, insertReplacementText() {
    const t5 = this.event.dataTransfer.getData("text/plain"), e4 = this.event.getTargetRanges()[0];
    this.withTargetDOMRange(e4, () => {
      this.insertString(t5, { updatePosition: false });
    });
  }, insertText() {
    var t5;
    return this.insertString(this.event.data || (null === (t5 = this.event.dataTransfer) || void 0 === t5 ? void 0 : t5.getData("text/plain")));
  }, insertTranspose() {
    return this.insertString(this.event.data);
  }, insertUnorderedList() {
    return this.toggleAttributeIfSupported("bullet");
  } });
  var yr = function(t5) {
    const e4 = document.createRange();
    return e4.setStart(t5.startContainer, t5.startOffset), e4.setEnd(t5.endContainer, t5.endOffset), e4;
  };
  var xr = (t5) => {
    var e4;
    return Array.from((null === (e4 = t5.dataTransfer) || void 0 === e4 ? void 0 : e4.types) || []).includes("Files");
  };
  var Cr = (t5) => {
    var e4;
    return (null === (e4 = t5.dataTransfer.files) || void 0 === e4 ? void 0 : e4[0]) && !Er(t5) && !((t6) => {
      let { dataTransfer: e5 } = t6;
      return e5.types.includes("Files") && e5.types.includes("text/html") && e5.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
    })(t5);
  };
  var Er = function(t5) {
    const e4 = t5.clipboardData;
    if (e4) {
      return Array.from(e4.types).filter((t6) => t6.match(/file/i)).length === e4.types.length && e4.files.length >= 1;
    }
  };
  var Sr = function(t5) {
    const e4 = t5.clipboardData;
    if (e4) return e4.types.includes("text/plain") && 1 === e4.types.length;
  };
  var Rr = function(t5) {
    const e4 = [];
    return t5.altKey && e4.push("alt"), t5.shiftKey && e4.push("shift"), e4.push(t5.key), e4;
  };
  var kr = (t5) => ({ x: t5.clientX, y: t5.clientY });
  var Tr = "[data-trix-attribute]";
  var wr = "[data-trix-action]";
  var Lr = "".concat(Tr, ", ").concat(wr);
  var Dr = "[data-trix-dialog]";
  var Nr = "".concat(Dr, "[data-trix-active]");
  var Ir = "".concat(Dr, " [data-trix-method]");
  var Or = "".concat(Dr, " [data-trix-input]");
  var Fr = (t5, e4) => (e4 || (e4 = Mr(t5)), t5.querySelector("[data-trix-input][name='".concat(e4, "']")));
  var Pr = (t5) => t5.getAttribute("data-trix-action");
  var Mr = (t5) => t5.getAttribute("data-trix-attribute") || t5.getAttribute("data-trix-dialog-attribute");
  var Br = class extends q3 {
    constructor(t5) {
      super(t5), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t5, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), b3("mousedown", { onElement: this.element, matchingSelector: wr, withCallback: this.didClickActionButton }), b3("mousedown", { onElement: this.element, matchingSelector: Tr, withCallback: this.didClickAttributeButton }), b3("click", { onElement: this.element, matchingSelector: Lr, preventDefault: true }), b3("click", { onElement: this.element, matchingSelector: Ir, withCallback: this.didClickDialogButton }), b3("keydown", { onElement: this.element, matchingSelector: Or, withCallback: this.didKeyDownDialogInput });
    }
    didClickActionButton(t5, e4) {
      var i4;
      null === (i4 = this.delegate) || void 0 === i4 || i4.toolbarDidClickButton(), t5.preventDefault();
      const n4 = Pr(e4);
      return this.getDialog(n4) ? this.toggleDialog(n4) : null === (r4 = this.delegate) || void 0 === r4 ? void 0 : r4.toolbarDidInvokeAction(n4, e4);
      var r4;
    }
    didClickAttributeButton(t5, e4) {
      var i4;
      null === (i4 = this.delegate) || void 0 === i4 || i4.toolbarDidClickButton(), t5.preventDefault();
      const n4 = Mr(e4);
      var r4;
      this.getDialog(n4) ? this.toggleDialog(n4) : null === (r4 = this.delegate) || void 0 === r4 || r4.toolbarDidToggleAttribute(n4);
      return this.refreshAttributeButtons();
    }
    didClickDialogButton(t5, e4) {
      const i4 = y3(e4, { matchingSelector: Dr });
      return this[e4.getAttribute("data-trix-method")].call(this, i4);
    }
    didKeyDownDialogInput(t5, e4) {
      if (13 === t5.keyCode) {
        t5.preventDefault();
        const i4 = e4.getAttribute("name"), n4 = this.getDialog(i4);
        this.setAttribute(n4);
      }
      if (27 === t5.keyCode) return t5.preventDefault(), this.hideDialog();
    }
    updateActions(t5) {
      return this.actions = t5, this.refreshActionButtons();
    }
    refreshActionButtons() {
      return this.eachActionButton((t5, e4) => {
        t5.disabled = false === this.actions[e4];
      });
    }
    eachActionButton(t5) {
      return Array.from(this.element.querySelectorAll(wr)).map((e4) => t5(e4, Pr(e4)));
    }
    updateAttributes(t5) {
      return this.attributes = t5, this.refreshAttributeButtons();
    }
    refreshAttributeButtons() {
      return this.eachAttributeButton((t5, e4) => (t5.disabled = false === this.attributes[e4], this.attributes[e4] || this.dialogIsVisible(e4) ? (t5.setAttribute("data-trix-active", ""), t5.classList.add("trix-active")) : (t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"))));
    }
    eachAttributeButton(t5) {
      return Array.from(this.element.querySelectorAll(Tr)).map((e4) => t5(e4, Mr(e4)));
    }
    applyKeyboardCommand(t5) {
      const e4 = JSON.stringify(t5.sort());
      for (const t6 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
        const i4 = t6.getAttribute("data-trix-key").split("+");
        if (JSON.stringify(i4.sort()) === e4) return v3("mousedown", { onElement: t6 }), true;
      }
      return false;
    }
    dialogIsVisible(t5) {
      const e4 = this.getDialog(t5);
      if (e4) return e4.hasAttribute("data-trix-active");
    }
    toggleDialog(t5) {
      return this.dialogIsVisible(t5) ? this.hideDialog() : this.showDialog(t5);
    }
    showDialog(t5) {
      var e4, i4;
      this.hideDialog(), null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarWillShowDialog();
      const n4 = this.getDialog(t5);
      n4.setAttribute("data-trix-active", ""), n4.classList.add("trix-active"), Array.from(n4.querySelectorAll("input[disabled]")).forEach((t6) => {
        t6.removeAttribute("disabled");
      });
      const r4 = Mr(n4);
      if (r4) {
        const e5 = Fr(n4, t5);
        e5 && (e5.value = this.attributes[r4] || "", e5.select());
      }
      return null === (i4 = this.delegate) || void 0 === i4 ? void 0 : i4.toolbarDidShowDialog(t5);
    }
    setAttribute(t5) {
      var e4;
      const i4 = Mr(t5), n4 = Fr(t5, i4);
      return !n4.willValidate || (n4.setCustomValidity(""), n4.checkValidity() && this.isSafeAttribute(n4)) ? (null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarDidUpdateAttribute(i4, n4.value), this.hideDialog()) : (n4.setCustomValidity("Invalid value"), n4.setAttribute("data-trix-validate", ""), n4.classList.add("trix-validate"), n4.focus());
    }
    isSafeAttribute(t5) {
      return !t5.hasAttribute("data-trix-validate-href") || li.isValidAttribute("a", "href", t5.value);
    }
    removeAttribute(t5) {
      var e4;
      const i4 = Mr(t5);
      return null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarDidRemoveAttribute(i4), this.hideDialog();
    }
    hideDialog() {
      const t5 = this.element.querySelector(Nr);
      var e4;
      if (t5) return t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"), this.resetDialogInputs(), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.toolbarDidHideDialog(((t6) => t6.getAttribute("data-trix-dialog"))(t5));
    }
    resetDialogInputs() {
      Array.from(this.element.querySelectorAll(Or)).forEach((t5) => {
        t5.setAttribute("disabled", "disabled"), t5.removeAttribute("data-trix-validate"), t5.classList.remove("trix-validate");
      });
    }
    getDialog(t5) {
      return this.element.querySelector("[data-trix-dialog=".concat(t5, "]"));
    }
  };
  var _r = class extends $n {
    constructor(t5) {
      let { editorElement: e4, document: i4, html: n4 } = t5;
      super(...arguments), this.editorElement = e4, this.selectionManager = new Vn(this.editorElement), this.selectionManager.delegate = this, this.composition = new wn(), this.composition.delegate = this, this.attachmentManager = new kn(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = 2 === _3.getLevel() ? new Ar(this.editorElement) : new gr(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Xn(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new Br(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new Pn(this.composition, this.selectionManager, this.editorElement), i4 ? this.editor.loadDocument(i4) : this.editor.loadHTML(n4);
    }
    registerSelectionManager() {
      return Ft.registerSelectionManager(this.selectionManager);
    }
    unregisterSelectionManager() {
      return Ft.unregisterSelectionManager(this.selectionManager);
    }
    render() {
      return this.compositionController.render();
    }
    reparse() {
      return this.composition.replaceHTML(this.editorElement.innerHTML);
    }
    compositionDidChangeDocument(t5) {
      if (this.notifyEditorElement("document-change"), !this.handlingInput) return this.render();
    }
    compositionDidChangeCurrentAttributes(t5) {
      return this.currentAttributes = t5, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
    }
    compositionDidPerformInsertionAtRange(t5) {
      this.pasting && (this.pastedRange = t5);
    }
    compositionShouldAcceptFile(t5) {
      return this.notifyEditorElement("file-accept", { file: t5 });
    }
    compositionDidAddAttachment(t5) {
      const e4 = this.attachmentManager.manageAttachment(t5);
      return this.notifyEditorElement("attachment-add", { attachment: e4 });
    }
    compositionDidEditAttachment(t5) {
      this.compositionController.rerenderViewForObject(t5);
      const e4 = this.attachmentManager.manageAttachment(t5);
      return this.notifyEditorElement("attachment-edit", { attachment: e4 }), this.notifyEditorElement("change");
    }
    compositionDidChangeAttachmentPreviewURL(t5) {
      return this.compositionController.invalidateViewForObject(t5), this.notifyEditorElement("change");
    }
    compositionDidRemoveAttachment(t5) {
      const e4 = this.attachmentManager.unmanageAttachment(t5);
      return this.notifyEditorElement("attachment-remove", { attachment: e4 });
    }
    compositionDidStartEditingAttachment(t5, e4) {
      return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t5), this.compositionController.installAttachmentEditorForAttachment(t5, e4), this.selectionManager.setLocationRange(this.attachmentLocationRange);
    }
    compositionDidStopEditingAttachment(t5) {
      this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
    }
    compositionDidRequestChangingSelectionToLocationRange(t5) {
      if (!this.loadingSnapshot || this.isFocused()) return this.requestedLocationRange = t5, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render();
    }
    compositionWillLoadSnapshot() {
      this.loadingSnapshot = true;
    }
    compositionDidLoadSnapshot() {
      this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
    }
    getSelectionManager() {
      return this.selectionManager;
    }
    attachmentManagerDidRequestRemovalOfAttachment(t5) {
      return this.removeAttachment(t5);
    }
    compositionControllerWillSyncDocumentView() {
      return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
    }
    compositionControllerDidSyncDocumentView() {
      return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
    }
    compositionControllerDidRender() {
      this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
    }
    compositionControllerDidFocus() {
      return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
    }
    compositionControllerDidBlur() {
      return this.notifyEditorElement("blur");
    }
    compositionControllerDidSelectAttachment(t5, e4) {
      return this.toolbarController.hideDialog(), this.composition.editAttachment(t5, e4);
    }
    compositionControllerDidRequestDeselectingAttachment(t5) {
      const e4 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t5);
      return this.selectionManager.setLocationRange(e4[1]);
    }
    compositionControllerWillUpdateAttachment(t5) {
      return this.editor.recordUndoEntry("Edit Attachment", { context: t5.id, consolidatable: true });
    }
    compositionControllerDidRequestRemovalOfAttachment(t5) {
      return this.removeAttachment(t5);
    }
    inputControllerWillHandleInput() {
      this.handlingInput = true, this.requestedRender = false;
    }
    inputControllerDidRequestRender() {
      this.requestedRender = true;
    }
    inputControllerDidHandleInput() {
      if (this.handlingInput = false, this.requestedRender) return this.requestedRender = false, this.render();
    }
    inputControllerDidAllowUnhandledInput() {
      return this.notifyEditorElement("change");
    }
    inputControllerDidRequestReparse() {
      return this.reparse();
    }
    inputControllerWillPerformTyping() {
      return this.recordTypingUndoEntry();
    }
    inputControllerWillPerformFormatting(t5) {
      return this.recordFormattingUndoEntry(t5);
    }
    inputControllerWillCutText() {
      return this.editor.recordUndoEntry("Cut");
    }
    inputControllerWillPaste(t5) {
      return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t5 });
    }
    inputControllerDidPaste(t5) {
      return t5.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t5 });
    }
    inputControllerWillMoveText() {
      return this.editor.recordUndoEntry("Move");
    }
    inputControllerWillAttachFiles() {
      return this.editor.recordUndoEntry("Drop Files");
    }
    inputControllerWillPerformUndo() {
      return this.editor.undo();
    }
    inputControllerWillPerformRedo() {
      return this.editor.redo();
    }
    inputControllerDidReceiveKeyboardCommand(t5) {
      return this.toolbarController.applyKeyboardCommand(t5);
    }
    inputControllerDidStartDrag() {
      this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
    }
    inputControllerDidReceiveDragOverPoint(t5) {
      return this.selectionManager.setLocationRangeFromPointRange(t5);
    }
    inputControllerDidCancelDrag() {
      this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
    }
    locationRangeDidChange(t5) {
      return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !Dt(this.attachmentLocationRange, t5) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
    }
    toolbarDidClickButton() {
      if (!this.getLocationRange()) return this.setLocationRange({ index: 0, offset: 0 });
    }
    toolbarDidInvokeAction(t5, e4) {
      return this.invokeAction(t5, e4);
    }
    toolbarDidToggleAttribute(t5) {
      if (this.recordFormattingUndoEntry(t5), this.composition.toggleCurrentAttribute(t5), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidUpdateAttribute(t5, e4) {
      if (this.recordFormattingUndoEntry(t5), this.composition.setCurrentAttribute(t5, e4), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidRemoveAttribute(t5) {
      if (this.recordFormattingUndoEntry(t5), this.composition.removeCurrentAttribute(t5), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarWillShowDialog(t5) {
      return this.composition.expandSelectionForEditing(), this.freezeSelection();
    }
    toolbarDidShowDialog(t5) {
      return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t5 });
    }
    toolbarDidHideDialog(t5) {
      return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t5 });
    }
    freezeSelection() {
      if (!this.selectionFrozen) return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
    }
    thawSelection() {
      if (this.selectionFrozen) return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
    }
    canInvokeAction(t5) {
      return !!this.actionIsExternal(t5) || !(null === (e4 = this.actions[t5]) || void 0 === e4 || null === (e4 = e4.test) || void 0 === e4 || !e4.call(this));
      var e4;
    }
    invokeAction(t5, e4) {
      return this.actionIsExternal(t5) ? this.notifyEditorElement("action-invoke", { actionName: t5, invokingElement: e4 }) : null === (i4 = this.actions[t5]) || void 0 === i4 || null === (i4 = i4.perform) || void 0 === i4 ? void 0 : i4.call(this);
      var i4;
    }
    actionIsExternal(t5) {
      return /^x-./.test(t5);
    }
    getCurrentActions() {
      const t5 = {};
      for (const e4 in this.actions) t5[e4] = this.canInvokeAction(e4);
      return t5;
    }
    updateCurrentActions() {
      const t5 = this.getCurrentActions();
      if (!Tt(t5, this.currentActions)) return this.currentActions = t5, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
    }
    runEditorFilters() {
      let t5 = this.composition.getSnapshot();
      if (Array.from(this.editor.filters).forEach((e5) => {
        const { document: i5, selectedRange: n4 } = t5;
        t5 = e5.call(this.editor, t5) || {}, t5.document || (t5.document = i5), t5.selectedRange || (t5.selectedRange = n4);
      }), e4 = t5, i4 = this.composition.getSnapshot(), !Dt(e4.selectedRange, i4.selectedRange) || !e4.document.isEqualTo(i4.document)) return this.composition.loadSnapshot(t5);
      var e4, i4;
    }
    updateInputElement() {
      const t5 = function(t6, e4) {
        const i4 = En[e4];
        if (i4) return i4(t6);
        throw new Error("unknown content type: ".concat(e4));
      }(this.compositionController.getSerializableElement(), "text/html");
      return this.editorElement.setFormValue(t5);
    }
    notifyEditorElement(t5, e4) {
      switch (t5) {
        case "document-change":
          this.documentChangedSinceLastRender = true;
          break;
        case "render":
          this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
          break;
        case "change":
        case "attachment-add":
        case "attachment-edit":
        case "attachment-remove":
          this.updateInputElement();
      }
      return this.editorElement.notify(t5, e4);
    }
    removeAttachment(t5) {
      return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t5), this.render();
    }
    recordFormattingUndoEntry(t5) {
      const e4 = mt(t5), i4 = this.selectionManager.getLocationRange();
      if (e4 || !Lt(i4)) return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
    }
    recordTypingUndoEntry() {
      return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
    }
    getUndoContext() {
      for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
      return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e4)];
    }
    getLocationContext() {
      const t5 = this.selectionManager.getLocationRange();
      return Lt(t5) ? t5[0].index : t5;
    }
    getTimeContext() {
      return V2.interval > 0 ? Math.floor((/* @__PURE__ */ new Date()).getTime() / V2.interval) : 0;
    }
    isFocused() {
      var t5;
      return this.editorElement === (null === (t5 = this.editorElement.ownerDocument) || void 0 === t5 ? void 0 : t5.activeElement);
    }
    isFocusedInvisibly() {
      return this.isFocused() && !this.getLocationRange();
    }
    get actions() {
      return this.constructor.actions;
    }
  };
  Di(_r, "actions", { undo: { test() {
    return this.editor.canUndo();
  }, perform() {
    return this.editor.undo();
  } }, redo: { test() {
    return this.editor.canRedo();
  }, perform() {
    return this.editor.redo();
  } }, link: { test() {
    return this.editor.canActivateAttribute("href");
  } }, increaseNestingLevel: { test() {
    return this.editor.canIncreaseNestingLevel();
  }, perform() {
    return this.editor.increaseNestingLevel() && this.render();
  } }, decreaseNestingLevel: { test() {
    return this.editor.canDecreaseNestingLevel();
  }, perform() {
    return this.editor.decreaseNestingLevel() && this.render();
  } }, attachFiles: { test: () => true, perform() {
    return _3.pickFiles(this.editor.insertFiles);
  } } }), _r.proxyMethod("getSelectionManager().setLocationRange"), _r.proxyMethod("getSelectionManager().getLocationRange");
  var jr = Object.freeze({ __proto__: null, AttachmentEditorController: Yn, CompositionController: Xn, Controller: $n, EditorController: _r, InputController: lr, Level0InputController: gr, Level2InputController: Ar, ToolbarController: Br });
  var Wr = Object.freeze({ __proto__: null, MutationObserver: er, SelectionChangeObserver: Ot });
  var Ur = Object.freeze({ __proto__: null, FileVerificationOperation: nr, ImagePreloadOperation: Ui });
  vt("trix-toolbar", "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}");
  var Vr = class extends HTMLElement {
    connectedCallback() {
      "" === this.innerHTML && (this.innerHTML = U2.getDefaultHTML());
    }
  };
  var zr = 0;
  var qr = function(t5) {
    if (!t5.hasAttribute("contenteditable")) return t5.setAttribute("contenteditable", ""), function(t6) {
      let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return e4.times = 1, b3(t6, e4);
    }("focus", { onElement: t5, withCallback: () => Hr(t5) });
  };
  var Hr = function(t5) {
    return Jr(t5), Kr(t5);
  };
  var Jr = function(t5) {
    var e4, i4;
    if (null !== (e4 = (i4 = document).queryCommandSupported) && void 0 !== e4 && e4.call(i4, "enableObjectResizing")) return document.execCommand("enableObjectResizing", false, false), b3("mscontrolselect", { onElement: t5, preventDefault: true });
  };
  var Kr = function(t5) {
    var e4, i4;
    if (null !== (e4 = (i4 = document).queryCommandSupported) && void 0 !== e4 && e4.call(i4, "DefaultParagraphSeparator")) {
      const { tagName: t6 } = n3.default;
      if (["div", "p"].includes(t6)) return document.execCommand("DefaultParagraphSeparator", false, t6);
    }
  };
  var Gr = a3.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
  vt("trix-editor", "%t {\n    display: block;\n}\n\n%t:empty::before {\n    content: attr(placeholder);\n    color: graytext;\n    cursor: text;\n    pointer-events: none;\n    white-space: pre-line;\n}\n\n%t a[contenteditable=false] {\n    cursor: text;\n}\n\n%t img {\n    max-width: 100%;\n    height: auto;\n}\n\n%t ".concat(e3, " figcaption textarea {\n    resize: none;\n}\n\n%t ").concat(e3, " figcaption textarea.trix-autoresize-clone {\n    position: absolute;\n    left: -9999px;\n    max-height: 0px;\n}\n\n%t ").concat(e3, " figcaption[data-trix-placeholder]:empty::before {\n    content: attr(data-trix-placeholder);\n    color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n    display: ").concat(Gr.display, " !important;\n    width: ").concat(Gr.width, " !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n    vertical-align: top !important;\n    margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n    vertical-align: bottom !important;\n    margin-right: -1px !important;\n}"));
  var Yr = /* @__PURE__ */ new WeakMap();
  var Xr = /* @__PURE__ */ new WeakSet();
  var $r = class {
    constructor(t5) {
      var e4, i4;
      _i(e4 = this, i4 = Xr), i4.add(e4), ji(this, Yr, { writable: true, value: void 0 }), this.element = t5, Oi(this, Yr, t5.attachInternals());
    }
    connectedCallback() {
      Bi(this, Xr, Zr).call(this);
    }
    disconnectedCallback() {
    }
    get labels() {
      return Ii(this, Yr).labels;
    }
    get disabled() {
      var t5;
      return null === (t5 = this.element.inputElement) || void 0 === t5 ? void 0 : t5.disabled;
    }
    set disabled(t5) {
      this.element.toggleAttribute("disabled", t5);
    }
    get required() {
      return this.element.hasAttribute("required");
    }
    set required(t5) {
      this.element.toggleAttribute("required", t5), Bi(this, Xr, Zr).call(this);
    }
    get validity() {
      return Ii(this, Yr).validity;
    }
    get validationMessage() {
      return Ii(this, Yr).validationMessage;
    }
    get willValidate() {
      return Ii(this, Yr).willValidate;
    }
    setFormValue(t5) {
      Bi(this, Xr, Zr).call(this);
    }
    checkValidity() {
      return Ii(this, Yr).checkValidity();
    }
    reportValidity() {
      return Ii(this, Yr).reportValidity();
    }
    setCustomValidity(t5) {
      Bi(this, Xr, Zr).call(this, t5);
    }
  };
  function Zr() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const { required: e4, value: i4 } = this.element, n4 = e4 && !i4, r4 = !!t5, o4 = T3("input", { required: e4 }), s4 = t5 || o4.validationMessage;
    Ii(this, Yr).setValidity({ valueMissing: n4, customError: r4 }, s4);
  }
  var Qr = /* @__PURE__ */ new WeakMap();
  var to = /* @__PURE__ */ new WeakMap();
  var eo = /* @__PURE__ */ new WeakMap();
  var io = class {
    constructor(t5) {
      ji(this, Qr, { writable: true, value: void 0 }), ji(this, to, { writable: true, value: (t6) => {
        t6.defaultPrevented || t6.target === this.element.form && this.element.reset();
      } }), ji(this, eo, { writable: true, value: (t6) => {
        if (t6.defaultPrevented) return;
        if (this.element.contains(t6.target)) return;
        const e4 = y3(t6.target, { matchingSelector: "label" });
        e4 && Array.from(this.labels).includes(e4) && this.element.focus();
      } }), this.element = t5;
    }
    connectedCallback() {
      Oi(this, Qr, function(t5) {
        if (t5.hasAttribute("aria-label") || t5.hasAttribute("aria-labelledby")) return;
        const e4 = function() {
          const e5 = Array.from(t5.labels).map((e6) => {
            if (!e6.contains(t5)) return e6.textContent;
          }).filter((t6) => t6), i4 = e5.join(" ");
          return i4 ? t5.setAttribute("aria-label", i4) : t5.removeAttribute("aria-label");
        };
        return e4(), b3("focus", { onElement: t5, withCallback: e4 });
      }(this.element)), window.addEventListener("reset", Ii(this, to), false), window.addEventListener("click", Ii(this, eo), false);
    }
    disconnectedCallback() {
      var t5;
      null === (t5 = Ii(this, Qr)) || void 0 === t5 || t5.destroy(), window.removeEventListener("reset", Ii(this, to), false), window.removeEventListener("click", Ii(this, eo), false);
    }
    get labels() {
      const t5 = [];
      this.element.id && this.element.ownerDocument && t5.push(...Array.from(this.element.ownerDocument.querySelectorAll("label[for='".concat(this.element.id, "']")) || []));
      const e4 = y3(this.element, { matchingSelector: "label" });
      return e4 && [this.element, null].includes(e4.control) && t5.push(e4), t5;
    }
    get disabled() {
      return console.warn("This browser does not support the [disabled] attribute for trix-editor elements."), false;
    }
    set disabled(t5) {
      console.warn("This browser does not support the [disabled] attribute for trix-editor elements.");
    }
    get required() {
      return console.warn("This browser does not support the [required] attribute for trix-editor elements."), false;
    }
    set required(t5) {
      console.warn("This browser does not support the [required] attribute for trix-editor elements.");
    }
    get validity() {
      return console.warn("This browser does not support the validity property for trix-editor elements."), null;
    }
    get validationMessage() {
      return console.warn("This browser does not support the validationMessage property for trix-editor elements."), "";
    }
    get willValidate() {
      return console.warn("This browser does not support the willValidate property for trix-editor elements."), false;
    }
    setFormValue(t5) {
    }
    checkValidity() {
      return console.warn("This browser does not support checkValidity() for trix-editor elements."), true;
    }
    reportValidity() {
      return console.warn("This browser does not support reportValidity() for trix-editor elements."), true;
    }
    setCustomValidity(t5) {
      console.warn("This browser does not support setCustomValidity(validationMessage) for trix-editor elements.");
    }
  };
  var no = /* @__PURE__ */ new WeakMap();
  var ro = class extends HTMLElement {
    constructor() {
      super(), ji(this, no, { writable: true, value: void 0 }), Oi(this, no, this.constructor.formAssociated ? new $r(this) : new io(this));
    }
    get trixId() {
      return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++zr), this.trixId);
    }
    get labels() {
      return Ii(this, no).labels;
    }
    get disabled() {
      return Ii(this, no).disabled;
    }
    set disabled(t5) {
      Ii(this, no).disabled = t5;
    }
    get required() {
      return Ii(this, no).required;
    }
    set required(t5) {
      Ii(this, no).required = t5;
    }
    get validity() {
      return Ii(this, no).validity;
    }
    get validationMessage() {
      return Ii(this, no).validationMessage;
    }
    get willValidate() {
      return Ii(this, no).willValidate;
    }
    get type() {
      return this.localName;
    }
    get toolbarElement() {
      var t5;
      if (this.hasAttribute("toolbar")) return null === (t5 = this.ownerDocument) || void 0 === t5 ? void 0 : t5.getElementById(this.getAttribute("toolbar"));
      if (this.parentNode) {
        const t6 = "trix-toolbar-".concat(this.trixId);
        return this.setAttribute("toolbar", t6), this.internalToolbar = T3("trix-toolbar", { id: t6 }), this.parentNode.insertBefore(this.internalToolbar, this), this.internalToolbar;
      }
    }
    get form() {
      var t5;
      return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.form;
    }
    get inputElement() {
      var t5;
      if (this.hasAttribute("input")) return null === (t5 = this.ownerDocument) || void 0 === t5 ? void 0 : t5.getElementById(this.getAttribute("input"));
      if (this.parentNode) {
        const t6 = "trix-input-".concat(this.trixId);
        this.setAttribute("input", t6);
        const e4 = T3("input", { type: "hidden", id: t6 });
        return this.parentNode.insertBefore(e4, this.nextElementSibling), e4;
      }
    }
    get editor() {
      var t5;
      return null === (t5 = this.editorController) || void 0 === t5 ? void 0 : t5.editor;
    }
    get name() {
      var t5;
      return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.name;
    }
    get value() {
      var t5;
      return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.value;
    }
    set value(t5) {
      var e4;
      this.defaultValue = t5, null === (e4 = this.editor) || void 0 === e4 || e4.loadHTML(this.defaultValue);
    }
    attributeChangedCallback(t5, e4, i4) {
      "connected" === t5 && this.isConnected && null != e4 && e4 !== i4 && requestAnimationFrame(() => this.reconnect());
    }
    notify(t5, e4) {
      if (this.editorController) return v3("trix-".concat(t5), { onElement: this, attributes: e4 });
    }
    setFormValue(t5) {
      this.inputElement && (this.inputElement.value = t5, Ii(this, no).setFormValue(t5));
    }
    connectedCallback() {
      this.hasAttribute("data-trix-internal") || (qr(this), function(t5) {
        if (!t5.hasAttribute("role")) t5.setAttribute("role", "textbox");
      }(this), this.editorController || (v3("trix-before-initialize", { onElement: this }), this.editorController = new _r({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => v3("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), Ii(this, no).connectedCallback(), this.toggleAttribute("connected", true), function(t5) {
        if (!document.querySelector(":focus") && t5.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t5) t5.focus();
      }(this));
    }
    disconnectedCallback() {
      var t5;
      null === (t5 = this.editorController) || void 0 === t5 || t5.unregisterSelectionManager(), Ii(this, no).disconnectedCallback(), this.toggleAttribute("connected", false);
    }
    reconnect() {
      this.removeInternalToolbar(), this.disconnectedCallback(), this.connectedCallback();
    }
    removeInternalToolbar() {
      var t5;
      null === (t5 = this.internalToolbar) || void 0 === t5 || t5.remove(), this.internalToolbar = null;
    }
    checkValidity() {
      return Ii(this, no).checkValidity();
    }
    reportValidity() {
      return Ii(this, no).reportValidity();
    }
    setCustomValidity(t5) {
      Ii(this, no).setCustomValidity(t5);
    }
    formDisabledCallback(t5) {
      this.inputElement && (this.inputElement.disabled = t5), this.toggleAttribute("contenteditable", !t5);
    }
    formResetCallback() {
      this.reset();
    }
    reset() {
      this.value = this.defaultValue;
    }
  };
  Di(ro, "formAssociated", "ElementInternals" in window), Di(ro, "observedAttributes", ["connected"]);
  var oo = { VERSION: t3, config: z3, core: Sn, models: zn, views: qn, controllers: jr, observers: Wr, operations: Ur, elements: Object.freeze({ __proto__: null, TrixEditorElement: ro, TrixToolbarElement: Vr }), filters: Object.freeze({ __proto__: null, Filter: In, attachmentGalleryFilter: On }) };
  Object.assign(oo, zn), window.Trix = oo, setTimeout(function() {
    customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Vr), customElements.get("trix-editor") || customElements.define("trix-editor", ro);
  }, 0);
})();
/*! Bundled license information:

@eonasdan/tempus-dominus/dist/plugins/fa-five.js:
  (*!
    * Tempus Dominus vv6.10.4 (https://getdatepicker.com/)
    * Copyright 2013-2025 Jonathan Peterson
    * Licensed under MIT (https://github.com/Eonasdan/tempus-dominus/blob/master/LICENSE)
    *)

@eonasdan/tempus-dominus/dist/plugins/customDateFormat.js:
  (*!
    * Tempus Dominus vv6.10.4 (https://getdatepicker.com/)
    * Copyright 2013-2025 Jonathan Peterson
    * Licensed under MIT (https://github.com/Eonasdan/tempus-dominus/blob/master/LICENSE)
    *)

compressorjs/dist/compressor.js:
  (*!
   * Compressor.js v1.2.1
   * https://fengyuanchen.github.io/compressorjs
   *
   * Copyright 2018-present Chen Fengyuan
   * Released under the MIT license
   *
   * Date: 2023-02-28T14:09:41.732Z
   *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

select2/dist/js/select2.js:
  (*!
   * Select2 4.1.0-rc.0
   * https://select2.github.io
   *
   * Released under the MIT license
   * https://github.com/select2/select2/blob/master/LICENSE.md
   *)
  (**
   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
   * Released under MIT license, http://github.com/requirejs/almond/LICENSE
   *)

@eonasdan/tempus-dominus/dist/js/tempus-dominus.esm.js:
  (*!
    * Tempus Dominus vv6.10.4 (https://getdatepicker.com/)
    * Copyright 2013-2025 Jonathan Peterson
    * Licensed under MIT (https://github.com/Eonasdan/tempus-dominus/blob/master/LICENSE)
    *)

@uppy/utils/lib/Translator.js:
  (**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {any[]} interpolated
   *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.12
  Copyright  2024 37signals LLC
   *)

trix/dist/trix.esm.min.js:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)
*/
//# sourceMappingURL=application.js.map
